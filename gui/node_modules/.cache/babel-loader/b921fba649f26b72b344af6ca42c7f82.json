{"ast":null,"code":"var _jsxFileName = \"/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js\",\n    _s = $RefreshSig$();\n\nimport './App.css';\nimport TextBox from \"./TextBox\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport axios from 'axios';\nimport { AwesomeButton } from \"react-awesome-button\";\nimport \"react-awesome-button/dist/styles.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Route() {\n  _s();\n\n  const [startLat, setStartLat] = useState(\"\");\n  const [startLon, setStartLon] = useState(\"\");\n  const [destLat, setDestLat] = useState(\"\");\n  const [destLon, setDestLon] = useState(\"\"); //const [route, setRoute] = useState([]);\n  //const [ways, setWays] = useState([]);\n\n  const CANVAS_SIDE_LENGTH = 450;\n  const CLICK_RANGE = 5; //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n  // are implemented\n\n  let topLat = 41.8320;\n  let leftLon = -71.4070;\n  let latLonRange = 0.0113;\n  let mouseDownX;\n  let mouseDownY; // We expect latitudes within the map range to be LESS than the topLat\n  // We expect longitudes within the map range to be GREATER than the leftLon\n  // In order to get bottomLat or rightLon, just subtract latLonRange from topLat, or add it to leftLon\n\n  const TILE_WIDTH = 0.0016; // this is an arbitrarily chosen-value, but it works well\n\n  let topmostTileLat = topLat;\n  let leftmostTileLon = leftLon;\n  let bottommostTileLat = topmostTileLat;\n  let rightmostTileLon = leftmostTileLon;\n  let tilesLoaded = []; // Tiles should be JavaScript objects with properties topLat, leftLon, and an [] of ways\n  // Ways should be length-4 list of Doubles: [lat1, lon1, lat2, lon2]\n\n  const canvasRef = useRef();\n  let ctxRef = useRef();\n  /**\n   * Code to run when the page loads\n   */\n\n  useEffect(() => {\n    //console.log(\"page loaded!\");\n    const canvas = canvasRef.current;\n    canvas.width = CANVAS_SIDE_LENGTH;\n    canvas.height = CANVAS_SIDE_LENGTH;\n    ctxRef.current = canvas.getContext(\"2d\"); // let ctx = ctxRef.current;\n    // ctx.fillStyle = \"green\";\n    // ctx.fillRect(0, 0, 100, 100);\n    // Load tiles\n\n    loadStartingTiles();\n  }, []);\n\n  function loadStartingTiles() {\n    console.log(\"Loading starting tiles\");\n    const boundaries = getMapBoundaries();\n    loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n  }\n\n  async function loadTilesWithin(topLatLimit, leftLonLimit, bottomLatLimit, rightLonLimit) {\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n    let newTile;\n    let curLat = topLatLimit;\n    let curLon = leftLonLimit;\n\n    while (curLon < rightLonLimit) {\n      while (curLat > bottomLatLimit) {\n        // Check if the tile has already been loaded\n        if (!tileLoaded(curLat, curLon)) {\n          const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH)); //console.log(ways);\n\n          newTile = {\n            \"tileLat\": curLat,\n            \"tileLon\": curLon,\n            \"ways\": ways,\n            \"name\": Math.round(Math.random() * 100)\n          }; // TODO eventually delete the randomly-generated \"name\" property\n\n          drawTile(newTile); // console.log(newTile);\n\n          console.log(\"adding tile\");\n          tilesLoaded.push(newTile);\n        }\n\n        curLat -= TILE_WIDTH;\n      } // console.log(\"curLat: \" + curLat);\n\n\n      if (curLat < bottommostTileLat) {\n        bottommostTileLat = curLat;\n      }\n\n      curLat = topLatLimit;\n      curLon += TILE_WIDTH;\n    }\n\n    if (curLon > rightmostTileLon) {\n      rightmostTileLon = curLon;\n    }\n  }\n  /**\n   * Determines whether a tile with a given lat/lon coordinate has been cached on the client-side\n   * or note. Returns a boolean.\n   * @param lat - latitude coordinate of tile to check\n   * @param lon - longitude coordinate of tile to check\n   * @returns {boolean} - whether or not the tile is cached already\n   */\n\n\n  function tileLoaded(lat, lon) {\n    let loaded = false;\n    let checkTile;\n\n    for (let i = 0; i < tilesLoaded.length; i++) {\n      checkTile = tilesLoaded[i];\n      loaded = loaded || checkTile[\"tileLat\"] === lat && checkTile[\"tileLon\"] === lon;\n    }\n\n    return loaded;\n  }\n  /**\n   * Makes an axios request.\n   */\n\n\n  async function requestRoute() {\n    const toSend = {\n      srclat: startLat,\n      srclong: startLon,\n      destlat: destLat,\n      destlong: destLon\n    };\n    console.log(toSend);\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    axios.post(\"http://localhost:4567/route\", toSend, config); // .then(response => {\n    //     console.log(response.data);\n    //     // TODO: make sure that the \"route\" here corresponds to the correct data we want back\n    //     //setRoute(response.data[\"route\"]);\n    // })\n    // .catch(function (error) {\n    //     console.log(error);\n    //});\n\n    const res = await axios.post(\"http://localhost:4567/route\", toSend, config);\n    console.log(res);\n    return res[\"data\"][\"route\"];\n  } //uses post request to get ways within bounding box\n\n\n  async function requestWays(coordinates) {\n    const toSend = {\n      lat1: coordinates[0],\n      long1: coordinates[1],\n      lat2: coordinates[2],\n      long2: coordinates[3]\n    };\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    const res = await axios.post(\"http://localhost:4567/ways\", toSend, config);\n    return res[\"data\"][\"ways\"];\n  }\n  /**\n   * Makes an axios request to get the coordinates of the node nearest to a clicked lat and lon.\n   */\n\n\n  function requestNearest(lat, lon, latSetter, lonSetter) {\n    const toSend = {\n      lat: lat,\n      lon: lon\n    };\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    axios.post(\"http://localhost:4567/nearest\", toSend, config).then(response => {\n      console.log(response.data);\n      return response.data;\n    }).then(data => {\n      const newLat = data[\"nearestLat\"];\n      const newLon = data[\"nearestLon\"];\n      latSetter(newLat);\n      lonSetter(newLon);\n      reloadMap();\n    }).catch(function (error) {\n      console.log(error);\n    });\n  }\n\n  function clearLoadTiles() {\n    clearCanvas(); // First, purge old tiles\n\n    const mapBoundaries = getMapBoundaries(); //these are backwards\n\n    const bottomLat = mapBoundaries[2];\n    const rightLon = mapBoundaries[3];\n    let saveTiles = []; // Iterate over all the loaded tiles and see if they're still useful\n\n    for (let i = 0; i < tilesLoaded.length; i++) {\n      const checkTile = tilesLoaded[i];\n      const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH); // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n\n      const tileTopLat = tileBoundaries[0];\n      const tileLeftLon = tileBoundaries[1];\n      const tileBottomLat = tileBoundaries[2];\n      const tileRightLon = tileBoundaries[3]; // We expect latitudes within the map range to be LESS than the topLat\n      // We expect longitudes within the map range to be GREATER than the leftLon\n\n      const deleteTile = tileBottomLat > topLat || tileTopLat < bottomLat || tileRightLon < leftLon || tileLeftLon > rightLon; // if (tileBottomLat > topLat) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n      // }\n      // if (tileLeftLon > rightLon) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the right side\");\n      // }\n      // if (deleteTile) {\n      //     console.log(\"deleting tile\");\n      // }\n\n      if (!deleteTile) {\n        drawTile(tilesLoaded[i]);\n        saveTiles.push(checkTile);\n      }\n    }\n\n    tilesLoaded = saveTiles; // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n    // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n\n    while (getBoundingBox(topmostTileLat, leftmostTileLon, TILE_WIDTH)[2] > topLat) {\n      // console.log(\"adjusting loaded top boundary\");\n      topmostTileLat -= TILE_WIDTH;\n    }\n\n    while (getBoundingBox(topmostTileLat, leftmostTileLon, TILE_WIDTH)[3] < leftLon) {\n      // console.log(\"adjusting loaded left boundary\");\n      leftmostTileLon += TILE_WIDTH;\n    }\n\n    while (bottommostTileLat < bottomLat) {\n      // console.log(\"adjusting loaded bottom boundary\");\n      bottommostTileLat += TILE_WIDTH;\n    }\n\n    while (rightmostTileLon > rightLon) {\n      // console.log(\"adjusting loaded right boundary\");\n      rightmostTileLon -= TILE_WIDTH;\n    } // Now, load new tiles\n\n\n    while (leftmostTileLon > leftLon) {\n      //console.log(\"gap at left\");\n      // loadTilesWithin(topmostTileLat, leftmostTileLon - TILE_WIDTH, bottommostTileLat, leftmostTileLon);\n      leftmostTileLon -= TILE_WIDTH;\n    }\n\n    while (topmostTileLat < topLat) {\n      //console.log(\"gap at top\");\n      // loadTilesWithin(topmostTileLat + TILE_WIDTH, leftmostTileLon, topmostTileLat, rightmostTileLon);\n      topmostTileLat += TILE_WIDTH;\n    }\n\n    while (bottommostTileLat >= bottomLat) {\n      //console.log(\"gap at bottom\");\n\n      /*loadTilesWithin(bottommostTileLat, leftmostTileLon - TILE_WIDTH,\n          bottommostTileLat - (2.0 * TILE_WIDTH), rightmostTileLon);*/\n      bottommostTileLat -= TILE_WIDTH;\n    }\n\n    while (rightmostTileLon <= rightLon) {\n      //console.log(\"gap at right\");\n\n      /*loadTilesWithin(topmostTileLat, rightmostTileLon + TILE_WIDTH,\n          bottommostTileLat, rightmostTileLon + (2.0 * TILE_WIDTH));*/\n      rightmostTileLon += TILE_WIDTH;\n    }\n\n    loadTilesWithin(topmostTileLat, leftmostTileLon, bottommostTileLat, rightmostTileLon); // console.log(\"num tiles after loading: \" + tilesLoaded.length);\n    //drawLoadedRect();\n  }\n\n  function reloadMap() {\n    clearLoadTiles(); // And add the circles for the selected start/destination!\n\n    const radius = pixIfy(latLonRange / 100); //console.log(\"startLat and startLon:\");\n    //console.log(startLat + \" \" + startLon);\n\n    if (!(parseFloat(startLon) === 0 || startLon.toString() === \"\" || parseFloat(startLat) === 0 || startLat.toString() === \"\")) {\n      console.log(\"drawing start circle\");\n      drawCircle(startLat, startLon, radius);\n    }\n\n    if (!(parseFloat(destLon) === 0 || destLon.toString() === \"\" || parseFloat(destLat) === 0 || destLat.toString() === \"\")) {\n      console.log(\"drawing destination circle\");\n      drawCircle(destLat, destLon, radius);\n    }\n  }\n  /**\n   * Code to turn lat/lon coordinates into pixel coordinates for the canvas:\n   * takes in a latitude and longitude coordinate, returns a length-2 list with the\n   * corresponding pixel position on the canvas [left, top]\n   * @param lat - the latitude coordinate to turn into a pixel left coordinate\n   * @param lon - the longitude coordinate to turn into a pixel top coordinate\n   * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n   */\n\n\n  function latLonCoordToPix(lat, lon) {\n    const normalizedLat = topLat - lat;\n    const normalizedLon = lon - leftLon; // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n    // REMEMBER: lat is y-value, lon is x-value!\n\n    return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n  }\n  /**\n   * Converts a single latitude/longitude coordinate value into a pixel value.\n   * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n   * @returns {number} the pixel conversion of the lat/lon value\n   */\n\n\n  function pixIfy(latLonVal) {\n    const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n    return latLonVal * pixOverLatLonFactor;\n  }\n  /**\n   * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n   * and longitude coordinate.\n   * Returns a length-2 list with [lat, lon].\n   * @param left - the pixel left coordinate to turn into map latitude\n   * @param top - the pixel top coordinate to turn into map longitude\n   * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n   */\n\n\n  function pixCoordToLatLon(left, top) {\n    const canvas = canvasRef.current;\n    const normalizedLeft = left - canvas.offsetLeft;\n    const normalizedTop = top - canvas.offsetTop; // console.log(normalizedLeft + \", \" + normalizedTop);\n    // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n    const returnLat = topLat - latLonIfy(normalizedTop);\n    const returnLon = leftLon + latLonIfy(normalizedLeft); // console.log(returnLat, \", \", returnLon)\n    // console.log(latLonCoordToPix(returnLat, returnLon));\n    // REMEMBER: lat is y-value, lon is x-value!\n\n    return [returnLat, returnLon];\n  }\n  /**\n   * Turns a single value in pixels into a value in latitude/longitude coordinates.\n   * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n   * @returns {number} the lat/lon conversion of the pixel value\n   */\n\n\n  function latLonIfy(pixVal) {\n    const latLonOverPixFactor = latLonRange / CANVAS_SIDE_LENGTH;\n    return pixVal * latLonOverPixFactor;\n  }\n  /**\n   * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n   * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of the current map frame.\n   */\n\n\n  function getMapBoundaries() {\n    return getBoundingBox(topLat, leftLon, latLonRange);\n  }\n  /**\n   * Get the lat/lon boundaries of a passed square area with unknown side length.\n   * @param boxtopLat latitude coordinate of the northwest corner\n   * @param boxleftLon longitude coordinate of the northwest corner\n   * @param boxRange side length, in terms of lat/lon coordinates\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of a passed square.\n   */\n\n\n  function getBoundingBox(boxtopLat, boxleftLon, boxRange) {\n    // REMEMBER: lat is y-value, lon is x-value!\n    return [boxtopLat, boxleftLon, boxtopLat - boxRange, boxleftLon + boxRange];\n  }\n\n  function handleClickOrDrag(mouseUpX, mouseUpY) {\n    const xChange = mouseUpX - mouseDownX; // positive if the map is dragged to the right\n\n    const yChange = mouseUpY - mouseDownY; // positive if the map is dragged downwards\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n\n    if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n      console.log(\"clicked\"); // This was a click!\n\n      const ctx = ctxRef.current;\n      ctx.fillStyle = \"green\"; // console.log(pixCoordToLatLon(mouseUpX, mouseUpY));\n\n      const latLonCoord = pixCoordToLatLon(mouseUpX, mouseUpY); //if (startLat === 0 || startLat.toString() === \"\")\n\n      if (startLat === \"\") {\n        requestNearest(latLonCoord[0], latLonCoord[1], setStartLat, setStartLon);\n      } else if (destLat === \"\") {\n        requestNearest(latLonCoord[0], latLonCoord[1], setDestLat, setDestLon);\n      } else {\n        let route = requestRoute();\n        route.forEach(traceRoute);\n      }\n    } else {\n      // This was a drag!\n      // REMEMBER: lat is y-value, lon is x-value!\n      //console.log(xChange, yChange);\n      //console.log(latLonIfy(xChange), latLonIfy(yChange));\n      //console.log(topLat + \", \" + leftLon);\n      // TODO: this may want to get changed to a setParamName() function call when setState is used\n      leftLon -= latLonIfy(xChange);\n      /*\n       * positive values, dragging the map to the right\n       * moves the previous leftLon rightwards\n       * meaning that the new leftLon should be less than the previous leftLon\n       */\n\n      topLat += latLonIfy(yChange);\n      /*\n       * positive values, dragging the map downwards\n       * moves the previous topLat downwards\n       * meaning that the new topLat should be greater than the previous topLat\n       */\n      //console.log(topLat + \", \" + leftLon);\n\n      reloadMap();\n    }\n  }\n\n  function handleZoomInOut(zoomedOut, mouseX, mouseY) {\n    const mouseLatLonCoord = pixCoordToLatLon(mouseX, mouseY);\n    const zoomLatNormalized = topLat - mouseLatLonCoord[0];\n    const zoomLonNormalized = mouseLatLonCoord[1] - leftLon;\n    const latFraction = zoomLatNormalized / latLonRange;\n    const lonFraction = zoomLonNormalized / latLonRange; // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n\n    if (zoomedOut) {\n      const stepSize = latLonRange * 1.05 - latLonRange;\n      latLonRange += stepSize; // We're zooming out, so the topLat should move upwards\n\n      topLat += latFraction * stepSize; // and leftLon should move leftwards\n\n      leftLon -= lonFraction * stepSize;\n    } else {\n      const stepSize = latLonRange - latLonRange * 0.95;\n      latLonRange -= stepSize; // We're zooming in, so the topLat should move downwards\n\n      topLat -= latFraction * stepSize; // and leftLon should move inwards\n\n      leftLon += lonFraction * stepSize;\n    }\n\n    reloadMap();\n  }\n\n  function clearCanvas() {\n    const ctx = ctxRef.current;\n    const canvas = canvasRef.current;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  function drawTile(tileToDraw) {\n    tileToDraw[\"ways\"].forEach(traceWay);\n  }\n\n  function drawCircle(lat, lon, radius) {\n    const ctx = ctxRef.current;\n    const pixCoord = latLonCoordToPix(lat, lon);\n    ctx.strokeStyle = \"red\";\n    ctx.beginPath();\n    ctx.arc(pixCoord[0], pixCoord[1], radius, 0, 2 * Math.PI);\n    ctx.stroke();\n  }\n\n  function drawLoadedRect() {\n    const ctx = ctxRef.current;\n    const loadedPixBoxTopLeft = latLonCoordToPix(topmostTileLat, leftmostTileLon);\n    const loadedPixBoxBottomRight = latLonCoordToPix(bottommostTileLat, rightmostTileLon);\n    const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n    const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n    ctx.strokeStyle = \"red\";\n    ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n  }\n\n  function drawSquare(tileToDraw) {\n    const ctx = ctxRef.current;\n    ctx.fillStyle = \"lightgreen\";\n    const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n    const baseX = tileCoord[0];\n    const baseY = tileCoord[1];\n    const pixTileWidth = pixIfy(TILE_WIDTH); // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n    //      Math.min(baseX + pixTileWidth, pixTileWidth),\n    //      Math.min(baseY + pixTileWidth, pixTileWidth));\n\n    ctx.strokeStyle = \"black\";\n    ctx.strokeRect(Math.max(baseX, 0), Math.max(baseY, 0), Math.min(baseX + pixTileWidth, pixTileWidth), Math.min(baseY + pixTileWidth, pixTileWidth));\n    ctx.fillStyle = \"black\";\n    ctx.fillText(tileToDraw[\"name\"], baseX + pixTileWidth / 2.0, baseY + pixTileWidth / 2.0);\n  } // function drawWays(tileToDraw) {\n  //     const canvas = $('#canvas')[0]; // Getting a reference to the <canvas> element that has an ID of 'canvas'\n  //     canvas.width = TILE_WIDTH;\n  //     canvas.height = TILE_WIDTH;\n  //     tileToDraw.ways.forEach(traceWay)\n  // }\n\n\n  function traceRoute(way) {\n    const ctx = ctxRef.current;\n    let startLatCoord = way[\"startLat\"];\n    let startLonCoord = way[\"startLong\"];\n    let pixStart = latLonCoordToPix(startLatCoord, startLonCoord);\n    ctx.fillStyle = \"blue\";\n    ctx.strokeStyle = \"blue\";\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(pixStart[0], pixStart[1]);\n    let endLatCoord = way[\"destLat\"]; //console.log(endLatCoord)\n\n    let endLongCoord = way[\"destLong\"]; //console.log(endLongCoord)\n\n    let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord); //console.log(pixEnd)\n\n    ctx.lineTo(pixEnd[0], pixEnd[1]);\n    ctx.stroke();\n  }\n\n  function traceWay(way) {\n    //console.log(way)\n    //probably should change wayslist into a hashmap\n    const ctx = ctxRef.current; //let c = document.getElementById(\"myCanvas\");\n    //let ctx = c.getContext(\"2d\");\n\n    let startLatCoord = way[\"startLat\"];\n    let startLonCoord = way[\"startLong\"];\n    let pixStart = latLonCoordToPix(startLatCoord, startLonCoord); //console.log(pixStart)\n\n    ctx.fillStyle = \"black\";\n    ctx.strokeStyle = \"black\";\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(pixStart[0], pixStart[1]);\n    let endLatCoord = way[\"destLat\"]; //console.log(endLatCoord)\n\n    let endLongCoord = way[\"destLong\"]; //console.log(endLongCoord)\n\n    let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord); //console.log(pixEnd)\n\n    ctx.lineTo(pixEnd[0], pixEnd[1]);\n    ctx.stroke();\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Maps GUI\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 578,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Latitude\",\n      boxVal: startLat,\n      change: setStartLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 579,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Longitude\",\n      boxVal: startLon,\n      change: setStartLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 580,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Latitude\",\n      boxVal: destLat,\n      change: setDestLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 581,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Longitude\",\n      boxVal: destLon,\n      change: setDestLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 582,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(AwesomeButton, {\n      type: \"primary\",\n      onPress: requestRoute,\n      children: \"Submit!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 583,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 584,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      onMouseDown: event => {\n        mouseDownX = event.pageX;\n        mouseDownY = event.pageY;\n      },\n      onMouseUp: event => {\n        //pixCoordToLatLon(event.pageX, event.pageY);\n        handleClickOrDrag(event.pageX, event.pageY);\n      },\n      onWheel: event => {\n        event.stopPropagation(); // Scrolling!\n\n        if (event.deltaY < 0) {\n          // Scrolling up\n          handleZoomInOut(false, event.pageX, event.pageY);\n        } else {\n          // Scrolling down\n          handleZoomInOut(true, event.pageX, event.pageY);\n        }\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 588,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 577,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Route, \"S9cX8xz8sIglcJFTa3ahfgvs3Vc=\");\n\n_c = Route;\nexport default Route;\n\nvar _c;\n\n$RefreshReg$(_c, \"Route\");","map":{"version":3,"sources":["/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js"],"names":["TextBox","React","useState","useEffect","useRef","axios","AwesomeButton","Route","startLat","setStartLat","startLon","setStartLon","destLat","setDestLat","destLon","setDestLon","CANVAS_SIDE_LENGTH","CLICK_RANGE","topLat","leftLon","latLonRange","mouseDownX","mouseDownY","TILE_WIDTH","topmostTileLat","leftmostTileLon","bottommostTileLat","rightmostTileLon","tilesLoaded","canvasRef","ctxRef","canvas","current","width","height","getContext","loadStartingTiles","console","log","boundaries","getMapBoundaries","loadTilesWithin","topLatLimit","leftLonLimit","bottomLatLimit","rightLonLimit","newTile","curLat","curLon","tileLoaded","ways","requestWays","getBoundingBox","Math","round","random","drawTile","push","lat","lon","loaded","checkTile","i","length","requestRoute","toSend","srclat","srclong","destlat","destlong","config","headers","post","res","coordinates","lat1","long1","lat2","long2","requestNearest","latSetter","lonSetter","then","response","data","newLat","newLon","reloadMap","catch","error","clearLoadTiles","clearCanvas","mapBoundaries","bottomLat","rightLon","saveTiles","tileBoundaries","tileTopLat","tileLeftLon","tileBottomLat","tileRightLon","deleteTile","radius","pixIfy","parseFloat","toString","drawCircle","latLonCoordToPix","normalizedLat","normalizedLon","latLonVal","pixOverLatLonFactor","pixCoordToLatLon","left","top","normalizedLeft","offsetLeft","normalizedTop","offsetTop","returnLat","latLonIfy","returnLon","pixVal","latLonOverPixFactor","boxtopLat","boxleftLon","boxRange","handleClickOrDrag","mouseUpX","mouseUpY","xChange","yChange","abs","ctx","fillStyle","latLonCoord","route","forEach","traceRoute","handleZoomInOut","zoomedOut","mouseX","mouseY","mouseLatLonCoord","zoomLatNormalized","zoomLonNormalized","latFraction","lonFraction","stepSize","clearRect","tileToDraw","traceWay","pixCoord","strokeStyle","beginPath","arc","PI","stroke","drawLoadedRect","loadedPixBoxTopLeft","loadedPixBoxBottomRight","loadedPixBoxWidth","loadedPixBoxHeight","strokeRect","drawSquare","tileCoord","baseX","baseY","pixTileWidth","max","min","fillText","way","startLatCoord","startLonCoord","pixStart","lineWidth","moveTo","endLatCoord","endLongCoord","pixEnd","lineTo","event","pageX","pageY","stopPropagation","deltaY"],"mappings":"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","sourcesContent":["import './App.css';\nimport TextBox from \"./TextBox\";\nimport React, {useState, useEffect, useRef} from 'react';\nimport axios from 'axios';\nimport { AwesomeButton } from \"react-awesome-button\";\nimport \"react-awesome-button/dist/styles.css\";\n\nfunction Route() {\n    const [startLat, setStartLat] = useState(\"\");\n    const [startLon, setStartLon] = useState(\"\");\n    const [destLat, setDestLat] = useState(\"\");\n    const [destLon, setDestLon] = useState(\"\");\n    //const [route, setRoute] = useState([]);\n    //const [ways, setWays] = useState([]);\n    const CANVAS_SIDE_LENGTH = 450;\n    const CLICK_RANGE = 5;\n    //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n    // are implemented\n    let topLat = 41.8320;\n    let leftLon = -71.4070;\n    let latLonRange = 0.0113;\n    let mouseDownX;\n    let mouseDownY;\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n    // In order to get bottomLat or rightLon, just subtract latLonRange from topLat, or add it to leftLon\n\n    const TILE_WIDTH = 0.0016; // this is an arbitrarily chosen-value, but it works well\n    let topmostTileLat = topLat;\n    let leftmostTileLon = leftLon;\n    let bottommostTileLat = topmostTileLat;\n    let rightmostTileLon = leftmostTileLon;\n    let tilesLoaded = [];\n    // Tiles should be JavaScript objects with properties topLat, leftLon, and an [] of ways\n    // Ways should be length-4 list of Doubles: [lat1, lon1, lat2, lon2]\n\n    const canvasRef = useRef();\n    let ctxRef = useRef();\n\n    /**\n     * Code to run when the page loads\n     */\n    useEffect(() => {\n        //console.log(\"page loaded!\");\n        const canvas = canvasRef.current;\n        canvas.width = CANVAS_SIDE_LENGTH;\n        canvas.height = CANVAS_SIDE_LENGTH;\n        ctxRef.current = canvas.getContext(\"2d\");\n        // let ctx = ctxRef.current;\n        // ctx.fillStyle = \"green\";\n        // ctx.fillRect(0, 0, 100, 100);\n\n        // Load tiles\n        loadStartingTiles();\n    }, []);\n\n    function loadStartingTiles() {\n        console.log(\"Loading starting tiles\");\n        const boundaries = getMapBoundaries();\n        loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n    }\n\n    async function loadTilesWithin(topLatLimit, leftLonLimit, bottomLatLimit, rightLonLimit) {\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n        let newTile;\n        let curLat = topLatLimit;\n        let curLon = leftLonLimit;\n        while (curLon < rightLonLimit) {\n            while (curLat > bottomLatLimit) {\n                // Check if the tile has already been loaded\n                if (!tileLoaded(curLat, curLon)) {\n                    const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n                    //console.log(ways);\n                    newTile = {\"tileLat\": curLat, \"tileLon\": curLon, \"ways\": ways, \"name\":Math.round(Math.random()*100)};\n                    // TODO eventually delete the randomly-generated \"name\" property\n                    drawTile(newTile);\n\n                    // console.log(newTile);\n                    console.log(\"adding tile\");\n                    tilesLoaded.push(newTile);\n                }\n\n                curLat -= TILE_WIDTH;\n            }\n            // console.log(\"curLat: \" + curLat);\n            if (curLat < bottommostTileLat) {\n                bottommostTileLat = curLat;\n            }\n            curLat = topLatLimit;\n            curLon += TILE_WIDTH;\n        }\n        if (curLon > rightmostTileLon) {\n            rightmostTileLon = curLon;\n        }\n    }\n\n    /**\n     * Determines whether a tile with a given lat/lon coordinate has been cached on the client-side\n     * or note. Returns a boolean.\n     * @param lat - latitude coordinate of tile to check\n     * @param lon - longitude coordinate of tile to check\n     * @returns {boolean} - whether or not the tile is cached already\n     */\n    function tileLoaded(lat, lon) {\n        let loaded = false;\n        let checkTile;\n        for (let i = 0; i < tilesLoaded.length; i++) {\n            checkTile = tilesLoaded[i];\n            loaded = loaded || (checkTile[\"tileLat\"] === lat && checkTile[\"tileLon\"] === lon);\n        }\n        return loaded;\n    }\n\n    /**\n     * Makes an axios request.\n     */\n    async function requestRoute() {\n        const toSend = {\n            srclat: startLat,\n            srclong: startLon,\n            destlat: destLat,\n            destlong: destLon\n        };\n        console.log(toSend);\n\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n        axios.post(\n            \"http://localhost:4567/route\",\n            toSend,\n            config\n        )\n            // .then(response => {\n            //     console.log(response.data);\n            //     // TODO: make sure that the \"route\" here corresponds to the correct data we want back\n            //     //setRoute(response.data[\"route\"]);\n            // })\n            // .catch(function (error) {\n            //     console.log(error);\n            //});\n        const res = await axios.post(\n            \"http://localhost:4567/route\",\n            toSend,\n            config\n        );\n        console.log(res);\n        return res[\"data\"][\"route\"];\n    }\n\n    //uses post request to get ways within bounding box\n    async function requestWays(coordinates) {\n        const toSend = {\n            lat1: coordinates[0],\n            long1: coordinates[1],\n            lat2: coordinates[2],\n            long2: coordinates[3]\n        };\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n        const res = await axios.post(\n            \"http://localhost:4567/ways\",\n            toSend,\n            config\n        );\n        return res[\"data\"][\"ways\"];\n    }\n\n    /**\n     * Makes an axios request to get the coordinates of the node nearest to a clicked lat and lon.\n     */\n    function requestNearest(lat, lon, latSetter, lonSetter) {\n        const toSend = {\n            lat: lat,\n            lon: lon\n        };\n\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n\n        axios.post(\n            \"http://localhost:4567/nearest\",\n            toSend,\n            config\n        )\n            .then(response => {\n                console.log(response.data);\n                return response.data;\n            })\n            .then((data) => {\n                const newLat = data[\"nearestLat\"];\n                const newLon = data[\"nearestLon\"];\n                latSetter(newLat);\n                lonSetter(newLon);\n                reloadMap();\n            })\n            .catch(function (error) {\n                console.log(error);\n            });\n    }\n\n    function clearLoadTiles() {\n        clearCanvas();\n\n        // First, purge old tiles\n        const mapBoundaries = getMapBoundaries();\n        //these are backwards\n        const bottomLat = mapBoundaries[2];\n        const rightLon = mapBoundaries[3];\n        let saveTiles = [];\n        // Iterate over all the loaded tiles and see if they're still useful\n        for (let i = 0; i < tilesLoaded.length; i++) {\n            const checkTile = tilesLoaded[i];\n            const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n            // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n            const tileTopLat = tileBoundaries[0];\n            const tileLeftLon = tileBoundaries[1];\n            const tileBottomLat = tileBoundaries[2];\n            const tileRightLon = tileBoundaries[3];\n            // We expect latitudes within the map range to be LESS than the topLat\n            // We expect longitudes within the map range to be GREATER than the leftLon\n            const deleteTile = (tileBottomLat > topLat) || (tileTopLat < bottomLat)\n                || (tileRightLon < leftLon) || (tileLeftLon > rightLon);\n            // if (tileBottomLat > topLat) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n            // }\n            // if (tileLeftLon > rightLon) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the right side\");\n            // }\n            // if (deleteTile) {\n            //     console.log(\"deleting tile\");\n            // }\n            if (!deleteTile) {\n                drawTile(tilesLoaded[i]);\n                saveTiles.push(checkTile);\n            }\n        }\n        tilesLoaded = saveTiles;\n\n        // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n        // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n        while (getBoundingBox(topmostTileLat, leftmostTileLon, TILE_WIDTH)[2] > topLat){\n            // console.log(\"adjusting loaded top boundary\");\n            topmostTileLat -= TILE_WIDTH;\n        }\n        while (getBoundingBox(topmostTileLat, leftmostTileLon, TILE_WIDTH)[3] < leftLon){\n            // console.log(\"adjusting loaded left boundary\");\n            leftmostTileLon += TILE_WIDTH;\n        }\n        while (bottommostTileLat < bottomLat){\n            // console.log(\"adjusting loaded bottom boundary\");\n            bottommostTileLat += TILE_WIDTH;\n        }\n        while (rightmostTileLon > rightLon){\n            // console.log(\"adjusting loaded right boundary\");\n            rightmostTileLon -= TILE_WIDTH;\n        }\n\n        // Now, load new tiles\n        while (leftmostTileLon > leftLon) {\n            //console.log(\"gap at left\");\n            // loadTilesWithin(topmostTileLat, leftmostTileLon - TILE_WIDTH, bottommostTileLat, leftmostTileLon);\n            leftmostTileLon -= TILE_WIDTH;\n        }\n        while (topmostTileLat < topLat) {\n            //console.log(\"gap at top\");\n            // loadTilesWithin(topmostTileLat + TILE_WIDTH, leftmostTileLon, topmostTileLat, rightmostTileLon);\n            topmostTileLat += TILE_WIDTH;\n        }\n        while (bottommostTileLat >= bottomLat) {\n            //console.log(\"gap at bottom\");\n            /*loadTilesWithin(bottommostTileLat, leftmostTileLon - TILE_WIDTH,\n                bottommostTileLat - (2.0 * TILE_WIDTH), rightmostTileLon);*/\n            bottommostTileLat -= TILE_WIDTH;\n        }\n        while (rightmostTileLon <= rightLon) {\n            //console.log(\"gap at right\");\n            /*loadTilesWithin(topmostTileLat, rightmostTileLon + TILE_WIDTH,\n                bottommostTileLat, rightmostTileLon + (2.0 * TILE_WIDTH));*/\n            rightmostTileLon += TILE_WIDTH;\n        }\n        loadTilesWithin(topmostTileLat, leftmostTileLon, bottommostTileLat, rightmostTileLon);\n        // console.log(\"num tiles after loading: \" + tilesLoaded.length);\n        //drawLoadedRect();\n    }\n\n    function reloadMap() {\n        clearLoadTiles();\n        // And add the circles for the selected start/destination!\n        const radius = pixIfy(latLonRange / 100);\n        //console.log(\"startLat and startLon:\");\n        //console.log(startLat + \" \" + startLon);\n        if (!(parseFloat(startLon) === 0 || startLon.toString() === \"\"\n            || parseFloat(startLat) === 0 || startLat.toString() === \"\")){\n            console.log(\"drawing start circle\");\n            drawCircle(startLat, startLon, radius);\n        }\n        if (!(parseFloat(destLon) === 0 || destLon.toString() === \"\"\n            || parseFloat(destLat) === 0 || destLat.toString() === \"\")){\n            console.log(\"drawing destination circle\");\n            drawCircle(destLat, destLon, radius);\n        }\n    }\n\n    /**\n     * Code to turn lat/lon coordinates into pixel coordinates for the canvas:\n     * takes in a latitude and longitude coordinate, returns a length-2 list with the\n     * corresponding pixel position on the canvas [left, top]\n     * @param lat - the latitude coordinate to turn into a pixel left coordinate\n     * @param lon - the longitude coordinate to turn into a pixel top coordinate\n     * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n     */\n    function latLonCoordToPix(lat, lon) {\n        const normalizedLat = topLat - lat;\n        const normalizedLon = lon - leftLon;\n        // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n    }\n\n    /**\n     * Converts a single latitude/longitude coordinate value into a pixel value.\n     * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n     * @returns {number} the pixel conversion of the lat/lon value\n     */\n    function pixIfy(latLonVal) {\n        const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n        return latLonVal * pixOverLatLonFactor;\n    }\n\n    /**\n     * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n     * and longitude coordinate.\n     * Returns a length-2 list with [lat, lon].\n     * @param left - the pixel left coordinate to turn into map latitude\n     * @param top - the pixel top coordinate to turn into map longitude\n     * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n     */\n    function pixCoordToLatLon(left, top) {\n        const canvas = canvasRef.current;\n        const normalizedLeft = left - canvas.offsetLeft;\n        const normalizedTop = top - canvas.offsetTop;\n        // console.log(normalizedLeft + \", \" + normalizedTop);\n        // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n        const returnLat = topLat - latLonIfy(normalizedTop);\n        const returnLon = leftLon + latLonIfy(normalizedLeft);\n        // console.log(returnLat, \", \", returnLon)\n        // console.log(latLonCoordToPix(returnLat, returnLon));\n\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [returnLat, returnLon];\n    }\n\n    /**\n     * Turns a single value in pixels into a value in latitude/longitude coordinates.\n     * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n     * @returns {number} the lat/lon conversion of the pixel value\n     */\n    function latLonIfy(pixVal) {\n        const latLonOverPixFactor =  latLonRange / CANVAS_SIDE_LENGTH;\n        return pixVal * latLonOverPixFactor;\n    }\n\n    /**\n     * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n     * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of the current map frame.\n     */\n    function getMapBoundaries() {\n        return getBoundingBox(topLat, leftLon, latLonRange);\n    }\n\n    /**\n     * Get the lat/lon boundaries of a passed square area with unknown side length.\n     * @param boxtopLat latitude coordinate of the northwest corner\n     * @param boxleftLon longitude coordinate of the northwest corner\n     * @param boxRange side length, in terms of lat/lon coordinates\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of a passed square.\n     */\n    function getBoundingBox(boxtopLat, boxleftLon, boxRange) {\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [boxtopLat, boxleftLon, boxtopLat - boxRange, boxleftLon + boxRange];\n    }\n\n    function handleClickOrDrag(mouseUpX, mouseUpY) {\n        const xChange = mouseUpX - mouseDownX; // positive if the map is dragged to the right\n        const yChange = mouseUpY - mouseDownY; // positive if the map is dragged downwards\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n\n        if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n            console.log(\"clicked\")\n            // This was a click!\n            const ctx = ctxRef.current;\n            ctx.fillStyle = \"green\";\n            // console.log(pixCoordToLatLon(mouseUpX, mouseUpY));\n            const latLonCoord = pixCoordToLatLon(mouseUpX, mouseUpY);\n            //if (startLat === 0 || startLat.toString() === \"\")\n            if (startLat === \"\") {\n                requestNearest(latLonCoord[0], latLonCoord[1], setStartLat, setStartLon);\n            } else if (destLat === \"\") {\n                requestNearest(latLonCoord[0], latLonCoord[1], setDestLat, setDestLon);\n            }\n            else {\n                let route = requestRoute();\n                route.forEach(traceRoute);\n            }\n        } else {\n            // This was a drag!\n            // REMEMBER: lat is y-value, lon is x-value!\n            //console.log(xChange, yChange);\n            //console.log(latLonIfy(xChange), latLonIfy(yChange));\n            //console.log(topLat + \", \" + leftLon);\n            // TODO: this may want to get changed to a setParamName() function call when setState is used\n            leftLon -= latLonIfy(xChange);\n            /*\n             * positive values, dragging the map to the right\n             * moves the previous leftLon rightwards\n             * meaning that the new leftLon should be less than the previous leftLon\n             */\n            topLat += latLonIfy(yChange);\n            /*\n             * positive values, dragging the map downwards\n             * moves the previous topLat downwards\n             * meaning that the new topLat should be greater than the previous topLat\n             */\n            //console.log(topLat + \", \" + leftLon);\n            reloadMap();\n        }\n    }\n\n    function handleZoomInOut(zoomedOut, mouseX, mouseY) {\n        const mouseLatLonCoord = pixCoordToLatLon(mouseX, mouseY);\n        const zoomLatNormalized = topLat - mouseLatLonCoord[0];\n        const zoomLonNormalized = mouseLatLonCoord[1] - leftLon;\n        const latFraction = (zoomLatNormalized / latLonRange);\n        const lonFraction = (zoomLonNormalized / latLonRange);\n\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n        if (zoomedOut) {\n            const stepSize = (latLonRange * 1.05) - latLonRange;\n            latLonRange += stepSize;\n            // We're zooming out, so the topLat should move upwards\n            topLat += latFraction * stepSize;\n            // and leftLon should move leftwards\n            leftLon -= lonFraction * stepSize;\n        } else {\n            const stepSize = latLonRange - (latLonRange * 0.95);\n            latLonRange -= stepSize;\n            // We're zooming in, so the topLat should move downwards\n            topLat -= latFraction * stepSize;\n            // and leftLon should move inwards\n            leftLon += lonFraction * stepSize;\n        }\n        reloadMap();\n    }\n\n    function clearCanvas() {\n        const ctx = ctxRef.current;\n        const canvas = canvasRef.current;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    function drawTile(tileToDraw) {\n        tileToDraw[\"ways\"].forEach(traceWay);\n    }\n\n    function drawCircle(lat, lon, radius) {\n        const ctx = ctxRef.current;\n        const pixCoord = latLonCoordToPix(lat, lon);\n        ctx.strokeStyle = \"red\";\n        ctx.beginPath();\n        ctx.arc(pixCoord[0], pixCoord[1], radius, 0, 2 * Math.PI);\n        ctx.stroke();\n    }\n\n    function drawLoadedRect(){\n        const ctx = ctxRef.current;\n        const loadedPixBoxTopLeft = latLonCoordToPix(topmostTileLat, leftmostTileLon);\n        const loadedPixBoxBottomRight = latLonCoordToPix(bottommostTileLat, rightmostTileLon);\n        const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n        const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n        ctx.strokeStyle = \"red\";\n        ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n    }\n\n    function drawSquare(tileToDraw) {\n        const ctx = ctxRef.current;\n        ctx.fillStyle = \"lightgreen\";\n        const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n        const baseX = tileCoord[0];\n        const baseY = tileCoord[1];\n\n        const pixTileWidth = pixIfy(TILE_WIDTH);\n        // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n        //      Math.min(baseX + pixTileWidth, pixTileWidth),\n        //      Math.min(baseY + pixTileWidth, pixTileWidth));\n        ctx.strokeStyle = \"black\";\n        ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n            Math.min(baseX + pixTileWidth, pixTileWidth),\n            Math.min(baseY + pixTileWidth, pixTileWidth));\n        ctx.fillStyle = \"black\";\n        ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n    }\n\n    // function drawWays(tileToDraw) {\n    //     const canvas = $('#canvas')[0]; // Getting a reference to the <canvas> element that has an ID of 'canvas'\n    //     canvas.width = TILE_WIDTH;\n    //     canvas.height = TILE_WIDTH;\n    //     tileToDraw.ways.forEach(traceWay)\n    // }\n\n    function traceRoute(way) {\n        const ctx = ctxRef.current;\n        let startLatCoord = way[\"startLat\"]\n        let startLonCoord = way[\"startLong\"]\n        let pixStart = latLonCoordToPix(startLatCoord, startLonCoord)\n        ctx.fillStyle = \"blue\";\n        ctx.strokeStyle = \"blue\";\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(pixStart[0], pixStart[1])\n        let endLatCoord = way[\"destLat\"]\n        //console.log(endLatCoord)\n        let endLongCoord = way[\"destLong\"]\n        //console.log(endLongCoord)\n        let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord)\n        //console.log(pixEnd)\n        ctx.lineTo(pixEnd[0], pixEnd[1])\n        ctx.stroke();\n    }\n    function traceWay(way) {\n        //console.log(way)\n        //probably should change wayslist into a hashmap\n        const ctx = ctxRef.current;\n        //let c = document.getElementById(\"myCanvas\");\n        //let ctx = c.getContext(\"2d\");\n        let startLatCoord = way[\"startLat\"]\n        let startLonCoord = way[\"startLong\"]\n        let pixStart = latLonCoordToPix(startLatCoord, startLonCoord)\n        //console.log(pixStart)\n        ctx.fillStyle = \"black\";\n        ctx.strokeStyle = \"black\";\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(pixStart[0], pixStart[1])\n        let endLatCoord = way[\"destLat\"]\n        //console.log(endLatCoord)\n        let endLongCoord = way[\"destLong\"]\n        //console.log(endLongCoord)\n        let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord)\n        //console.log(pixEnd)\n        ctx.lineTo(pixEnd[0], pixEnd[1])\n        ctx.stroke();\n    }\n\n    return (\n        <div>\n            <h1>Maps GUI</h1>\n            <TextBox label={\"Source Latitude\"} boxVal={startLat} change={setStartLat}/>\n            <TextBox label={\"Source Longitude\"} boxVal={startLon} change={setStartLon}/>\n            <TextBox label={\"Destination Latitude\"} boxVal={destLat} change={setDestLat}/>\n            <TextBox label={\"Destination Longitude\"} boxVal={destLon} change={setDestLon}/>\n            <AwesomeButton type=\"primary\" onPress={requestRoute}>Submit!</AwesomeButton>\n            <br/>\n            {/*{route.map((coord, index) =>*/}\n            {/*    <p key={index}>{coord[0]}, {coord[1]}</p>*/}\n            {/*)}*/}\n            <canvas ref={canvasRef} onMouseDown={(event) => {\n                mouseDownX = event.pageX;\n                mouseDownY = event.pageY;\n            }} onMouseUp={(event) => {\n                //pixCoordToLatLon(event.pageX, event.pageY);\n                handleClickOrDrag(event.pageX, event.pageY);\n            }} onWheel={(event) => {\n                event.stopPropagation();\n                // Scrolling!\n                if (event.deltaY < 0) {\n                    // Scrolling up\n                    handleZoomInOut(false, event.pageX, event.pageY);\n                } else {\n                    // Scrolling down\n                    handleZoomInOut(true, event.pageX, event.pageY);\n                }\n            }}/>\n        </div>\n    );\n}\n\nexport default Route;"]},"metadata":{},"sourceType":"module"}