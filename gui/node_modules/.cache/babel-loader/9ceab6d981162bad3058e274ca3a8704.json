{"ast":null,"code":"var _jsxFileName = \"/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js\",\n    _s = $RefreshSig$();\n\nimport './App.css';\nimport TextBox from \"./TextBox\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport axios from 'axios';\nimport \"react-awesome-button/dist/styles.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Route() {\n  _s();\n\n  // const [startLat, setStartLat] = useState(\"\");\n  // const [startLon, setStartLon] = useState(\"\");\n  // const [destLat, setDestLat] = useState(\"\");\n  // const [destLon, setDestLon] = useState(\"\");\n  const [startInt1, setStartInt1] = useState(\"\");\n  const [startInt2, setStartInt2] = useState(\"\");\n  const [destInt1, setDestInt1] = useState(\"\");\n  const [destInt2, setDestInt2] = useState(\"\");\n  const [route, setRoute] = useState([]);\n  const CANVAS_SIDE_LENGTH = 450;\n  const SCROLL_WAIT = 100;\n  const CLICK_RANGE = 5;\n  const [mapWindow, setMapWindow] = useState([41.8320, -71.4070, 0.0113]);\n  const topLat = mapWindow[0];\n  const leftLon = mapWindow[1];\n  const latLonRange = mapWindow[2];\n  let mouseDownX;\n  let mouseDownY; // We expect latitudes within the map range to be LESS than the topLat\n  // We expect longitudes within the map range to be GREATER than the leftLon\n  // In order to get bottomLat or rightLon, just subtract latLonRange from topLat, or add it to leftLon\n\n  const TILE_WIDTH = 0.0016; // this is an arbitrarily chosen-value, but it works well\n\n  let topmostTileLat = useRef(topLat);\n  let leftmostTileLon = useRef(leftLon);\n  let bottommostTileLat = useRef(topmostTileLat.current);\n  let rightmostTileLon = useRef(leftmostTileLon.current);\n  let tilesLoadedRef = useRef([]); // Tiles should be JavaScript objects with properties topLat, leftLon, and an [] of ways\n  // Ways should be length-4 list of Doubles: [lat1, lon1, lat2, lon2]\n\n  const canvasRef = useRef();\n  let ctxRef = useRef();\n  let reloadCounter = useRef(0);\n  /**\n   * Code to run when the page loads\n   */\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    canvas.width = CANVAS_SIDE_LENGTH;\n    canvas.height = CANVAS_SIDE_LENGTH;\n    ctxRef.current = canvas.getContext(\"2d\"); // let ctx = ctxRef.current;\n    // ctx.fillStyle = \"green\";\n    // ctx.fillRect(0, 0, 100, 100);\n    // Loading starting tiles is taken care of by the automatic redrawMap() call\n    //const boundaries = getMapBoundaries();\n    //loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n  }, []);\n  useEffect(() => {\n    //TODO if we uncomment the below console.log, we'll see that the map gets reloaded four times every\n    // time the canvas is clicked (once for each useState() parameter that gets changed)\n    // which is kinda wasteful of resources, though it doesn't impact user experience\n    // If we want to fix it, we could combine all four startLat/startLon/destLat/destLon\n    // into one const [routeEndCoords, setRouteEndCoords] = useState([\"\",\"\",\"\",\"\"])\n    //console.log(\"reload number \" + reloadCounter.current);\n    redrawMap();\n  });\n\n  async function loadTilesWithin(topLatLimit, leftLonLimit, bottomLatLimit, rightLonLimit, reloadNum) {\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n    // const tilesLoadedTemp = tilesLoadedRef.current;\n    let newTile;\n    let curLat = topLatLimit;\n    let curLon = leftLonLimit;\n\n    while (curLon < rightLonLimit) {\n      while (curLat > bottomLatLimit) {\n        if (reloadNum !== reloadCounter.current) {\n          return;\n        } // Check if the tile has already been loaded\n\n\n        if (!tileLoaded(curLat, curLon, tilesLoadedRef.current)) {\n          const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n          newTile = {\n            \"tileLat\": curLat,\n            \"tileLon\": curLon,\n            \"ways\": ways\n          };\n          drawTile(newTile);\n          tilesLoadedRef.current.push(newTile);\n        }\n\n        curLat -= TILE_WIDTH;\n      }\n\n      if (curLat < bottommostTileLat.current) {\n        bottommostTileLat.current = curLat;\n      }\n\n      curLat = topLatLimit;\n      curLon += TILE_WIDTH;\n    }\n\n    if (curLon > rightmostTileLon.current) {\n      rightmostTileLon.current = curLon;\n    }\n  }\n  /**\n   * Determines whether a tile with a given lat/lon coordinate has been cached on the client-side\n   * or note. Returns a boolean.\n   * @param lat - latitude coordinate of tile to check\n   * @param lon - longitude coordinate of tile to check\n   * @param loadedTiles - list of tiles that have been loaded already\n   * @returns {boolean} - whether or not the tile is cached already\n   */\n\n\n  function tileLoaded(lat, lon, loadedTiles) {\n    let loaded = false;\n    let checkTile;\n\n    for (let i = 0; i < loadedTiles.length; i++) {\n      checkTile = loadedTiles[i];\n      loaded = loaded || checkTile[\"tileLat\"] === lat && checkTile[\"tileLon\"] === lon;\n    }\n\n    return loaded;\n  }\n  /**\n   * Makes an axios request.\n   */\n\n\n  async function requestRoute() {\n    const toSend = {\n      srcInt1: startInt1,\n      srcInt2: startInt2,\n      destInt1: destInt1,\n      destInt2: destInt2\n    };\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    const res = await axios.post(\"http://localhost:4567/route\", toSend, config);\n    return res[\"data\"][\"route\"];\n  } //uses post request to get ways within bounding box\n\n\n  async function requestWays(coordinates) {\n    const toSend = {\n      lat1: coordinates[0],\n      long1: coordinates[1],\n      lat2: coordinates[2],\n      long2: coordinates[3]\n    };\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    const res = await axios.post(\"http://localhost:4567/ways\", toSend, config);\n    return res[\"data\"][\"ways\"];\n  }\n  /**\n   * Makes an axios request to get the coordinates of the node nearest to a clicked lat and lon.\n   */\n\n\n  function requestNearest(lat, lon, latSetter, lonSetter) {\n    const toSend = {\n      lat: lat,\n      lon: lon\n    };\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    axios.post(\"http://localhost:4567/nearest\", toSend, config).then(response => {\n      // console.log(response.data);\n      return response.data;\n    }).then(data => {\n      return data[\"intersection\"];\n    }).then(newCoord => {\n      latSetter(newCoord[0]);\n      lonSetter(newCoord[1]);\n      setRoute([]); // redrawMap();\n    }).catch(function (error) {\n      console.log(error);\n    });\n  }\n\n  function clearLoadTiles() {\n    const tilesLoadedTemp = tilesLoadedRef.current; // First, purge old tiles\n\n    const mapBoundaries = getMapBoundaries(); //these are backwards\n\n    const bottomLat = mapBoundaries[2];\n    const rightLon = mapBoundaries[3];\n    let saveTiles = []; // Iterate over all the loaded tiles and see if they're still useful\n\n    for (let i = 0; i < tilesLoadedTemp.length; i++) {\n      const checkTile = tilesLoadedTemp[i];\n      const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH); // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n\n      const tileTopLat = tileBoundaries[0];\n      const tileLeftLon = tileBoundaries[1];\n      const tileBottomLat = tileBoundaries[2];\n      const tileRightLon = tileBoundaries[3]; // We expect latitudes within the map range to be LESS than the topLat\n      // We expect longitudes within the map range to be GREATER than the leftLon\n\n      const deleteTile = tileBottomLat > topLat || tileTopLat < bottomLat || tileRightLon < leftLon || tileLeftLon > rightLon; // if (tileBottomLat > topLat) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n      // }\n      // if (tileLeftLon > rightLon) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the right side\");\n      // }\n      // if (deleteTile) {\n      //     console.log(\"deleting tile\");\n      // }\n\n      if (!deleteTile) {\n        // console.log(\"rendering tile for reload number \" + reloadNum);\n        drawTile(tilesLoadedTemp[i]);\n        saveTiles.push(checkTile);\n      }\n    }\n\n    tilesLoadedRef.current = saveTiles; // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n    // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n\n    while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[2] > topLat) {\n      // console.log(\"adjusting loaded top boundary\");\n      topmostTileLat.current -= TILE_WIDTH;\n    }\n\n    while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[3] < leftLon) {\n      // console.log(\"adjusting loaded left boundary\");\n      leftmostTileLon.current += TILE_WIDTH;\n    }\n\n    while (bottommostTileLat.current < bottomLat) {\n      // console.log(\"adjusting loaded bottom boundary\");\n      bottommostTileLat.current += TILE_WIDTH;\n    }\n\n    while (rightmostTileLon.current > rightLon) {\n      // console.log(\"adjusting loaded right boundary\");\n      rightmostTileLon.current -= TILE_WIDTH;\n    } // Now, load new tiles\n\n\n    while (leftmostTileLon.current > leftLon) {\n      //console.log(\"gap at left\");\n      // loadTilesWithin(topmostTileLat.current, leftmostTileLon.current - TILE_WIDTH, bottommostTileLat.current, leftmostTileLon.current);\n      leftmostTileLon.current -= TILE_WIDTH;\n    }\n\n    while (topmostTileLat.current < topLat) {\n      //console.log(\"gap at top\");\n      // loadTilesWithin(topmostTileLat.current + TILE_WIDTH, leftmostTileLon.current, topmostTileLat.current, rightmostTileLon.current);\n      topmostTileLat.current += TILE_WIDTH;\n    }\n\n    while (bottommostTileLat.current >= bottomLat) {\n      //console.log(\"gap at bottom\");\n\n      /*loadTilesWithin(bottommostTileLat.current, leftmostTileLon.current - TILE_WIDTH,\n          bottommostTileLat.current - (2.0 * TILE_WIDTH), rightmostTileLon.current);*/\n      bottommostTileLat.current -= TILE_WIDTH;\n    }\n\n    while (rightmostTileLon.current <= rightLon) {\n      //console.log(\"gap at right\");\n\n      /*loadTilesWithin(topmostTileLat.current, rightmostTileLon.current + TILE_WIDTH,\n          bottommostTileLat.current, rightmostTileLon.current + (2.0 * TILE_WIDTH));*/\n      rightmostTileLon.current += TILE_WIDTH;\n    }\n\n    loadTilesWithin(topmostTileLat.current, leftmostTileLon.current, bottommostTileLat.current, rightmostTileLon.current, reloadCounter.current); // console.log(\"num tiles after loading: \" + tilesLoadedTemp.length);\n    //drawLoadedRect();\n  }\n\n  function redrawMap() {\n    clearCanvas();\n    clearLoadTiles(); //drawStartEndCircles();\n\n    drawRoute();\n  }\n  /**\n   * Code to turn lat/lon coordinates into pixel coordinates for the canvas:\n   * takes in a latitude and longitude coordinate, returns a length-2 list with the\n   * corresponding pixel position on the canvas [left, top]\n   * @param lat - the latitude coordinate to turn into a pixel left coordinate\n   * @param lon - the longitude coordinate to turn into a pixel top coordinate\n   * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n   */\n\n\n  function latLonCoordToPix(lat, lon) {\n    const normalizedLat = topLat - lat;\n    const normalizedLon = lon - leftLon; // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n    // REMEMBER: lat is y-value, lon is x-value!\n\n    return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n  }\n  /**\n   * Converts a single latitude/longitude coordinate value into a pixel value.\n   * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n   * @returns {number} the pixel conversion of the lat/lon value\n   */\n\n\n  function pixIfy(latLonVal) {\n    const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n    return latLonVal * pixOverLatLonFactor;\n  }\n  /**\n   * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n   * and longitude coordinate.\n   * Returns a length-2 list with [lat, lon].\n   * @param left - the pixel left coordinate to turn into map latitude\n   * @param top - the pixel top coordinate to turn into map longitude\n   * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n   */\n\n\n  function pixCoordToLatLon(left, top) {\n    const canvas = canvasRef.current;\n    const normalizedLeft = left - canvas.offsetLeft;\n    const normalizedTop = top - canvas.offsetTop; // console.log(normalizedLeft + \", \" + normalizedTop);\n    // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n    const returnLat = topLat - latLonIfy(normalizedTop);\n    const returnLon = leftLon + latLonIfy(normalizedLeft); // console.log(returnLat, \", \", returnLon)\n    // console.log(latLonCoordToPix(returnLat, returnLon));\n    // REMEMBER: lat is y-value, lon is x-value!\n\n    return [returnLat, returnLon];\n  }\n  /**\n   * Turns a single value in pixels into a value in latitude/longitude coordinates.\n   * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n   * @returns {number} the lat/lon conversion of the pixel value\n   */\n\n\n  function latLonIfy(pixVal) {\n    const latLonOverPixFactor = latLonRange / CANVAS_SIDE_LENGTH;\n    return pixVal * latLonOverPixFactor;\n  }\n  /**\n   * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n   * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of the current map frame.\n   */\n\n\n  function getMapBoundaries() {\n    return getBoundingBox(topLat, leftLon, latLonRange);\n  }\n  /**\n   * Get the lat/lon boundaries of a passed square area with unknown side length.\n   * @param boxtopLat latitude coordinate of the northwest corner\n   * @param boxleftLon longitude coordinate of the northwest corner\n   * @param boxRange side length, in terms of lat/lon coordinates\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of a passed square.\n   */\n\n\n  function getBoundingBox(boxtopLat, boxleftLon, boxRange) {\n    // REMEMBER: lat is y-value, lon is x-value!\n    return [boxtopLat, boxleftLon, boxtopLat - boxRange, boxleftLon + boxRange];\n  }\n\n  function handleClickOrDrag(mouseUpX, mouseUpY) {\n    const xChange = mouseUpX - mouseDownX; // positive if the map is dragged to the right\n\n    const yChange = mouseUpY - mouseDownY; // positive if the map is dragged downwards\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n\n    if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n      // This was a click!\n      const ctx = ctxRef.current;\n      ctx.fillStyle = \"green\"; // console.log(pixCoordToLatLon(mouseUpX, mouseUpY));\n\n      const latLonCoord = pixCoordToLatLon(mouseUpX, mouseUpY); //if (startLat === 0 || startLat.toString() === \"\")\n\n      if (startInt1 === \"\") {\n        requestNearest(latLonCoord[0], latLonCoord[1], setStartInt1, setStartInt2);\n      } else {\n        requestNearest(latLonCoord[0], latLonCoord[1], setDestInt1, setDestInt2);\n      }\n    } else {\n      reloadCounter.current += 1; // console.log(\"reload number \" + reloadCounter.current);\n      // This was a drag!\n      // REMEMBER: lat is y-value, lon is x-value!\n      //console.log(xChange, yChange);\n      //console.log(latLonIfy(xChange), latLonIfy(yChange));\n      //console.log(topLat + \", \" + leftLon);\n      //setLeftLon(leftLon - latLonIfy(xChange));\n\n      const newLeftLon = leftLon - latLonIfy(xChange);\n      /*\n       * positive values, dragging the map to the right\n       * moves the previous leftLon rightwards\n       * meaning that the new leftLon should be less than the previous leftLon\n       */\n      //setTopLat(topLat + latLonIfy(yChange));\n\n      const newTopLat = topLat + latLonIfy(yChange);\n      /*\n       * positive values, dragging the map downwards\n       * moves the previous topLat downwards\n       * meaning that the new topLat should be greater than the previous topLat\n       */\n      //console.log(topLat + \", \" + leftLon);\n      // redrawMap();\n\n      const newMapWindow = [newTopLat, newLeftLon, mapWindow[2]];\n      setMapWindow(newMapWindow);\n    }\n  }\n\n  function handleZoomInOut(zoomedOut, mouseX, mouseY, numScrolls) {\n    reloadCounter.current += 1; // console.log(\"reload number \" + reloadCounter.current);\n\n    const mouseLatLonCoord = pixCoordToLatLon(mouseX, mouseY);\n    const zoomLatNormalized = topLat - mouseLatLonCoord[0];\n    const zoomLonNormalized = mouseLatLonCoord[1] - leftLon;\n    const latFraction = zoomLatNormalized / latLonRange;\n    const lonFraction = zoomLonNormalized / latLonRange; // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n\n    if (zoomedOut) {\n      const stepSize = latLonRange * Math.pow(1.05, numScrolls) - latLonRange; //setLatLonRange(latLonRange + stepSize);\n\n      const newLatLonRange = latLonRange + stepSize; // We're zooming out, so the topLat should move upwards\n      //setTopLat(topLat + (latFraction * stepSize));\n\n      const newTopLat = topLat + latFraction * stepSize; // and leftLon should move leftwards\n      //setLeftLon(leftLon - (lonFraction * stepSize));\n\n      const newLeftLon = leftLon - lonFraction * stepSize;\n      const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n      setMapWindow(newMapWindow);\n    } else {\n      const stepSize = latLonRange - latLonRange * Math.pow(0.95, numScrolls); //setLatLonRange(latLonRange - stepSize);\n\n      const newLatLonRange = latLonRange - stepSize; // We're zooming in, so the topLat should move downwards\n      //setTopLat(topLat - (latFraction * stepSize));\n\n      const newTopLat = topLat - latFraction * stepSize; // and leftLon should move inwards\n      //setLeftLon(leftLon + (lonFraction * stepSize));\n\n      const newLeftLon = leftLon + lonFraction * stepSize;\n      const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n      setMapWindow(newMapWindow);\n    } // redrawMap();\n\n  }\n\n  function clearCanvas() {\n    const ctx = ctxRef.current;\n    const canvas = canvasRef.current;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  function drawTile(tileToDraw) {\n    // const mapBoundaries = getMapBoundaries();\n    // // We expect latitudes within the map range to be LESS than the topLat\n    // // We expect longitudes within the map range to be GREATER than the leftLon\n    // const withinMapBoundaries = (tileToDraw[\"tileLat\"] < mapBoundaries[0])\n    //     && (tileToDraw[\"tileLat\"] > mapBoundaries[2])\n    //     && (tileToDraw[\"tileLon\"] > mapBoundaries[1])\n    //     && (tileToDraw[\"tileLon\"] < mapBoundaries[3]);\n    // if (!withinMapBoundaries) {\n    //     console.log(tileToDraw);\n    // }\n    tileToDraw[\"ways\"].forEach(traceWay);\n  }\n\n  function drawCircle(lat, lon, radius) {\n    const ctx = ctxRef.current;\n    const pixCoord = latLonCoordToPix(lat, lon);\n    ctx.strokeStyle = \"red\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(pixCoord[0], pixCoord[1], radius, 0, 2 * Math.PI);\n    ctx.stroke();\n  } // function drawStartEndCircles() {\n  //     // And add the circles for the selected start/destination!\n  //     const radius = pixIfy(latLonRange / 100);\n  //     //console.log(\"startLat and startLon:\");\n  //     //console.log(startLat + \" \" + startLon);\n  //     if (startInt1.toString() === \"\"\n  //         ||  startInt2.toString() === \"\"){\n  //         // drawing start circle\n  //         //drawCircle(startLat, startLon, radius);\n  //     }\n  //     if (!(parseFloat(destLon) === 0 || destLon.toString() === \"\"\n  //         || parseFloat(destLat) === 0 || destLat.toString() === \"\")){\n  //         // drawing destination circle\n  //         //drawCircle(destLat, destLon, radius);\n  //     }\n  // }\n  // function drawLoadedRect(){\n  //     const ctx = ctxRef.current;\n  //     const loadedPixBoxTopLeft = latLonCoordToPix(topmostTileLat.current, leftmostTileLon.current);\n  //     const loadedPixBoxBottomRight = latLonCoordToPix(bottommostTileLat.current, rightmostTileLon.current);\n  //     const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n  //     const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n  //     ctx.strokeStyle = \"red\";\n  //     ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n  // }\n  //\n  // function drawSquare(tileToDraw) {\n  //     const ctx = ctxRef.current;\n  //     ctx.fillStyle = \"lightgreen\";\n  //     const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n  //     const baseX = tileCoord[0];\n  //     const baseY = tileCoord[1];\n  //\n  //     const pixTileWidth = pixIfy(TILE_WIDTH);\n  //     // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n  //     //      Math.min(baseX + pixTileWidth, pixTileWidth),\n  //     //      Math.min(baseY + pixTileWidth, pixTileWidth));\n  //     ctx.strokeStyle = \"black\";\n  //     ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n  //         Math.min(baseX + pixTileWidth, pixTileWidth),\n  //         Math.min(baseY + pixTileWidth, pixTileWidth));\n  //     ctx.fillStyle = \"black\";\n  //     ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n  // }\n\n\n  function traceRoute(way) {\n    const ctx = ctxRef.current;\n    let startLatCoord = way[\"startLat\"];\n    let startLonCoord = way[\"startLong\"];\n    let pixStart = latLonCoordToPix(startLatCoord, startLonCoord);\n    ctx.fillStyle = \"blue\";\n    ctx.strokeStyle = \"blue\";\n    ctx.lineWidth = 4;\n    ctx.beginPath();\n    ctx.moveTo(pixStart[0], pixStart[1]);\n    let endLatCoord = way[\"destLat\"]; //console.log(endLatCoord)\n\n    let endLongCoord = way[\"destLong\"]; //console.log(endLongCoord)\n\n    let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord); //console.log(pixEnd)\n\n    ctx.lineTo(pixEnd[0], pixEnd[1]);\n    ctx.stroke();\n  } //M picked colors randomly feel free to change colors if you would like\n\n\n  function traceWay(way) {\n    const ctx = ctxRef.current;\n    let startLatCoord = Number(way[\"startLat\"]);\n    let startLonCoord = Number(way[\"startLong\"]);\n    let pixStart = latLonCoordToPix(startLatCoord, startLonCoord);\n\n    switch (way[\"type\"]) {\n      case 'ROUTE':\n        ctx.fillStyle = \"MidnightBlue\";\n        ctx.strokeStyle = \"MidnightBlue\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'residential':\n        ctx.fillStyle = \"green\";\n        ctx.strokeStyle = \"green\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'service':\n        ctx.fillStyle = \"Coral\";\n        ctx.strokeStyle = \"Coral\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'secondary':\n        ctx.fillStyle = \"CornflowerBlue\";\n        ctx.strokeStyle = \"CornflowerBlue\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'track':\n        ctx.fillStyle = \"Chocolate\";\n        ctx.strokeStyle = \"Chocolate\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'tertiary':\n        ctx.fillStyle = \"LightPink\";\n        ctx.strokeStyle = \"LightPink\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'trunk':\n        ctx.fillStyle = \"DarkOrchid\";\n        ctx.strokeStyle = \"DarkOrchid\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'primary':\n        ctx.fillStyle = \"DarkViolet\";\n        ctx.strokeStyle = \"DarkViolet\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'secondary_link':\n        ctx.fillStyle = \"Gold\";\n        ctx.strokeStyle = \"Gold\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'trunk_link':\n        ctx.fillStyle = \"Lavender\";\n        ctx.strokeStyle = \"Lavender\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'path':\n        ctx.fillStyle = \"LightBlue\";\n        ctx.strokeStyle = \"LightBlue\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'motorway_link':\n        ctx.fillStyle = \"LightGreen\";\n        ctx.strokeStyle = \"LightGreen\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'motorway':\n        ctx.fillStyle = \"LightSeaGreen\";\n        ctx.strokeStyle = \"LightSeaGreen\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'cycleway':\n        ctx.fillStyle = \"MediumBlue\";\n        ctx.strokeStyle = \"MediumBlue\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'tertiary_link':\n        ctx.fillStyle = \"MediumPurple\";\n        ctx.strokeStyle = \"MediumPurple\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'footway':\n        ctx.fillStyle = \"Plum\";\n        ctx.strokeStyle = \"Plum\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'primary_link':\n        ctx.fillStyle = \"Pink\";\n        ctx.strokeStyle = \"Pink\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'pedestrian':\n        ctx.fillStyle = \"Orange\";\n        ctx.strokeStyle = \"Orange\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'steps':\n        ctx.fillStyle = \"PaleVioletRed\";\n        ctx.strokeStyle = \"PaleVioletRed\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'construction':\n        ctx.fillStyle = \"Red\";\n        ctx.strokeStyle = \"Red\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'living_street':\n        ctx.fillStyle = \"SkyBlue\";\n        ctx.strokeStyle = \"SkyBlue\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'road':\n        ctx.fillStyle = \"Yellow\";\n        ctx.strokeStyle = \"Yellow\";\n        ctx.lineWidth = 1;\n        break;\n\n      default:\n        ctx.fillStyle = \"DarkGray\";\n        ctx.strokeStyle = \"DarkGray\";\n        ctx.lineWidth = 1;\n    }\n\n    ctx.beginPath();\n    ctx.moveTo(pixStart[0], pixStart[1]);\n    let endLatCoord = Number(way[\"destLat\"]);\n    let endLongCoord = Number(way[\"destLong\"]);\n    let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord);\n    ctx.lineTo(pixEnd[0], pixEnd[1]);\n    ctx.stroke();\n  } //traces route from 2 selected points in blue\n  //M this disappears if you scroll or pan i think, im not sure how to fix it i will leave it for now\n  // and we can come back to this\n  // Maxime reply: I think I went ahead and fixed this!\n  // It was because of the redrawMap() method, which gets called anytime we scroll or pan,\n  // and ever time it gets called, it calls the clearCanvas() method to wipe the canvas\n  // (including the route we just drew), then it redraws all of the ways.\n  //TODO we could probably lump all this functionality directly into the requestRoute() method\n  // Since all we really need is to use the setRoute() method to store the route data\n\n\n  async function getRoute() {\n    // console.log(\"should draw the route\");\n    const routeTemp = await requestRoute(); // console.log(routeTemp);\n\n    setRoute(routeTemp); // drawRoute()\n    // Now we'll auto-zoom to a proper display size!\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n    // const latRange = Math.abs(startLat - destLat);\n    // const lonRange = Math.abs(startLon - destLon);\n    // const routeTopLat = Math.max(startLat, destLat);\n    // const routeLeftLon = Math.min(startLon, destLon);\n    // const maxRange = Math.max(latRange, lonRange);\n    // const centerLatPadding = (maxRange - latRange) / 2.0;\n    // const centerLonPadding = (maxRange - lonRange) / 2.0;\n    // const overallPadding = 0.1 * maxRange; // We'll add a border of 10% of the longest dimension of the path\n    // const newTopLat = routeTopLat + centerLatPadding + overallPadding;\n    // const newLeftLon = routeLeftLon - centerLonPadding - overallPadding;\n    // const newLatLonRange = maxRange + (2 * overallPadding);\n    // const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n    // setMapWindow(newMapWindow);\n  }\n\n  function drawRoute() {\n    for (const way of route) {\n      traceRoute(way);\n    }\n  }\n\n  function clearMap() {\n    // clear out the clicked/entered-in points\n    setStartLat(\"\");\n    setStartLon(\"\");\n    setDestLat(\"\");\n    setDestLon(\"\"); // also clear out any loaded route\n\n    setRoute([]); // rerender the map\n    // redrawMap();\n  }\n\n  let scrollCounter = 0;\n  let scrollFinish;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Maps GUI\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 758,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Start Street 1\",\n      boxVal: startInt1,\n      change: setStartInt1\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 759,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Start Street 2\",\n      boxVal: startInt2,\n      change: setStartInt2\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 760,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Street 1\",\n      boxVal: destInt1,\n      change: setDestInt1\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 761,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Street 2\",\n      boxVal: destInt2,\n      change: setDestInt2\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 762,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: getRoute,\n      children: \"Map Route\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 763,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: clearMap,\n      children: \"Clear Map\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 764,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 765,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      onMouseDown: event => {\n        mouseDownX = event.pageX;\n        mouseDownY = event.pageY;\n      },\n      onMouseUp: event => {\n        //pixCoordToLatLon(event.pageX, event.pageY);\n        handleClickOrDrag(event.pageX, event.pageY);\n      },\n      onWheel: event => {\n        event.stopPropagation(); // scrollCounter++;\n        // // Scrolling!\n        // clearTimeout(scrollFinish)\n        // scrollFinish = setTimeout(() => {\n        //     // Not scrolling anymore\n        //     if (event.deltaY < 0) {\n        //         // Scrolling up\n        //         handleZoomInOut(false, event.pageX, event.pageY, scrollCounter);\n        //     } else {\n        //         // Scrolling down\n        //         handleZoomInOut(true, event.pageX, event.pageY, scrollCounter);\n        //     }\n        // }, SCROLL_WAIT);\n        // Scrolling!\n\n        if (event.deltaY < 0) {\n          // Scrolling up\n          handleZoomInOut(false, event.pageX, event.pageY, 1);\n        } else {\n          // Scrolling down\n          handleZoomInOut(true, event.pageX, event.pageY, 1);\n        }\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 769,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 757,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Route, \"qX3KeNjkxmiL9cJPupBEHrqZrfM=\");\n\n_c = Route;\nexport default Route;\n\nvar _c;\n\n$RefreshReg$(_c, \"Route\");","map":{"version":3,"sources":["/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js"],"names":["TextBox","React","useState","useEffect","useRef","axios","Route","startInt1","setStartInt1","startInt2","setStartInt2","destInt1","setDestInt1","destInt2","setDestInt2","route","setRoute","CANVAS_SIDE_LENGTH","SCROLL_WAIT","CLICK_RANGE","mapWindow","setMapWindow","topLat","leftLon","latLonRange","mouseDownX","mouseDownY","TILE_WIDTH","topmostTileLat","leftmostTileLon","bottommostTileLat","current","rightmostTileLon","tilesLoadedRef","canvasRef","ctxRef","reloadCounter","canvas","width","height","getContext","redrawMap","loadTilesWithin","topLatLimit","leftLonLimit","bottomLatLimit","rightLonLimit","reloadNum","newTile","curLat","curLon","tileLoaded","ways","requestWays","getBoundingBox","drawTile","push","lat","lon","loadedTiles","loaded","checkTile","i","length","requestRoute","toSend","srcInt1","srcInt2","config","headers","res","post","coordinates","lat1","long1","lat2","long2","requestNearest","latSetter","lonSetter","then","response","data","newCoord","catch","error","console","log","clearLoadTiles","tilesLoadedTemp","mapBoundaries","getMapBoundaries","bottomLat","rightLon","saveTiles","tileBoundaries","tileTopLat","tileLeftLon","tileBottomLat","tileRightLon","deleteTile","clearCanvas","drawRoute","latLonCoordToPix","normalizedLat","normalizedLon","pixIfy","latLonVal","pixOverLatLonFactor","pixCoordToLatLon","left","top","normalizedLeft","offsetLeft","normalizedTop","offsetTop","returnLat","latLonIfy","returnLon","pixVal","latLonOverPixFactor","boxtopLat","boxleftLon","boxRange","handleClickOrDrag","mouseUpX","mouseUpY","xChange","yChange","Math","abs","ctx","fillStyle","latLonCoord","newLeftLon","newTopLat","newMapWindow","handleZoomInOut","zoomedOut","mouseX","mouseY","numScrolls","mouseLatLonCoord","zoomLatNormalized","zoomLonNormalized","latFraction","lonFraction","stepSize","pow","newLatLonRange","clearRect","tileToDraw","forEach","traceWay","drawCircle","radius","pixCoord","strokeStyle","lineWidth","beginPath","arc","PI","stroke","traceRoute","way","startLatCoord","startLonCoord","pixStart","moveTo","endLatCoord","endLongCoord","pixEnd","lineTo","Number","getRoute","routeTemp","clearMap","setStartLat","setStartLon","setDestLat","setDestLon","scrollCounter","scrollFinish","event","pageX","pageY","stopPropagation","deltaY"],"mappings":";;;AAAA,OAAO,WAAP;AACA,OAAOA,OAAP,MAAoB,WAApB;AACA,OAAOC,KAAP,IAAeC,QAAf,EAAyBC,SAAzB,EAAoCC,MAApC,QAAiD,OAAjD;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAO,sCAAP;;;AAEA,SAASC,KAAT,GAAiB;AAAA;;AACb;AACA;AACA;AACA;AACA,QAAM,CAACC,SAAD,EAAYC,YAAZ,IAA4BN,QAAQ,CAAC,EAAD,CAA1C;AACA,QAAM,CAACO,SAAD,EAAYC,YAAZ,IAA4BR,QAAQ,CAAC,EAAD,CAA1C;AACA,QAAM,CAACS,QAAD,EAAWC,WAAX,IAA0BV,QAAQ,CAAC,EAAD,CAAxC;AACA,QAAM,CAACW,QAAD,EAAWC,WAAX,IAA0BZ,QAAQ,CAAC,EAAD,CAAxC;AACA,QAAM,CAACa,KAAD,EAAQC,QAAR,IAAoBd,QAAQ,CAAC,EAAD,CAAlC;AACA,QAAMe,kBAAkB,GAAG,GAA3B;AACA,QAAMC,WAAW,GAAG,GAApB;AACA,QAAMC,WAAW,GAAG,CAApB;AACA,QAAM,CAACC,SAAD,EAAYC,YAAZ,IAA4BnB,QAAQ,CAAC,CAAC,OAAD,EAAU,CAAC,OAAX,EAAoB,MAApB,CAAD,CAA1C;AACA,QAAMoB,MAAM,GAAGF,SAAS,CAAC,CAAD,CAAxB;AACA,QAAMG,OAAO,GAAGH,SAAS,CAAC,CAAD,CAAzB;AACA,QAAMI,WAAW,GAAGJ,SAAS,CAAC,CAAD,CAA7B;AACA,MAAIK,UAAJ;AACA,MAAIC,UAAJ,CAlBa,CAmBb;AACA;AACA;;AAEA,QAAMC,UAAU,GAAG,MAAnB,CAvBa,CAuBc;;AAC3B,MAAIC,cAAc,GAAGxB,MAAM,CAACkB,MAAD,CAA3B;AACA,MAAIO,eAAe,GAAGzB,MAAM,CAACmB,OAAD,CAA5B;AACA,MAAIO,iBAAiB,GAAG1B,MAAM,CAACwB,cAAc,CAACG,OAAhB,CAA9B;AACA,MAAIC,gBAAgB,GAAG5B,MAAM,CAACyB,eAAe,CAACE,OAAjB,CAA7B;AACA,MAAIE,cAAc,GAAG7B,MAAM,CAAC,EAAD,CAA3B,CA5Ba,CA6Bb;AACA;;AAEA,QAAM8B,SAAS,GAAG9B,MAAM,EAAxB;AACA,MAAI+B,MAAM,GAAG/B,MAAM,EAAnB;AACA,MAAIgC,aAAa,GAAGhC,MAAM,CAAC,CAAD,CAA1B;AAEA;AACJ;AACA;;AACID,EAAAA,SAAS,CAAC,MAAM;AACZ,UAAMkC,MAAM,GAAGH,SAAS,CAACH,OAAzB;AACAM,IAAAA,MAAM,CAACC,KAAP,GAAerB,kBAAf;AACAoB,IAAAA,MAAM,CAACE,MAAP,GAAgBtB,kBAAhB;AACAkB,IAAAA,MAAM,CAACJ,OAAP,GAAiBM,MAAM,CAACG,UAAP,CAAkB,IAAlB,CAAjB,CAJY,CAKZ;AACA;AACA;AAEA;AACA;AACA;AACH,GAZQ,EAYN,EAZM,CAAT;AAcArC,EAAAA,SAAS,CAAC,MAAM;AACZ;AACA;AACA;AACA;AACA;AACA;AACAsC,IAAAA,SAAS;AACZ,GARQ,CAAT;;AAUA,iBAAeC,eAAf,CAA+BC,WAA/B,EAA4CC,YAA5C,EAA0DC,cAA1D,EAA0EC,aAA1E,EAAyFC,SAAzF,EAAoG;AAChG;AACA;AACA;AACA,QAAIC,OAAJ;AACA,QAAIC,MAAM,GAAGN,WAAb;AACA,QAAIO,MAAM,GAAGN,YAAb;;AACA,WAAOM,MAAM,GAAGJ,aAAhB,EAA+B;AAC3B,aAAOG,MAAM,GAAGJ,cAAhB,EAAgC;AAC5B,YAAIE,SAAS,KAAKX,aAAa,CAACL,OAAhC,EAAyC;AACrC;AACH,SAH2B,CAI5B;;;AACA,YAAI,CAACoB,UAAU,CAACF,MAAD,EAASC,MAAT,EAAiBjB,cAAc,CAACF,OAAhC,CAAf,EAAyD;AACrD,gBAAMqB,IAAI,GAAG,MAAMC,WAAW,CAACC,cAAc,CAACL,MAAD,EAASC,MAAT,EAAiBvB,UAAjB,CAAf,CAA9B;AACAqB,UAAAA,OAAO,GAAG;AAAC,uBAAWC,MAAZ;AAAoB,uBAAWC,MAA/B;AAAuC,oBAAQE;AAA/C,WAAV;AACAG,UAAAA,QAAQ,CAACP,OAAD,CAAR;AACAf,UAAAA,cAAc,CAACF,OAAf,CAAuByB,IAAvB,CAA4BR,OAA5B;AACH;;AAEDC,QAAAA,MAAM,IAAItB,UAAV;AACH;;AACD,UAAIsB,MAAM,GAAGnB,iBAAiB,CAACC,OAA/B,EAAwC;AACpCD,QAAAA,iBAAiB,CAACC,OAAlB,GAA4BkB,MAA5B;AACH;;AACDA,MAAAA,MAAM,GAAGN,WAAT;AACAO,MAAAA,MAAM,IAAIvB,UAAV;AACH;;AACD,QAAIuB,MAAM,GAAGlB,gBAAgB,CAACD,OAA9B,EAAuC;AACnCC,MAAAA,gBAAgB,CAACD,OAAjB,GAA2BmB,MAA3B;AACH;AACJ;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,WAASC,UAAT,CAAoBM,GAApB,EAAyBC,GAAzB,EAA8BC,WAA9B,EAA2C;AACvC,QAAIC,MAAM,GAAG,KAAb;AACA,QAAIC,SAAJ;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,WAAW,CAACI,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AACzCD,MAAAA,SAAS,GAAGF,WAAW,CAACG,CAAD,CAAvB;AACAF,MAAAA,MAAM,GAAGA,MAAM,IAAKC,SAAS,CAAC,SAAD,CAAT,KAAyBJ,GAAzB,IAAgCI,SAAS,CAAC,SAAD,CAAT,KAAyBH,GAA7E;AACH;;AACD,WAAOE,MAAP;AACH;AAED;AACJ;AACA;;;AACI,iBAAeI,YAAf,GAA8B;AAC1B,UAAMC,MAAM,GAAG;AACXC,MAAAA,OAAO,EAAE3D,SADE;AAEX4D,MAAAA,OAAO,EAAE1D,SAFE;AAGXE,MAAAA,QAAQ,EAAEA,QAHC;AAIXE,MAAAA,QAAQ,EAAEA;AAJC,KAAf;AAOA,QAAIuD,MAAM,GAAG;AACTC,MAAAA,OAAO,EAAE;AACL,wBAAgB,kBADX;AAEL,uCAA+B;AAF1B;AADA,KAAb;AAMA,UAAMC,GAAG,GAAG,MAAMjE,KAAK,CAACkE,IAAN,CACd,6BADc,EAEdN,MAFc,EAGdG,MAHc,CAAlB;AAKA,WAAOE,GAAG,CAAC,MAAD,CAAH,CAAY,OAAZ,CAAP;AACH,GAzIY,CA2Ib;;;AACA,iBAAejB,WAAf,CAA2BmB,WAA3B,EAAwC;AACpC,UAAMP,MAAM,GAAG;AACXQ,MAAAA,IAAI,EAAED,WAAW,CAAC,CAAD,CADN;AAEXE,MAAAA,KAAK,EAAEF,WAAW,CAAC,CAAD,CAFP;AAGXG,MAAAA,IAAI,EAAEH,WAAW,CAAC,CAAD,CAHN;AAIXI,MAAAA,KAAK,EAAEJ,WAAW,CAAC,CAAD;AAJP,KAAf;AAMA,QAAIJ,MAAM,GAAG;AACTC,MAAAA,OAAO,EAAE;AACL,wBAAgB,kBADX;AAEL,uCAA+B;AAF1B;AADA,KAAb;AAMA,UAAMC,GAAG,GAAG,MAAMjE,KAAK,CAACkE,IAAN,CACd,4BADc,EAEdN,MAFc,EAGdG,MAHc,CAAlB;AAKA,WAAOE,GAAG,CAAC,MAAD,CAAH,CAAY,MAAZ,CAAP;AACH;AAED;AACJ;AACA;;;AACI,WAASO,cAAT,CAAwBpB,GAAxB,EAA6BC,GAA7B,EAAkCoB,SAAlC,EAA6CC,SAA7C,EAAwD;AACpD,UAAMd,MAAM,GAAG;AACXR,MAAAA,GAAG,EAAEA,GADM;AAEXC,MAAAA,GAAG,EAAEA;AAFM,KAAf;AAKA,QAAIU,MAAM,GAAG;AACTC,MAAAA,OAAO,EAAE;AACL,wBAAgB,kBADX;AAEL,uCAA+B;AAF1B;AADA,KAAb;AAOAhE,IAAAA,KAAK,CAACkE,IAAN,CACI,+BADJ,EAEIN,MAFJ,EAGIG,MAHJ,EAKKY,IALL,CAKUC,QAAQ,IAAI;AACd;AACA,aAAOA,QAAQ,CAACC,IAAhB;AACH,KARL,EASKF,IATL,CASWE,IAAD,IAAU;AACZ,aAAOA,IAAI,CAAC,cAAD,CAAX;AACH,KAXL,EAYKF,IAZL,CAYWG,QAAD,IAAc;AAChBL,MAAAA,SAAS,CAACK,QAAQ,CAAC,CAAD,CAAT,CAAT;AACAJ,MAAAA,SAAS,CAACI,QAAQ,CAAC,CAAD,CAAT,CAAT;AACAnE,MAAAA,QAAQ,CAAC,EAAD,CAAR,CAHgB,CAIhB;AACH,KAjBL,EAkBKoE,KAlBL,CAkBW,UAAUC,KAAV,EAAiB;AACpBC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH,KApBL;AAqBH;;AAED,WAASG,cAAT,GAA0B;AACtB,UAAMC,eAAe,GAAGxD,cAAc,CAACF,OAAvC,CADsB,CAEtB;;AACA,UAAM2D,aAAa,GAAGC,gBAAgB,EAAtC,CAHsB,CAItB;;AACA,UAAMC,SAAS,GAAGF,aAAa,CAAC,CAAD,CAA/B;AACA,UAAMG,QAAQ,GAAGH,aAAa,CAAC,CAAD,CAA9B;AACA,QAAII,SAAS,GAAG,EAAhB,CAPsB,CAQtB;;AACA,SAAK,IAAIhC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2B,eAAe,CAAC1B,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;AAC7C,YAAMD,SAAS,GAAG4B,eAAe,CAAC3B,CAAD,CAAjC;AACA,YAAMiC,cAAc,GAAGzC,cAAc,CAACO,SAAS,CAAC,SAAD,CAAV,EAAuBA,SAAS,CAAC,SAAD,CAAhC,EAA6ClC,UAA7C,CAArC,CAF6C,CAG7C;;AACA,YAAMqE,UAAU,GAAGD,cAAc,CAAC,CAAD,CAAjC;AACA,YAAME,WAAW,GAAGF,cAAc,CAAC,CAAD,CAAlC;AACA,YAAMG,aAAa,GAAGH,cAAc,CAAC,CAAD,CAApC;AACA,YAAMI,YAAY,GAAGJ,cAAc,CAAC,CAAD,CAAnC,CAP6C,CAQ7C;AACA;;AACA,YAAMK,UAAU,GAAIF,aAAa,GAAG5E,MAAjB,IAA6B0E,UAAU,GAAGJ,SAA1C,IACXO,YAAY,GAAG5E,OADJ,IACiB0E,WAAW,GAAGJ,QADlD,CAV6C,CAY7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAI,CAACO,UAAL,EAAiB;AACb;AACA7C,QAAAA,QAAQ,CAACkC,eAAe,CAAC3B,CAAD,CAAhB,CAAR;AACAgC,QAAAA,SAAS,CAACtC,IAAV,CAAeK,SAAf;AACH;AACJ;;AACD5B,IAAAA,cAAc,CAACF,OAAf,GAAyB+D,SAAzB,CApCsB,CAsCtB;AACA;;AACA,WAAOxC,cAAc,CAAC1B,cAAc,CAACG,OAAhB,EAAyBF,eAAe,CAACE,OAAzC,EAAkDJ,UAAlD,CAAd,CAA4E,CAA5E,IAAiFL,MAAxF,EAA+F;AAC3F;AACAM,MAAAA,cAAc,CAACG,OAAf,IAA0BJ,UAA1B;AACH;;AACD,WAAO2B,cAAc,CAAC1B,cAAc,CAACG,OAAhB,EAAyBF,eAAe,CAACE,OAAzC,EAAkDJ,UAAlD,CAAd,CAA4E,CAA5E,IAAiFJ,OAAxF,EAAgG;AAC5F;AACAM,MAAAA,eAAe,CAACE,OAAhB,IAA2BJ,UAA3B;AACH;;AACD,WAAOG,iBAAiB,CAACC,OAAlB,GAA4B6D,SAAnC,EAA6C;AACzC;AACA9D,MAAAA,iBAAiB,CAACC,OAAlB,IAA6BJ,UAA7B;AACH;;AACD,WAAOK,gBAAgB,CAACD,OAAjB,GAA2B8D,QAAlC,EAA2C;AACvC;AACA7D,MAAAA,gBAAgB,CAACD,OAAjB,IAA4BJ,UAA5B;AACH,KAvDqB,CAyDtB;;;AACA,WAAOE,eAAe,CAACE,OAAhB,GAA0BR,OAAjC,EAA0C;AACtC;AACA;AACAM,MAAAA,eAAe,CAACE,OAAhB,IAA2BJ,UAA3B;AACH;;AACD,WAAOC,cAAc,CAACG,OAAf,GAAyBT,MAAhC,EAAwC;AACpC;AACA;AACAM,MAAAA,cAAc,CAACG,OAAf,IAA0BJ,UAA1B;AACH;;AACD,WAAOG,iBAAiB,CAACC,OAAlB,IAA6B6D,SAApC,EAA+C;AAC3C;;AACA;AACZ;AACY9D,MAAAA,iBAAiB,CAACC,OAAlB,IAA6BJ,UAA7B;AACH;;AACD,WAAOK,gBAAgB,CAACD,OAAjB,IAA4B8D,QAAnC,EAA6C;AACzC;;AACA;AACZ;AACY7D,MAAAA,gBAAgB,CAACD,OAAjB,IAA4BJ,UAA5B;AACH;;AACDe,IAAAA,eAAe,CAACd,cAAc,CAACG,OAAhB,EAAyBF,eAAe,CAACE,OAAzC,EACXD,iBAAiB,CAACC,OADP,EACgBC,gBAAgB,CAACD,OADjC,EAC0CK,aAAa,CAACL,OADxD,CAAf,CAhFsB,CAkFtB;AACA;AACH;;AAED,WAASU,SAAT,GAAqB;AACjB4D,IAAAA,WAAW;AACXb,IAAAA,cAAc,GAFG,CAGjB;;AACAc,IAAAA,SAAS;AACZ;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,WAASC,gBAAT,CAA0B9C,GAA1B,EAA+BC,GAA/B,EAAoC;AAChC,UAAM8C,aAAa,GAAGlF,MAAM,GAAGmC,GAA/B;AACA,UAAMgD,aAAa,GAAG/C,GAAG,GAAGnC,OAA5B,CAFgC,CAGhC;AACA;AACA;AAEA;;AACA,WAAO,CAACmF,MAAM,CAACD,aAAD,CAAP,EAAwBC,MAAM,CAACF,aAAD,CAA9B,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACI,WAASE,MAAT,CAAgBC,SAAhB,EAA2B;AACvB,UAAMC,mBAAmB,GAAG3F,kBAAkB,GAAGO,WAAjD;AACA,WAAOmF,SAAS,GAAGC,mBAAnB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,WAASC,gBAAT,CAA0BC,IAA1B,EAAgCC,GAAhC,EAAqC;AACjC,UAAM1E,MAAM,GAAGH,SAAS,CAACH,OAAzB;AACA,UAAMiF,cAAc,GAAGF,IAAI,GAAGzE,MAAM,CAAC4E,UAArC;AACA,UAAMC,aAAa,GAAGH,GAAG,GAAG1E,MAAM,CAAC8E,SAAnC,CAHiC,CAIjC;AACA;;AAEA,UAAMC,SAAS,GAAG9F,MAAM,GAAG+F,SAAS,CAACH,aAAD,CAApC;AACA,UAAMI,SAAS,GAAG/F,OAAO,GAAG8F,SAAS,CAACL,cAAD,CAArC,CARiC,CASjC;AACA;AAEA;;AACA,WAAO,CAACI,SAAD,EAAYE,SAAZ,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACI,WAASD,SAAT,CAAmBE,MAAnB,EAA2B;AACvB,UAAMC,mBAAmB,GAAIhG,WAAW,GAAGP,kBAA3C;AACA,WAAOsG,MAAM,GAAGC,mBAAhB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACI,WAAS7B,gBAAT,GAA4B;AACxB,WAAOrC,cAAc,CAAChC,MAAD,EAASC,OAAT,EAAkBC,WAAlB,CAArB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,WAAS8B,cAAT,CAAwBmE,SAAxB,EAAmCC,UAAnC,EAA+CC,QAA/C,EAAyD;AACrD;AACA,WAAO,CAACF,SAAD,EAAYC,UAAZ,EAAwBD,SAAS,GAAGE,QAApC,EAA8CD,UAAU,GAAGC,QAA3D,CAAP;AACH;;AAED,WAASC,iBAAT,CAA2BC,QAA3B,EAAqCC,QAArC,EAA+C;AAC3C,UAAMC,OAAO,GAAGF,QAAQ,GAAGpG,UAA3B,CAD2C,CACJ;;AACvC,UAAMuG,OAAO,GAAGF,QAAQ,GAAGpG,UAA3B,CAF2C,CAEJ;AACvC;AACA;;AAEA,QAAIuG,IAAI,CAACC,GAAL,CAASH,OAAT,IAAoB5G,WAApB,IAAmC8G,IAAI,CAACC,GAAL,CAASF,OAAT,IAAoB7G,WAA3D,EAAwE;AACpE;AACA,YAAMgH,GAAG,GAAGhG,MAAM,CAACJ,OAAnB;AACAoG,MAAAA,GAAG,CAACC,SAAJ,GAAgB,OAAhB,CAHoE,CAIpE;;AACA,YAAMC,WAAW,GAAGxB,gBAAgB,CAACgB,QAAD,EAAWC,QAAX,CAApC,CALoE,CAMpE;;AACA,UAAIvH,SAAS,KAAK,EAAlB,EAAsB;AAClBsE,QAAAA,cAAc,CAACwD,WAAW,CAAC,CAAD,CAAZ,EAAiBA,WAAW,CAAC,CAAD,CAA5B,EAAiC7H,YAAjC,EAA+CE,YAA/C,CAAd;AACH,OAFD,MAEO;AACHmE,QAAAA,cAAc,CAACwD,WAAW,CAAC,CAAD,CAAZ,EAAiBA,WAAW,CAAC,CAAD,CAA5B,EAAiCzH,WAAjC,EAA8CE,WAA9C,CAAd;AACH;AACJ,KAZD,MAYO;AACHsB,MAAAA,aAAa,CAACL,OAAd,IAAyB,CAAzB,CADG,CAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAMuG,UAAU,GAAG/G,OAAO,GAAG8F,SAAS,CAACU,OAAD,CAAtC;AACA;AACZ;AACA;AACA;AACA;AACY;;AACA,YAAMQ,SAAS,GAAGjH,MAAM,GAAG+F,SAAS,CAACW,OAAD,CAApC;AACA;AACZ;AACA;AACA;AACA;AACY;AACA;;AACA,YAAMQ,YAAY,GAAG,CAACD,SAAD,EAAYD,UAAZ,EAAwBlH,SAAS,CAAC,CAAD,CAAjC,CAArB;AACAC,MAAAA,YAAY,CAACmH,YAAD,CAAZ;AACH;AACJ;;AAED,WAASC,eAAT,CAAyBC,SAAzB,EAAoCC,MAApC,EAA4CC,MAA5C,EAAoDC,UAApD,EAAgE;AAC5DzG,IAAAA,aAAa,CAACL,OAAd,IAAyB,CAAzB,CAD4D,CAE5D;;AACA,UAAM+G,gBAAgB,GAAGjC,gBAAgB,CAAC8B,MAAD,EAASC,MAAT,CAAzC;AACA,UAAMG,iBAAiB,GAAGzH,MAAM,GAAGwH,gBAAgB,CAAC,CAAD,CAAnD;AACA,UAAME,iBAAiB,GAAGF,gBAAgB,CAAC,CAAD,CAAhB,GAAsBvH,OAAhD;AACA,UAAM0H,WAAW,GAAIF,iBAAiB,GAAGvH,WAAzC;AACA,UAAM0H,WAAW,GAAIF,iBAAiB,GAAGxH,WAAzC,CAP4D,CAS5D;AACA;;AACA,QAAIkH,SAAJ,EAAe;AACX,YAAMS,QAAQ,GAAI3H,WAAW,GAAGyG,IAAI,CAACmB,GAAL,CAAS,IAAT,EAAeP,UAAf,CAAf,GAA6CrH,WAA9D,CADW,CAEX;;AACA,YAAM6H,cAAc,GAAG7H,WAAW,GAAG2H,QAArC,CAHW,CAIX;AACA;;AACA,YAAMZ,SAAS,GAAGjH,MAAM,GAAI2H,WAAW,GAAGE,QAA1C,CANW,CAOX;AACA;;AACA,YAAMb,UAAU,GAAG/G,OAAO,GAAI2H,WAAW,GAAGC,QAA5C;AACA,YAAMX,YAAY,GAAG,CAACD,SAAD,EAAYD,UAAZ,EAAwBe,cAAxB,CAArB;AACAhI,MAAAA,YAAY,CAACmH,YAAD,CAAZ;AACH,KAZD,MAYO;AACH,YAAMW,QAAQ,GAAG3H,WAAW,GAAIA,WAAW,GAAGyG,IAAI,CAACmB,GAAL,CAAS,IAAT,EAAeP,UAAf,CAA9C,CADG,CAEH;;AACA,YAAMQ,cAAc,GAAG7H,WAAW,GAAG2H,QAArC,CAHG,CAIH;AACA;;AACA,YAAMZ,SAAS,GAAGjH,MAAM,GAAI2H,WAAW,GAAGE,QAA1C,CANG,CAOH;AACA;;AACA,YAAMb,UAAU,GAAG/G,OAAO,GAAI2H,WAAW,GAAGC,QAA5C;AACA,YAAMX,YAAY,GAAG,CAACD,SAAD,EAAYD,UAAZ,EAAwBe,cAAxB,CAArB;AACAhI,MAAAA,YAAY,CAACmH,YAAD,CAAZ;AACH,KAnC2D,CAoC5D;;AACH;;AAED,WAASnC,WAAT,GAAuB;AACnB,UAAM8B,GAAG,GAAGhG,MAAM,CAACJ,OAAnB;AACA,UAAMM,MAAM,GAAGH,SAAS,CAACH,OAAzB;AACAoG,IAAAA,GAAG,CAACmB,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoBjH,MAAM,CAACC,KAA3B,EAAkCD,MAAM,CAACE,MAAzC;AACH;;AAED,WAASgB,QAAT,CAAkBgG,UAAlB,EAA8B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,IAAAA,UAAU,CAAC,MAAD,CAAV,CAAmBC,OAAnB,CAA2BC,QAA3B;AACH;;AAED,WAASC,UAAT,CAAoBjG,GAApB,EAAyBC,GAAzB,EAA8BiG,MAA9B,EAAsC;AAClC,UAAMxB,GAAG,GAAGhG,MAAM,CAACJ,OAAnB;AACA,UAAM6H,QAAQ,GAAGrD,gBAAgB,CAAC9C,GAAD,EAAMC,GAAN,CAAjC;AACAyE,IAAAA,GAAG,CAAC0B,WAAJ,GAAkB,KAAlB;AACA1B,IAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA3B,IAAAA,GAAG,CAAC4B,SAAJ;AACA5B,IAAAA,GAAG,CAAC6B,GAAJ,CAAQJ,QAAQ,CAAC,CAAD,CAAhB,EAAqBA,QAAQ,CAAC,CAAD,CAA7B,EAAkCD,MAAlC,EAA0C,CAA1C,EAA6C,IAAI1B,IAAI,CAACgC,EAAtD;AACA9B,IAAAA,GAAG,CAAC+B,MAAJ;AACH,GA7eY,CA+eb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,WAASC,UAAT,CAAoBC,GAApB,EAAyB;AACrB,UAAMjC,GAAG,GAAGhG,MAAM,CAACJ,OAAnB;AACA,QAAIsI,aAAa,GAAGD,GAAG,CAAC,UAAD,CAAvB;AACA,QAAIE,aAAa,GAAGF,GAAG,CAAC,WAAD,CAAvB;AACA,QAAIG,QAAQ,GAAGhE,gBAAgB,CAAC8D,aAAD,EAAgBC,aAAhB,CAA/B;AACAnC,IAAAA,GAAG,CAACC,SAAJ,GAAgB,MAAhB;AACAD,IAAAA,GAAG,CAAC0B,WAAJ,GAAkB,MAAlB;AACA1B,IAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA3B,IAAAA,GAAG,CAAC4B,SAAJ;AACA5B,IAAAA,GAAG,CAACqC,MAAJ,CAAWD,QAAQ,CAAC,CAAD,CAAnB,EAAwBA,QAAQ,CAAC,CAAD,CAAhC;AACA,QAAIE,WAAW,GAAGL,GAAG,CAAC,SAAD,CAArB,CAVqB,CAWrB;;AACA,QAAIM,YAAY,GAAGN,GAAG,CAAC,UAAD,CAAtB,CAZqB,CAarB;;AACA,QAAIO,MAAM,GAAGpE,gBAAgB,CAACkE,WAAD,EAAcC,YAAd,CAA7B,CAdqB,CAerB;;AACAvC,IAAAA,GAAG,CAACyC,MAAJ,CAAWD,MAAM,CAAC,CAAD,CAAjB,EAAsBA,MAAM,CAAC,CAAD,CAA5B;AACAxC,IAAAA,GAAG,CAAC+B,MAAJ;AACH,GA/iBY,CAijBb;;;AACA,WAAST,QAAT,CAAkBW,GAAlB,EAAuB;AACnB,UAAMjC,GAAG,GAAGhG,MAAM,CAACJ,OAAnB;AACA,QAAIsI,aAAa,GAAGQ,MAAM,CAACT,GAAG,CAAC,UAAD,CAAJ,CAA1B;AACA,QAAIE,aAAa,GAAGO,MAAM,CAACT,GAAG,CAAC,WAAD,CAAJ,CAA1B;AACA,QAAIG,QAAQ,GAAGhE,gBAAgB,CAAC8D,aAAD,EAAgBC,aAAhB,CAA/B;;AACA,YAAQF,GAAG,CAAC,MAAD,CAAX;AACI,WAAK,OAAL;AACIjC,QAAAA,GAAG,CAACC,SAAJ,GAAgB,cAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,cAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,aAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,OAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,OAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,SAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,OAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,OAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,WAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,gBAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,gBAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,OAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,WAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,WAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,UAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,WAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,WAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,OAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,YAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,YAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,SAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,YAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,YAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,gBAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,MAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,MAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,YAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,UAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,UAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,MAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,WAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,WAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,eAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,YAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,YAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,UAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,eAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,eAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,UAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,YAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,YAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,eAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,cAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,cAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,SAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,MAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,MAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,cAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,MAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,MAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,YAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,QAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,QAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,OAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,eAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,eAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,cAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,KAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,KAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,eAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,SAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,SAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ,WAAK,MAAL;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,QAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,QAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AACA;;AACJ;AACI3B,QAAAA,GAAG,CAACC,SAAJ,GAAgB,UAAhB;AACAD,QAAAA,GAAG,CAAC0B,WAAJ,GAAkB,UAAlB;AACA1B,QAAAA,GAAG,CAAC2B,SAAJ,GAAgB,CAAhB;AAlHR;;AAoHA3B,IAAAA,GAAG,CAAC4B,SAAJ;AACA5B,IAAAA,GAAG,CAACqC,MAAJ,CAAWD,QAAQ,CAAC,CAAD,CAAnB,EAAwBA,QAAQ,CAAC,CAAD,CAAhC;AACA,QAAIE,WAAW,GAAGI,MAAM,CAACT,GAAG,CAAC,SAAD,CAAJ,CAAxB;AACA,QAAIM,YAAY,GAAGG,MAAM,CAACT,GAAG,CAAC,UAAD,CAAJ,CAAzB;AACA,QAAIO,MAAM,GAAGpE,gBAAgB,CAACkE,WAAD,EAAcC,YAAd,CAA7B;AACAvC,IAAAA,GAAG,CAACyC,MAAJ,CAAWD,MAAM,CAAC,CAAD,CAAjB,EAAsBA,MAAM,CAAC,CAAD,CAA5B;AACAxC,IAAAA,GAAG,CAAC+B,MAAJ;AACH,GAlrBY,CAorBb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,iBAAeY,QAAf,GAA0B;AACtB;AACA,UAAMC,SAAS,GAAG,MAAM/G,YAAY,EAApC,CAFsB,CAGtB;;AACAhD,IAAAA,QAAQ,CAAC+J,SAAD,CAAR,CAJsB,CAKtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH;;AAED,WAASzE,SAAT,GAAqB;AACjB,SAAK,MAAM8D,GAAX,IAAkBrJ,KAAlB,EAAyB;AACrBoJ,MAAAA,UAAU,CAACC,GAAD,CAAV;AACH;AACJ;;AAED,WAASY,QAAT,GAAoB;AAChB;AACAC,IAAAA,WAAW,CAAC,EAAD,CAAX;AACAC,IAAAA,WAAW,CAAC,EAAD,CAAX;AACAC,IAAAA,UAAU,CAAC,EAAD,CAAV;AACAC,IAAAA,UAAU,CAAC,EAAD,CAAV,CALgB,CAOhB;;AACApK,IAAAA,QAAQ,CAAC,EAAD,CAAR,CARgB,CAUhB;AACA;AACH;;AAED,MAAIqK,aAAa,GAAG,CAApB;AACA,MAAIC,YAAJ;AAEA,sBACI;AAAA,4BACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YADJ,eAEI,QAAC,OAAD;AAAS,MAAA,KAAK,EAAE,gBAAhB;AAAkC,MAAA,MAAM,EAAE/K,SAA1C;AAAqD,MAAA,MAAM,EAAEC;AAA7D;AAAA;AAAA;AAAA;AAAA,YAFJ,eAGI,QAAC,OAAD;AAAS,MAAA,KAAK,EAAE,gBAAhB;AAAkC,MAAA,MAAM,EAAEC,SAA1C;AAAqD,MAAA,MAAM,EAAEC;AAA7D;AAAA;AAAA;AAAA;AAAA,YAHJ,eAII,QAAC,OAAD;AAAS,MAAA,KAAK,EAAE,sBAAhB;AAAwC,MAAA,MAAM,EAAEC,QAAhD;AAA0D,MAAA,MAAM,EAAEC;AAAlE;AAAA;AAAA;AAAA;AAAA,YAJJ,eAKI,QAAC,OAAD;AAAS,MAAA,KAAK,EAAE,sBAAhB;AAAwC,MAAA,MAAM,EAAEC,QAAhD;AAA0D,MAAA,MAAM,EAAEC;AAAlE;AAAA;AAAA;AAAA;AAAA,YALJ,eAMI;AAAQ,MAAA,OAAO,EAAEgK,QAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YANJ,eAOI;AAAQ,MAAA,OAAO,EAAEE,QAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAPJ,eAQI;AAAA;AAAA;AAAA;AAAA,YARJ,eAYI;AAAQ,MAAA,GAAG,EAAE9I,SAAb;AAAwB,MAAA,WAAW,EAAGqJ,KAAD,IAAW;AAC5C9J,QAAAA,UAAU,GAAG8J,KAAK,CAACC,KAAnB;AACA9J,QAAAA,UAAU,GAAG6J,KAAK,CAACE,KAAnB;AACH,OAHD;AAGG,MAAA,SAAS,EAAGF,KAAD,IAAW;AACrB;AACA3D,QAAAA,iBAAiB,CAAC2D,KAAK,CAACC,KAAP,EAAcD,KAAK,CAACE,KAApB,CAAjB;AACH,OAND;AAMG,MAAA,OAAO,EAAGF,KAAD,IAAW;AACnBA,QAAAA,KAAK,CAACG,eAAN,GADmB,CAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAIH,KAAK,CAACI,MAAN,GAAe,CAAnB,EAAsB;AAClB;AACAlD,UAAAA,eAAe,CAAC,KAAD,EAAQ8C,KAAK,CAACC,KAAd,EAAqBD,KAAK,CAACE,KAA3B,EAAkC,CAAlC,CAAf;AACH,SAHD,MAGO;AACH;AACAhD,UAAAA,eAAe,CAAC,IAAD,EAAO8C,KAAK,CAACC,KAAb,EAAoBD,KAAK,CAACE,KAA1B,EAAiC,CAAjC,CAAf;AACH;AACJ;AA7BD;AAAA;AAAA;AAAA;AAAA,YAZJ;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AA6CH;;GA1xBQnL,K;;KAAAA,K;AA4xBT,eAAeA,KAAf","sourcesContent":["import './App.css';\nimport TextBox from \"./TextBox\";\nimport React, {useState, useEffect, useRef} from 'react';\nimport axios from 'axios';\nimport \"react-awesome-button/dist/styles.css\";\n\nfunction Route() {\n    // const [startLat, setStartLat] = useState(\"\");\n    // const [startLon, setStartLon] = useState(\"\");\n    // const [destLat, setDestLat] = useState(\"\");\n    // const [destLon, setDestLon] = useState(\"\");\n    const [startInt1, setStartInt1] = useState(\"\");\n    const [startInt2, setStartInt2] = useState(\"\");\n    const [destInt1, setDestInt1] = useState(\"\");\n    const [destInt2, setDestInt2] = useState(\"\");\n    const [route, setRoute] = useState([]);\n    const CANVAS_SIDE_LENGTH = 450;\n    const SCROLL_WAIT = 100;\n    const CLICK_RANGE = 5;\n    const [mapWindow, setMapWindow] = useState([41.8320, -71.4070, 0.0113])\n    const topLat = mapWindow[0];\n    const leftLon = mapWindow[1];\n    const latLonRange = mapWindow[2];\n    let mouseDownX;\n    let mouseDownY;\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n    // In order to get bottomLat or rightLon, just subtract latLonRange from topLat, or add it to leftLon\n\n    const TILE_WIDTH = 0.0016; // this is an arbitrarily chosen-value, but it works well\n    let topmostTileLat = useRef(topLat);\n    let leftmostTileLon = useRef(leftLon);\n    let bottommostTileLat = useRef(topmostTileLat.current);\n    let rightmostTileLon = useRef(leftmostTileLon.current);\n    let tilesLoadedRef = useRef([]);\n    // Tiles should be JavaScript objects with properties topLat, leftLon, and an [] of ways\n    // Ways should be length-4 list of Doubles: [lat1, lon1, lat2, lon2]\n\n    const canvasRef = useRef();\n    let ctxRef = useRef();\n    let reloadCounter = useRef(0);\n\n    /**\n     * Code to run when the page loads\n     */\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        canvas.width = CANVAS_SIDE_LENGTH;\n        canvas.height = CANVAS_SIDE_LENGTH;\n        ctxRef.current = canvas.getContext(\"2d\");\n        // let ctx = ctxRef.current;\n        // ctx.fillStyle = \"green\";\n        // ctx.fillRect(0, 0, 100, 100);\n\n        // Loading starting tiles is taken care of by the automatic redrawMap() call\n        //const boundaries = getMapBoundaries();\n        //loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n    }, [ ]);\n\n    useEffect(() => {\n        //TODO if we uncomment the below console.log, we'll see that the map gets reloaded four times every\n        // time the canvas is clicked (once for each useState() parameter that gets changed)\n        // which is kinda wasteful of resources, though it doesn't impact user experience\n        // If we want to fix it, we could combine all four startLat/startLon/destLat/destLon\n        // into one const [routeEndCoords, setRouteEndCoords] = useState([\"\",\"\",\"\",\"\"])\n        //console.log(\"reload number \" + reloadCounter.current);\n        redrawMap();\n    })\n\n    async function loadTilesWithin(topLatLimit, leftLonLimit, bottomLatLimit, rightLonLimit, reloadNum) {\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n        // const tilesLoadedTemp = tilesLoadedRef.current;\n        let newTile;\n        let curLat = topLatLimit;\n        let curLon = leftLonLimit;\n        while (curLon < rightLonLimit) {\n            while (curLat > bottomLatLimit) {\n                if (reloadNum !== reloadCounter.current) {\n                    return;\n                }\n                // Check if the tile has already been loaded\n                if (!tileLoaded(curLat, curLon, tilesLoadedRef.current)) {\n                    const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n                    newTile = {\"tileLat\": curLat, \"tileLon\": curLon, \"ways\": ways};\n                    drawTile(newTile);\n                    tilesLoadedRef.current.push(newTile);\n                }\n\n                curLat -= TILE_WIDTH;\n            }\n            if (curLat < bottommostTileLat.current) {\n                bottommostTileLat.current = curLat;\n            }\n            curLat = topLatLimit;\n            curLon += TILE_WIDTH;\n        }\n        if (curLon > rightmostTileLon.current) {\n            rightmostTileLon.current = curLon;\n        }\n    }\n\n    /**\n     * Determines whether a tile with a given lat/lon coordinate has been cached on the client-side\n     * or note. Returns a boolean.\n     * @param lat - latitude coordinate of tile to check\n     * @param lon - longitude coordinate of tile to check\n     * @param loadedTiles - list of tiles that have been loaded already\n     * @returns {boolean} - whether or not the tile is cached already\n     */\n    function tileLoaded(lat, lon, loadedTiles) {\n        let loaded = false;\n        let checkTile;\n        for (let i = 0; i < loadedTiles.length; i++) {\n            checkTile = loadedTiles[i];\n            loaded = loaded || (checkTile[\"tileLat\"] === lat && checkTile[\"tileLon\"] === lon);\n        }\n        return loaded;\n    }\n\n    /**\n     * Makes an axios request.\n     */\n    async function requestRoute() {\n        const toSend = {\n            srcInt1: startInt1,\n            srcInt2: startInt2,\n            destInt1: destInt1,\n            destInt2: destInt2\n        };\n\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n        const res = await axios.post(\n            \"http://localhost:4567/route\",\n            toSend,\n            config\n        );\n        return res[\"data\"][\"route\"];\n    }\n\n    //uses post request to get ways within bounding box\n    async function requestWays(coordinates) {\n        const toSend = {\n            lat1: coordinates[0],\n            long1: coordinates[1],\n            lat2: coordinates[2],\n            long2: coordinates[3]\n        };\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n        const res = await axios.post(\n            \"http://localhost:4567/ways\",\n            toSend,\n            config\n        );\n        return res[\"data\"][\"ways\"];\n    }\n\n    /**\n     * Makes an axios request to get the coordinates of the node nearest to a clicked lat and lon.\n     */\n    function requestNearest(lat, lon, latSetter, lonSetter) {\n        const toSend = {\n            lat: lat,\n            lon: lon\n        };\n\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n\n        axios.post(\n            \"http://localhost:4567/nearest\",\n            toSend,\n            config\n        )\n            .then(response => {\n                // console.log(response.data);\n                return response.data;\n            })\n            .then((data) => {\n                return data[\"intersection\"];\n            })\n            .then((newCoord) => {\n                latSetter(newCoord[0]);\n                lonSetter(newCoord[1]);\n                setRoute([]);\n                // redrawMap();\n            })\n            .catch(function (error) {\n                console.log(error);\n            });\n    }\n\n    function clearLoadTiles() {\n        const tilesLoadedTemp = tilesLoadedRef.current;\n        // First, purge old tiles\n        const mapBoundaries = getMapBoundaries();\n        //these are backwards\n        const bottomLat = mapBoundaries[2];\n        const rightLon = mapBoundaries[3];\n        let saveTiles = [];\n        // Iterate over all the loaded tiles and see if they're still useful\n        for (let i = 0; i < tilesLoadedTemp.length; i++) {\n            const checkTile = tilesLoadedTemp[i];\n            const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n            // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n            const tileTopLat = tileBoundaries[0];\n            const tileLeftLon = tileBoundaries[1];\n            const tileBottomLat = tileBoundaries[2];\n            const tileRightLon = tileBoundaries[3];\n            // We expect latitudes within the map range to be LESS than the topLat\n            // We expect longitudes within the map range to be GREATER than the leftLon\n            const deleteTile = (tileBottomLat > topLat) || (tileTopLat < bottomLat)\n                || (tileRightLon < leftLon) || (tileLeftLon > rightLon);\n            // if (tileBottomLat > topLat) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n            // }\n            // if (tileLeftLon > rightLon) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the right side\");\n            // }\n            // if (deleteTile) {\n            //     console.log(\"deleting tile\");\n            // }\n            if (!deleteTile) {\n                // console.log(\"rendering tile for reload number \" + reloadNum);\n                drawTile(tilesLoadedTemp[i]);\n                saveTiles.push(checkTile);\n            }\n        }\n        tilesLoadedRef.current = saveTiles;\n\n        // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n        // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n        while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[2] > topLat){\n            // console.log(\"adjusting loaded top boundary\");\n            topmostTileLat.current -= TILE_WIDTH;\n        }\n        while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[3] < leftLon){\n            // console.log(\"adjusting loaded left boundary\");\n            leftmostTileLon.current += TILE_WIDTH;\n        }\n        while (bottommostTileLat.current < bottomLat){\n            // console.log(\"adjusting loaded bottom boundary\");\n            bottommostTileLat.current += TILE_WIDTH;\n        }\n        while (rightmostTileLon.current > rightLon){\n            // console.log(\"adjusting loaded right boundary\");\n            rightmostTileLon.current -= TILE_WIDTH;\n        }\n\n        // Now, load new tiles\n        while (leftmostTileLon.current > leftLon) {\n            //console.log(\"gap at left\");\n            // loadTilesWithin(topmostTileLat.current, leftmostTileLon.current - TILE_WIDTH, bottommostTileLat.current, leftmostTileLon.current);\n            leftmostTileLon.current -= TILE_WIDTH;\n        }\n        while (topmostTileLat.current < topLat) {\n            //console.log(\"gap at top\");\n            // loadTilesWithin(topmostTileLat.current + TILE_WIDTH, leftmostTileLon.current, topmostTileLat.current, rightmostTileLon.current);\n            topmostTileLat.current += TILE_WIDTH;\n        }\n        while (bottommostTileLat.current >= bottomLat) {\n            //console.log(\"gap at bottom\");\n            /*loadTilesWithin(bottommostTileLat.current, leftmostTileLon.current - TILE_WIDTH,\n                bottommostTileLat.current - (2.0 * TILE_WIDTH), rightmostTileLon.current);*/\n            bottommostTileLat.current -= TILE_WIDTH;\n        }\n        while (rightmostTileLon.current <= rightLon) {\n            //console.log(\"gap at right\");\n            /*loadTilesWithin(topmostTileLat.current, rightmostTileLon.current + TILE_WIDTH,\n                bottommostTileLat.current, rightmostTileLon.current + (2.0 * TILE_WIDTH));*/\n            rightmostTileLon.current += TILE_WIDTH;\n        }\n        loadTilesWithin(topmostTileLat.current, leftmostTileLon.current,\n            bottommostTileLat.current, rightmostTileLon.current, reloadCounter.current);\n        // console.log(\"num tiles after loading: \" + tilesLoadedTemp.length);\n        //drawLoadedRect();\n    }\n\n    function redrawMap() {\n        clearCanvas();\n        clearLoadTiles();\n        //drawStartEndCircles();\n        drawRoute();\n    }\n\n    /**\n     * Code to turn lat/lon coordinates into pixel coordinates for the canvas:\n     * takes in a latitude and longitude coordinate, returns a length-2 list with the\n     * corresponding pixel position on the canvas [left, top]\n     * @param lat - the latitude coordinate to turn into a pixel left coordinate\n     * @param lon - the longitude coordinate to turn into a pixel top coordinate\n     * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n     */\n    function latLonCoordToPix(lat, lon) {\n        const normalizedLat = topLat - lat;\n        const normalizedLon = lon - leftLon;\n        // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n    }\n\n    /**\n     * Converts a single latitude/longitude coordinate value into a pixel value.\n     * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n     * @returns {number} the pixel conversion of the lat/lon value\n     */\n    function pixIfy(latLonVal) {\n        const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n        return latLonVal * pixOverLatLonFactor;\n    }\n\n    /**\n     * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n     * and longitude coordinate.\n     * Returns a length-2 list with [lat, lon].\n     * @param left - the pixel left coordinate to turn into map latitude\n     * @param top - the pixel top coordinate to turn into map longitude\n     * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n     */\n    function pixCoordToLatLon(left, top) {\n        const canvas = canvasRef.current;\n        const normalizedLeft = left - canvas.offsetLeft;\n        const normalizedTop = top - canvas.offsetTop;\n        // console.log(normalizedLeft + \", \" + normalizedTop);\n        // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n        const returnLat = topLat - latLonIfy(normalizedTop);\n        const returnLon = leftLon + latLonIfy(normalizedLeft);\n        // console.log(returnLat, \", \", returnLon)\n        // console.log(latLonCoordToPix(returnLat, returnLon));\n\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [returnLat, returnLon];\n    }\n\n    /**\n     * Turns a single value in pixels into a value in latitude/longitude coordinates.\n     * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n     * @returns {number} the lat/lon conversion of the pixel value\n     */\n    function latLonIfy(pixVal) {\n        const latLonOverPixFactor =  latLonRange / CANVAS_SIDE_LENGTH;\n        return pixVal * latLonOverPixFactor;\n    }\n\n    /**\n     * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n     * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of the current map frame.\n     */\n    function getMapBoundaries() {\n        return getBoundingBox(topLat, leftLon, latLonRange);\n    }\n\n    /**\n     * Get the lat/lon boundaries of a passed square area with unknown side length.\n     * @param boxtopLat latitude coordinate of the northwest corner\n     * @param boxleftLon longitude coordinate of the northwest corner\n     * @param boxRange side length, in terms of lat/lon coordinates\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of a passed square.\n     */\n    function getBoundingBox(boxtopLat, boxleftLon, boxRange) {\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [boxtopLat, boxleftLon, boxtopLat - boxRange, boxleftLon + boxRange];\n    }\n\n    function handleClickOrDrag(mouseUpX, mouseUpY) {\n        const xChange = mouseUpX - mouseDownX; // positive if the map is dragged to the right\n        const yChange = mouseUpY - mouseDownY; // positive if the map is dragged downwards\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n\n        if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n            // This was a click!\n            const ctx = ctxRef.current;\n            ctx.fillStyle = \"green\";\n            // console.log(pixCoordToLatLon(mouseUpX, mouseUpY));\n            const latLonCoord = pixCoordToLatLon(mouseUpX, mouseUpY);\n            //if (startLat === 0 || startLat.toString() === \"\")\n            if (startInt1 === \"\") {\n                requestNearest(latLonCoord[0], latLonCoord[1], setStartInt1, setStartInt2);\n            } else {\n                requestNearest(latLonCoord[0], latLonCoord[1], setDestInt1, setDestInt2);\n            }\n        } else {\n            reloadCounter.current += 1;\n            // console.log(\"reload number \" + reloadCounter.current);\n            // This was a drag!\n            // REMEMBER: lat is y-value, lon is x-value!\n            //console.log(xChange, yChange);\n            //console.log(latLonIfy(xChange), latLonIfy(yChange));\n            //console.log(topLat + \", \" + leftLon);\n            //setLeftLon(leftLon - latLonIfy(xChange));\n            const newLeftLon = leftLon - latLonIfy(xChange);\n            /*\n             * positive values, dragging the map to the right\n             * moves the previous leftLon rightwards\n             * meaning that the new leftLon should be less than the previous leftLon\n             */\n            //setTopLat(topLat + latLonIfy(yChange));\n            const newTopLat = topLat + latLonIfy(yChange);\n            /*\n             * positive values, dragging the map downwards\n             * moves the previous topLat downwards\n             * meaning that the new topLat should be greater than the previous topLat\n             */\n            //console.log(topLat + \", \" + leftLon);\n            // redrawMap();\n            const newMapWindow = [newTopLat, newLeftLon, mapWindow[2]];\n            setMapWindow(newMapWindow);\n        }\n    }\n\n    function handleZoomInOut(zoomedOut, mouseX, mouseY, numScrolls) {\n        reloadCounter.current += 1;\n        // console.log(\"reload number \" + reloadCounter.current);\n        const mouseLatLonCoord = pixCoordToLatLon(mouseX, mouseY);\n        const zoomLatNormalized = topLat - mouseLatLonCoord[0];\n        const zoomLonNormalized = mouseLatLonCoord[1] - leftLon;\n        const latFraction = (zoomLatNormalized / latLonRange);\n        const lonFraction = (zoomLonNormalized / latLonRange);\n\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n        if (zoomedOut) {\n            const stepSize = (latLonRange * Math.pow(1.05, numScrolls)) - latLonRange;\n            //setLatLonRange(latLonRange + stepSize);\n            const newLatLonRange = latLonRange + stepSize;\n            // We're zooming out, so the topLat should move upwards\n            //setTopLat(topLat + (latFraction * stepSize));\n            const newTopLat = topLat + (latFraction * stepSize);\n            // and leftLon should move leftwards\n            //setLeftLon(leftLon - (lonFraction * stepSize));\n            const newLeftLon = leftLon - (lonFraction * stepSize);\n            const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n            setMapWindow(newMapWindow);\n        } else {\n            const stepSize = latLonRange - (latLonRange * Math.pow(0.95, numScrolls));\n            //setLatLonRange(latLonRange - stepSize);\n            const newLatLonRange = latLonRange - stepSize;\n            // We're zooming in, so the topLat should move downwards\n            //setTopLat(topLat - (latFraction * stepSize));\n            const newTopLat = topLat - (latFraction * stepSize);\n            // and leftLon should move inwards\n            //setLeftLon(leftLon + (lonFraction * stepSize));\n            const newLeftLon = leftLon + (lonFraction * stepSize);\n            const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n            setMapWindow(newMapWindow);\n        }\n        // redrawMap();\n    }\n\n    function clearCanvas() {\n        const ctx = ctxRef.current;\n        const canvas = canvasRef.current;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    function drawTile(tileToDraw) {\n        // const mapBoundaries = getMapBoundaries();\n        // // We expect latitudes within the map range to be LESS than the topLat\n        // // We expect longitudes within the map range to be GREATER than the leftLon\n        // const withinMapBoundaries = (tileToDraw[\"tileLat\"] < mapBoundaries[0])\n        //     && (tileToDraw[\"tileLat\"] > mapBoundaries[2])\n        //     && (tileToDraw[\"tileLon\"] > mapBoundaries[1])\n        //     && (tileToDraw[\"tileLon\"] < mapBoundaries[3]);\n        // if (!withinMapBoundaries) {\n        //     console.log(tileToDraw);\n        // }\n        tileToDraw[\"ways\"].forEach(traceWay);\n    }\n\n    function drawCircle(lat, lon, radius) {\n        const ctx = ctxRef.current;\n        const pixCoord = latLonCoordToPix(lat, lon);\n        ctx.strokeStyle = \"red\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.arc(pixCoord[0], pixCoord[1], radius, 0, 2 * Math.PI);\n        ctx.stroke();\n    }\n\n    // function drawStartEndCircles() {\n    //     // And add the circles for the selected start/destination!\n    //     const radius = pixIfy(latLonRange / 100);\n    //     //console.log(\"startLat and startLon:\");\n    //     //console.log(startLat + \" \" + startLon);\n    //     if (startInt1.toString() === \"\"\n    //         ||  startInt2.toString() === \"\"){\n    //         // drawing start circle\n    //         //drawCircle(startLat, startLon, radius);\n    //     }\n    //     if (!(parseFloat(destLon) === 0 || destLon.toString() === \"\"\n    //         || parseFloat(destLat) === 0 || destLat.toString() === \"\")){\n    //         // drawing destination circle\n    //         //drawCircle(destLat, destLon, radius);\n    //     }\n    // }\n\n    // function drawLoadedRect(){\n    //     const ctx = ctxRef.current;\n    //     const loadedPixBoxTopLeft = latLonCoordToPix(topmostTileLat.current, leftmostTileLon.current);\n    //     const loadedPixBoxBottomRight = latLonCoordToPix(bottommostTileLat.current, rightmostTileLon.current);\n    //     const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n    //     const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n    //     ctx.strokeStyle = \"red\";\n    //     ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n    // }\n    //\n    // function drawSquare(tileToDraw) {\n    //     const ctx = ctxRef.current;\n    //     ctx.fillStyle = \"lightgreen\";\n    //     const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n    //     const baseX = tileCoord[0];\n    //     const baseY = tileCoord[1];\n    //\n    //     const pixTileWidth = pixIfy(TILE_WIDTH);\n    //     // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n    //     //      Math.min(baseX + pixTileWidth, pixTileWidth),\n    //     //      Math.min(baseY + pixTileWidth, pixTileWidth));\n    //     ctx.strokeStyle = \"black\";\n    //     ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n    //         Math.min(baseX + pixTileWidth, pixTileWidth),\n    //         Math.min(baseY + pixTileWidth, pixTileWidth));\n    //     ctx.fillStyle = \"black\";\n    //     ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n    // }\n\n    function traceRoute(way) {\n        const ctx = ctxRef.current;\n        let startLatCoord = way[\"startLat\"]\n        let startLonCoord = way[\"startLong\"]\n        let pixStart = latLonCoordToPix(startLatCoord, startLonCoord)\n        ctx.fillStyle = \"blue\";\n        ctx.strokeStyle = \"blue\";\n        ctx.lineWidth = 4;\n        ctx.beginPath();\n        ctx.moveTo(pixStart[0], pixStart[1])\n        let endLatCoord = way[\"destLat\"]\n        //console.log(endLatCoord)\n        let endLongCoord = way[\"destLong\"]\n        //console.log(endLongCoord)\n        let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord)\n        //console.log(pixEnd)\n        ctx.lineTo(pixEnd[0], pixEnd[1])\n        ctx.stroke();\n    }\n\n    //M picked colors randomly feel free to change colors if you would like\n    function traceWay(way) {\n        const ctx = ctxRef.current;\n        let startLatCoord = Number(way[\"startLat\"])\n        let startLonCoord = Number(way[\"startLong\"])\n        let pixStart = latLonCoordToPix(startLatCoord, startLonCoord)\n        switch (way[\"type\"]) {\n            case 'ROUTE':\n                ctx.fillStyle = \"MidnightBlue\";\n                ctx.strokeStyle = \"MidnightBlue\";\n                ctx.lineWidth = 1;\n                break;\n            case 'residential':\n                ctx.fillStyle = \"green\";\n                ctx.strokeStyle = \"green\";\n                ctx.lineWidth = 1;\n                break;\n            case 'service':\n                ctx.fillStyle = \"Coral\";\n                ctx.strokeStyle = \"Coral\";\n                ctx.lineWidth = 1;\n                break;\n            case 'secondary':\n                ctx.fillStyle = \"CornflowerBlue\";\n                ctx.strokeStyle = \"CornflowerBlue\";\n                ctx.lineWidth = 1;\n                break;\n            case 'track':\n                ctx.fillStyle = \"Chocolate\";\n                ctx.strokeStyle = \"Chocolate\";\n                ctx.lineWidth = 1;\n                break;\n            case 'tertiary':\n                ctx.fillStyle = \"LightPink\";\n                ctx.strokeStyle = \"LightPink\";\n                ctx.lineWidth = 1;\n                break;\n            case 'trunk':\n                ctx.fillStyle = \"DarkOrchid\";\n                ctx.strokeStyle = \"DarkOrchid\";\n                ctx.lineWidth = 1;\n                break;\n            case 'primary':\n                ctx.fillStyle = \"DarkViolet\";\n                ctx.strokeStyle = \"DarkViolet\";\n                ctx.lineWidth = 1;\n                break;\n            case 'secondary_link':\n                ctx.fillStyle = \"Gold\";\n                ctx.strokeStyle = \"Gold\";\n                ctx.lineWidth = 1;\n                break;\n            case 'trunk_link':\n                ctx.fillStyle = \"Lavender\";\n                ctx.strokeStyle = \"Lavender\";\n                ctx.lineWidth = 1;\n                break;\n            case 'path':\n                ctx.fillStyle = \"LightBlue\";\n                ctx.strokeStyle = \"LightBlue\";\n                ctx.lineWidth = 1;\n                break;\n            case 'motorway_link':\n                ctx.fillStyle = \"LightGreen\";\n                ctx.strokeStyle = \"LightGreen\";\n                ctx.lineWidth = 1;\n                break;\n            case 'motorway':\n                ctx.fillStyle = \"LightSeaGreen\";\n                ctx.strokeStyle = \"LightSeaGreen\";\n                ctx.lineWidth = 1;\n                break;\n            case 'cycleway':\n                ctx.fillStyle = \"MediumBlue\";\n                ctx.strokeStyle = \"MediumBlue\";\n                ctx.lineWidth = 1;\n                break;\n            case 'tertiary_link':\n                ctx.fillStyle = \"MediumPurple\";\n                ctx.strokeStyle = \"MediumPurple\";\n                ctx.lineWidth = 1;\n                break;\n            case 'footway':\n                ctx.fillStyle = \"Plum\";\n                ctx.strokeStyle = \"Plum\";\n                ctx.lineWidth = 1;\n                break;\n            case 'primary_link':\n                ctx.fillStyle = \"Pink\";\n                ctx.strokeStyle = \"Pink\";\n                ctx.lineWidth = 1;\n                break;\n            case 'pedestrian':\n                ctx.fillStyle = \"Orange\";\n                ctx.strokeStyle = \"Orange\";\n                ctx.lineWidth = 1;\n                break;\n            case 'steps':\n                ctx.fillStyle = \"PaleVioletRed\";\n                ctx.strokeStyle = \"PaleVioletRed\";\n                ctx.lineWidth = 1;\n                break;\n            case 'construction':\n                ctx.fillStyle = \"Red\";\n                ctx.strokeStyle = \"Red\";\n                ctx.lineWidth = 1;\n                break;\n            case 'living_street':\n                ctx.fillStyle = \"SkyBlue\";\n                ctx.strokeStyle = \"SkyBlue\";\n                ctx.lineWidth = 1;\n                break;\n            case 'road':\n                ctx.fillStyle = \"Yellow\";\n                ctx.strokeStyle = \"Yellow\";\n                ctx.lineWidth = 1;\n                break;\n            default:\n                ctx.fillStyle = \"DarkGray\";\n                ctx.strokeStyle = \"DarkGray\";\n                ctx.lineWidth = 1;\n        }\n        ctx.beginPath();\n        ctx.moveTo(pixStart[0], pixStart[1])\n        let endLatCoord = Number(way[\"destLat\"])\n        let endLongCoord = Number(way[\"destLong\"])\n        let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord)\n        ctx.lineTo(pixEnd[0], pixEnd[1])\n        ctx.stroke();\n    }\n\n    //traces route from 2 selected points in blue\n    //M this disappears if you scroll or pan i think, im not sure how to fix it i will leave it for now\n    // and we can come back to this\n    // Maxime reply: I think I went ahead and fixed this!\n    // It was because of the redrawMap() method, which gets called anytime we scroll or pan,\n    // and ever time it gets called, it calls the clearCanvas() method to wipe the canvas\n    // (including the route we just drew), then it redraws all of the ways.\n    //TODO we could probably lump all this functionality directly into the requestRoute() method\n    // Since all we really need is to use the setRoute() method to store the route data\n    async function getRoute() {\n        // console.log(\"should draw the route\");\n        const routeTemp = await requestRoute();\n        // console.log(routeTemp);\n        setRoute(routeTemp);\n        // drawRoute()\n\n        // Now we'll auto-zoom to a proper display size!\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n        // const latRange = Math.abs(startLat - destLat);\n        // const lonRange = Math.abs(startLon - destLon);\n        // const routeTopLat = Math.max(startLat, destLat);\n        // const routeLeftLon = Math.min(startLon, destLon);\n        // const maxRange = Math.max(latRange, lonRange);\n        // const centerLatPadding = (maxRange - latRange) / 2.0;\n        // const centerLonPadding = (maxRange - lonRange) / 2.0;\n        // const overallPadding = 0.1 * maxRange; // We'll add a border of 10% of the longest dimension of the path\n        // const newTopLat = routeTopLat + centerLatPadding + overallPadding;\n        // const newLeftLon = routeLeftLon - centerLonPadding - overallPadding;\n        // const newLatLonRange = maxRange + (2 * overallPadding);\n        // const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n        // setMapWindow(newMapWindow);\n    }\n\n    function drawRoute() {\n        for (const way of route) {\n            traceRoute(way)\n        }\n    }\n\n    function clearMap() {\n        // clear out the clicked/entered-in points\n        setStartLat(\"\");\n        setStartLon(\"\");\n        setDestLat(\"\");\n        setDestLon(\"\");\n\n        // also clear out any loaded route\n        setRoute([]);\n\n        // rerender the map\n        // redrawMap();\n    }\n\n    let scrollCounter = 0;\n    let scrollFinish;\n\n    return (\n        <div>\n            <h1>Maps GUI</h1>\n            <TextBox label={\"Start Street 1\"} boxVal={startInt1} change={setStartInt1}/>\n            <TextBox label={\"Start Street 2\"} boxVal={startInt2} change={setStartInt2}/>\n            <TextBox label={\"Destination Street 1\"} boxVal={destInt1} change={setDestInt1}/>\n            <TextBox label={\"Destination Street 2\"} boxVal={destInt2} change={setDestInt2}/>\n            <button onClick={getRoute}>Map Route</button>\n            <button onClick={clearMap}>Clear Map</button>\n            <br/>\n            {/*{route.map((coord, index) =>*/}\n            {/*    <p key={index}>{coord[0]}, {coord[1]}</p>*/}\n            {/*)}*/}\n            <canvas ref={canvasRef} onMouseDown={(event) => {\n                mouseDownX = event.pageX;\n                mouseDownY = event.pageY;\n            }} onMouseUp={(event) => {\n                //pixCoordToLatLon(event.pageX, event.pageY);\n                handleClickOrDrag(event.pageX, event.pageY);\n            }} onWheel={(event) => {\n                event.stopPropagation();\n                // scrollCounter++;\n                // // Scrolling!\n                // clearTimeout(scrollFinish)\n                // scrollFinish = setTimeout(() => {\n                //     // Not scrolling anymore\n                //     if (event.deltaY < 0) {\n                //         // Scrolling up\n                //         handleZoomInOut(false, event.pageX, event.pageY, scrollCounter);\n                //     } else {\n                //         // Scrolling down\n                //         handleZoomInOut(true, event.pageX, event.pageY, scrollCounter);\n                //     }\n                // }, SCROLL_WAIT);\n                // Scrolling!\n                if (event.deltaY < 0) {\n                    // Scrolling up\n                    handleZoomInOut(false, event.pageX, event.pageY, 1);\n                } else {\n                    // Scrolling down\n                    handleZoomInOut(true, event.pageX, event.pageY, 1);\n                }\n            }}/>\n        </div>\n    );\n}\n\nexport default Route;"]},"metadata":{},"sourceType":"module"}