{"ast":null,"code":"var _jsxFileName = \"/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js\",\n    _s = $RefreshSig$();\n\nimport './App.css';\nimport TextBox from \"./TextBox\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport axios from 'axios';\nimport \"react-awesome-button/dist/styles.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Route() {\n  _s();\n\n  const [startLat, setStartLat] = useState(\"\");\n  const [startLon, setStartLon] = useState(\"\");\n  const [destLat, setDestLat] = useState(\"\");\n  const [destLon, setDestLon] = useState(\"\");\n  const [route, setRoute] = useState([]); //const [ways, setWays] = useState([]);\n\n  const CANVAS_SIDE_LENGTH = 450;\n  const SCROLL_WAIT = 100;\n  const CLICK_RANGE = 5; //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n  // are implemented\n\n  const [mapWindow, setMapWindow] = useState([41.8320, -71.4070, 0.0113]);\n  const topLat = mapWindow[0];\n  const leftLon = mapWindow[1];\n  const latLonRange = mapWindow[2]; // const [topLat, setTopLat] = useState(41.8320);\n  // const [leftLon, setLeftLon] = useState(-71.4070);\n  // const [latLonRange, setLatLonRange] = useState(0.0113);\n\n  let mouseDownX;\n  let mouseDownY; // We expect latitudes within the map range to be LESS than the topLat\n  // We expect longitudes within the map range to be GREATER than the leftLon\n  // In order to get bottomLat or rightLon, just subtract latLonRange from topLat, or add it to leftLon\n\n  const TILE_WIDTH = 0.0016; // this is an arbitrarily chosen-value, but it works well\n\n  let topmostTileLat = useRef(topLat);\n  let leftmostTileLon = useRef(leftLon);\n  let bottommostTileLat = useRef(topmostTileLat.current);\n  let rightmostTileLon = useRef(leftmostTileLon.current);\n  let tilesLoadedRef = useRef([]); // Tiles should be JavaScript objects with properties topLat, leftLon, and an [] of ways\n  // Ways should be length-4 list of Doubles: [lat1, lon1, lat2, lon2]\n\n  const canvasRef = useRef();\n  let ctxRef = useRef();\n  let reloadCounter = useRef(0);\n  /**\n   * Code to run when the page loads\n   */\n\n  useEffect(() => {\n    //console.log(\"page loaded!\");\n    const canvas = canvasRef.current;\n    canvas.width = CANVAS_SIDE_LENGTH;\n    canvas.height = CANVAS_SIDE_LENGTH;\n    ctxRef.current = canvas.getContext(\"2d\"); // let ctx = ctxRef.current;\n    // ctx.fillStyle = \"green\";\n    // ctx.fillRect(0, 0, 100, 100);\n    // Loading starting tiles is taken care of by the automatic redrawMap() call\n    //const boundaries = getMapBoundaries();\n    //loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n  }, []);\n  useEffect(() => {\n    //TODO if we uncomment the below console.log, we'll see that the map gets reloaded four times every\n    // time the canvas is clicked (once for each useState() parameter that gets changed)\n    // which is kinda wasteful of resources, though it doesn't impact user experience\n    // If we want to fix it, we could combine all four startLat/startLon/destLat/destLon\n    // into one const [routeEndCoords, setRouteEndCoords] = useState([\"\",\"\",\"\",\"\"])\n    //console.log(\"reload number \" + reloadCounter.current);\n    redrawMap();\n  });\n\n  async function loadTilesWithin(topLatLimit, leftLonLimit, bottomLatLimit, rightLonLimit, reloadNum) {\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n    // const tilesLoadedTemp = tilesLoadedRef.current;\n    let newTile;\n    let curLat = topLatLimit;\n    let curLon = leftLonLimit;\n\n    while (curLon < rightLonLimit) {\n      while (curLat > bottomLatLimit) {\n        if (reloadNum !== reloadCounter.current) {\n          return;\n        } // Check if the tile has already been loaded\n        //console.log(tileLoaded(curLat, curLon, tilesLoadedRef.current));\n\n\n        if (!tileLoaded(curLat, curLon, tilesLoadedRef.current)) {\n          const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH)); //console.log(ways);\n\n          newTile = {\n            \"tileLat\": curLat,\n            \"tileLon\": curLon,\n            \"ways\": ways\n          }; // Tiles previously had a randomly-generated \"name\" property: \"name\":Math.round(Math.random()*100)\n          // console.log(\"rendering tile for reload number \" + reloadNum);\n\n          drawTile(newTile); // console.log(newTile);\n\n          tilesLoadedRef.current.push(newTile);\n        }\n\n        curLat -= TILE_WIDTH;\n      } // console.log(\"curLat: \" + curLat);\n\n\n      if (curLat < bottommostTileLat.current) {\n        bottommostTileLat.current = curLat;\n      }\n\n      curLat = topLatLimit;\n      curLon += TILE_WIDTH;\n    }\n\n    if (curLon > rightmostTileLon.current) {\n      rightmostTileLon.current = curLon;\n    } // console.log(\"num tiles loaded: \" + tilesLoadedRef.current.length);\n    //tilesLoadedRef.current = tilesLoadedTemp;\n\n  }\n  /**\n   * Determines whether a tile with a given lat/lon coordinate has been cached on the client-side\n   * or note. Returns a boolean.\n   * @param lat - latitude coordinate of tile to check\n   * @param lon - longitude coordinate of tile to check\n   * @param loadedTiles - list of tiles that have been loaded already\n   * @returns {boolean} - whether or not the tile is cached already\n   */\n\n\n  function tileLoaded(lat, lon, loadedTiles) {\n    // console.log(\"checking tile \" + lat + \" \" + lon);\n    //console.log(\"num tiles checking: \" + loadedTiles.length);\n    let loaded = false;\n    let checkTile;\n\n    for (let i = 0; i < loadedTiles.length; i++) {\n      checkTile = loadedTiles[i];\n      loaded = loaded || checkTile[\"tileLat\"] === lat && checkTile[\"tileLon\"] === lon;\n    }\n\n    return loaded;\n  }\n  /**\n   * Makes an axios request.\n   */\n\n\n  async function requestRoute() {\n    const toSend = {\n      srclat: startLat,\n      srclong: startLon,\n      destlat: destLat,\n      destlong: destLon\n    }; // console.log(toSend);\n\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    const res = await axios.post(\"http://localhost:4567/route\", toSend, config); // console.log(res[\"data\"][\"route\"]);\n\n    return res[\"data\"][\"route\"];\n  } //uses post request to get ways within bounding box\n\n\n  async function requestWays(coordinates) {\n    const toSend = {\n      lat1: coordinates[0],\n      long1: coordinates[1],\n      lat2: coordinates[2],\n      long2: coordinates[3]\n    };\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    const res = await axios.post(\"http://localhost:4567/ways\", toSend, config);\n    return res[\"data\"][\"ways\"];\n  }\n  /**\n   * Makes an axios request to get the coordinates of the node nearest to a clicked lat and lon.\n   */\n\n\n  function requestNearest(lat, lon, latSetter, lonSetter) {\n    const toSend = {\n      lat: lat,\n      lon: lon\n    };\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    axios.post(\"http://localhost:4567/nearest\", toSend, config).then(response => {\n      // console.log(response.data);\n      return response.data;\n    }).then(data => {\n      const newLat = data[\"nearestLat\"];\n      const newLon = data[\"nearestLon\"];\n      return [newLat, newLon];\n    }).then(newCoord => {\n      latSetter(newCoord[0]);\n      lonSetter(newCoord[1]);\n      setRoute([]); // redrawMap();\n    }).catch(function (error) {\n      console.log(error);\n    });\n  }\n\n  function clearLoadTiles() {\n    const tilesLoadedTemp = tilesLoadedRef.current; // First, purge old tiles\n\n    const mapBoundaries = getMapBoundaries(); //these are backwards\n\n    const bottomLat = mapBoundaries[2];\n    const rightLon = mapBoundaries[3];\n    let saveTiles = []; // Iterate over all the loaded tiles and see if they're still useful\n\n    for (let i = 0; i < tilesLoadedTemp.length; i++) {\n      const checkTile = tilesLoadedTemp[i];\n      const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH); // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n\n      const tileTopLat = tileBoundaries[0];\n      const tileLeftLon = tileBoundaries[1];\n      const tileBottomLat = tileBoundaries[2];\n      const tileRightLon = tileBoundaries[3]; // We expect latitudes within the map range to be LESS than the topLat\n      // We expect longitudes within the map range to be GREATER than the leftLon\n\n      const deleteTile = tileBottomLat > topLat || tileTopLat < bottomLat || tileRightLon < leftLon || tileLeftLon > rightLon; // if (tileBottomLat > topLat) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n      // }\n      // if (tileLeftLon > rightLon) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the right side\");\n      // }\n      // if (deleteTile) {\n      //     console.log(\"deleting tile\");\n      // }\n\n      if (!deleteTile) {\n        // console.log(\"rendering tile for reload number \" + reloadNum);\n        drawTile(tilesLoadedTemp[i]);\n        saveTiles.push(checkTile);\n      }\n    }\n\n    tilesLoadedRef.current = saveTiles; // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n    // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n\n    while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[2] > topLat) {\n      // console.log(\"adjusting loaded top boundary\");\n      topmostTileLat.current -= TILE_WIDTH;\n    }\n\n    while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[3] < leftLon) {\n      // console.log(\"adjusting loaded left boundary\");\n      leftmostTileLon.current += TILE_WIDTH;\n    }\n\n    while (bottommostTileLat.current < bottomLat) {\n      // console.log(\"adjusting loaded bottom boundary\");\n      bottommostTileLat.current += TILE_WIDTH;\n    }\n\n    while (rightmostTileLon.current > rightLon) {\n      // console.log(\"adjusting loaded right boundary\");\n      rightmostTileLon.current -= TILE_WIDTH;\n    } // Now, load new tiles\n\n\n    while (leftmostTileLon.current > leftLon) {\n      //console.log(\"gap at left\");\n      // loadTilesWithin(topmostTileLat.current, leftmostTileLon.current - TILE_WIDTH, bottommostTileLat.current, leftmostTileLon.current);\n      leftmostTileLon.current -= TILE_WIDTH;\n    }\n\n    while (topmostTileLat.current < topLat) {\n      //console.log(\"gap at top\");\n      // loadTilesWithin(topmostTileLat.current + TILE_WIDTH, leftmostTileLon.current, topmostTileLat.current, rightmostTileLon.current);\n      topmostTileLat.current += TILE_WIDTH;\n    }\n\n    while (bottommostTileLat.current >= bottomLat) {\n      //console.log(\"gap at bottom\");\n\n      /*loadTilesWithin(bottommostTileLat.current, leftmostTileLon.current - TILE_WIDTH,\n          bottommostTileLat.current - (2.0 * TILE_WIDTH), rightmostTileLon.current);*/\n      bottommostTileLat.current -= TILE_WIDTH;\n    }\n\n    while (rightmostTileLon.current <= rightLon) {\n      //console.log(\"gap at right\");\n\n      /*loadTilesWithin(topmostTileLat.current, rightmostTileLon.current + TILE_WIDTH,\n          bottommostTileLat.current, rightmostTileLon.current + (2.0 * TILE_WIDTH));*/\n      rightmostTileLon.current += TILE_WIDTH;\n    }\n\n    loadTilesWithin(topmostTileLat.current, leftmostTileLon.current, bottommostTileLat.current, rightmostTileLon.current, reloadCounter.current); // console.log(\"num tiles after loading: \" + tilesLoadedTemp.length);\n    //drawLoadedRect();\n  }\n\n  function redrawMap() {\n    clearCanvas();\n    clearLoadTiles();\n    drawStartEndCircles();\n    drawRoute();\n  }\n  /**\n   * Code to turn lat/lon coordinates into pixel coordinates for the canvas:\n   * takes in a latitude and longitude coordinate, returns a length-2 list with the\n   * corresponding pixel position on the canvas [left, top]\n   * @param lat - the latitude coordinate to turn into a pixel left coordinate\n   * @param lon - the longitude coordinate to turn into a pixel top coordinate\n   * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n   */\n\n\n  function latLonCoordToPix(lat, lon) {\n    const normalizedLat = topLat - lat;\n    const normalizedLon = lon - leftLon; // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n    // REMEMBER: lat is y-value, lon is x-value!\n\n    return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n  }\n  /**\n   * Converts a single latitude/longitude coordinate value into a pixel value.\n   * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n   * @returns {number} the pixel conversion of the lat/lon value\n   */\n\n\n  function pixIfy(latLonVal) {\n    const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n    return latLonVal * pixOverLatLonFactor;\n  }\n  /**\n   * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n   * and longitude coordinate.\n   * Returns a length-2 list with [lat, lon].\n   * @param left - the pixel left coordinate to turn into map latitude\n   * @param top - the pixel top coordinate to turn into map longitude\n   * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n   */\n\n\n  function pixCoordToLatLon(left, top) {\n    const canvas = canvasRef.current;\n    const normalizedLeft = left - canvas.offsetLeft;\n    const normalizedTop = top - canvas.offsetTop; // console.log(normalizedLeft + \", \" + normalizedTop);\n    // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n    const returnLat = topLat - latLonIfy(normalizedTop);\n    const returnLon = leftLon + latLonIfy(normalizedLeft); // console.log(returnLat, \", \", returnLon)\n    // console.log(latLonCoordToPix(returnLat, returnLon));\n    // REMEMBER: lat is y-value, lon is x-value!\n\n    return [returnLat, returnLon];\n  }\n  /**\n   * Turns a single value in pixels into a value in latitude/longitude coordinates.\n   * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n   * @returns {number} the lat/lon conversion of the pixel value\n   */\n\n\n  function latLonIfy(pixVal) {\n    const latLonOverPixFactor = latLonRange / CANVAS_SIDE_LENGTH;\n    return pixVal * latLonOverPixFactor;\n  }\n  /**\n   * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n   * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of the current map frame.\n   */\n\n\n  function getMapBoundaries() {\n    return getBoundingBox(topLat, leftLon, latLonRange);\n  }\n  /**\n   * Get the lat/lon boundaries of a passed square area with unknown side length.\n   * @param boxtopLat latitude coordinate of the northwest corner\n   * @param boxleftLon longitude coordinate of the northwest corner\n   * @param boxRange side length, in terms of lat/lon coordinates\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of a passed square.\n   */\n\n\n  function getBoundingBox(boxtopLat, boxleftLon, boxRange) {\n    // REMEMBER: lat is y-value, lon is x-value!\n    return [boxtopLat, boxleftLon, boxtopLat - boxRange, boxleftLon + boxRange];\n  }\n\n  function handleClickOrDrag(mouseUpX, mouseUpY) {\n    const xChange = mouseUpX - mouseDownX; // positive if the map is dragged to the right\n\n    const yChange = mouseUpY - mouseDownY; // positive if the map is dragged downwards\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n\n    if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n      // This was a click!\n      const ctx = ctxRef.current;\n      ctx.fillStyle = \"green\"; // console.log(pixCoordToLatLon(mouseUpX, mouseUpY));\n\n      const latLonCoord = pixCoordToLatLon(mouseUpX, mouseUpY); //if (startLat === 0 || startLat.toString() === \"\")\n\n      if (startLat === \"\") {\n        requestNearest(latLonCoord[0], latLonCoord[1], setStartLat, setStartLon);\n      } else {\n        requestNearest(latLonCoord[0], latLonCoord[1], setDestLat, setDestLon);\n      }\n    } else {\n      reloadCounter.current += 1; // console.log(\"reload number \" + reloadCounter.current);\n      // This was a drag!\n      // REMEMBER: lat is y-value, lon is x-value!\n      //console.log(xChange, yChange);\n      //console.log(latLonIfy(xChange), latLonIfy(yChange));\n      //console.log(topLat + \", \" + leftLon);\n      //setLeftLon(leftLon - latLonIfy(xChange));\n\n      const newLeftLon = leftLon - latLonIfy(xChange);\n      /*\n       * positive values, dragging the map to the right\n       * moves the previous leftLon rightwards\n       * meaning that the new leftLon should be less than the previous leftLon\n       */\n      //setTopLat(topLat + latLonIfy(yChange));\n\n      const newTopLat = topLat + latLonIfy(yChange);\n      /*\n       * positive values, dragging the map downwards\n       * moves the previous topLat downwards\n       * meaning that the new topLat should be greater than the previous topLat\n       */\n      //console.log(topLat + \", \" + leftLon);\n      // redrawMap();\n\n      const newMapWindow = [newTopLat, newLeftLon, mapWindow[2]];\n      setMapWindow(newMapWindow);\n    }\n  }\n\n  function handleZoomInOut(zoomedOut, mouseX, mouseY, numScrolls) {\n    reloadCounter.current += 1; // console.log(\"reload number \" + reloadCounter.current);\n\n    const mouseLatLonCoord = pixCoordToLatLon(mouseX, mouseY);\n    const zoomLatNormalized = topLat - mouseLatLonCoord[0];\n    const zoomLonNormalized = mouseLatLonCoord[1] - leftLon;\n    const latFraction = zoomLatNormalized / latLonRange;\n    const lonFraction = zoomLonNormalized / latLonRange; // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n\n    if (zoomedOut) {\n      const stepSize = latLonRange * Math.pow(1.05, numScrolls) - latLonRange; //setLatLonRange(latLonRange + stepSize);\n\n      const newLatLonRange = latLonRange + stepSize; // We're zooming out, so the topLat should move upwards\n      //setTopLat(topLat + (latFraction * stepSize));\n\n      const newTopLat = topLat + latFraction * stepSize; // and leftLon should move leftwards\n      //setLeftLon(leftLon - (lonFraction * stepSize));\n\n      const newLeftLon = leftLon - lonFraction * stepSize;\n      const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n      setMapWindow(newMapWindow);\n    } else {\n      const stepSize = latLonRange - latLonRange * Math.pow(0.95, numScrolls); //setLatLonRange(latLonRange - stepSize);\n\n      const newLatLonRange = latLonRange - stepSize; // We're zooming in, so the topLat should move downwards\n      //setTopLat(topLat - (latFraction * stepSize));\n\n      const newTopLat = topLat - latFraction * stepSize; // and leftLon should move inwards\n      //setLeftLon(leftLon + (lonFraction * stepSize));\n\n      const newLeftLon = leftLon + lonFraction * stepSize;\n      const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n      setMapWindow(newMapWindow);\n    } // redrawMap();\n\n  }\n\n  function clearCanvas() {\n    const ctx = ctxRef.current;\n    const canvas = canvasRef.current;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  function drawTile(tileToDraw) {\n    // const mapBoundaries = getMapBoundaries();\n    // // We expect latitudes within the map range to be LESS than the topLat\n    // // We expect longitudes within the map range to be GREATER than the leftLon\n    // const withinMapBoundaries = (tileToDraw[\"tileLat\"] < mapBoundaries[0])\n    //     && (tileToDraw[\"tileLat\"] > mapBoundaries[2])\n    //     && (tileToDraw[\"tileLon\"] > mapBoundaries[1])\n    //     && (tileToDraw[\"tileLon\"] < mapBoundaries[3]);\n    // if (!withinMapBoundaries) {\n    //     console.log(tileToDraw);\n    // }\n    tileToDraw[\"ways\"].forEach(traceWay);\n  }\n\n  function drawCircle(lat, lon, radius) {\n    const ctx = ctxRef.current;\n    const pixCoord = latLonCoordToPix(lat, lon);\n    ctx.strokeStyle = \"red\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(pixCoord[0], pixCoord[1], radius, 0, 2 * Math.PI);\n    ctx.stroke();\n  }\n\n  function drawStartEndCircles() {\n    // And add the circles for the selected start/destination!\n    const radius = pixIfy(latLonRange / 100); //console.log(\"startLat and startLon:\");\n    //console.log(startLat + \" \" + startLon);\n\n    if (!(parseFloat(startLon) === 0 || startLon.toString() === \"\" || parseFloat(startLat) === 0 || startLat.toString() === \"\")) {\n      // drawing start circle\n      drawCircle(startLat, startLon, radius);\n    }\n\n    if (!(parseFloat(destLon) === 0 || destLon.toString() === \"\" || parseFloat(destLat) === 0 || destLat.toString() === \"\")) {\n      // drawing destination circle\n      drawCircle(destLat, destLon, radius);\n    }\n  } // function drawLoadedRect(){\n  //     const ctx = ctxRef.current;\n  //     const loadedPixBoxTopLeft = latLonCoordToPix(topmostTileLat.current, leftmostTileLon.current);\n  //     const loadedPixBoxBottomRight = latLonCoordToPix(bottommostTileLat.current, rightmostTileLon.current);\n  //     const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n  //     const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n  //     ctx.strokeStyle = \"red\";\n  //     ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n  // }\n  //\n  // function drawSquare(tileToDraw) {\n  //     const ctx = ctxRef.current;\n  //     ctx.fillStyle = \"lightgreen\";\n  //     const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n  //     const baseX = tileCoord[0];\n  //     const baseY = tileCoord[1];\n  //\n  //     const pixTileWidth = pixIfy(TILE_WIDTH);\n  //     // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n  //     //      Math.min(baseX + pixTileWidth, pixTileWidth),\n  //     //      Math.min(baseY + pixTileWidth, pixTileWidth));\n  //     ctx.strokeStyle = \"black\";\n  //     ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n  //         Math.min(baseX + pixTileWidth, pixTileWidth),\n  //         Math.min(baseY + pixTileWidth, pixTileWidth));\n  //     ctx.fillStyle = \"black\";\n  //     ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n  // }\n  //M TODO traceRoute and traceWay can be combined, but for now I am leaving as is because it works\n  // and I want to let you get started\n  // Maxime reply: yep! That makes sense, thank you!\n\n\n  function traceRoute(way) {\n    const ctx = ctxRef.current;\n    let startLatCoord = way[\"startLat\"];\n    let startLonCoord = way[\"startLong\"];\n    let pixStart = latLonCoordToPix(startLatCoord, startLonCoord);\n    ctx.fillStyle = \"blue\";\n    ctx.strokeStyle = \"blue\";\n    ctx.lineWidth = 4;\n    ctx.beginPath();\n    ctx.moveTo(pixStart[0], pixStart[1]);\n    let endLatCoord = way[\"destLat\"]; //console.log(endLatCoord)\n\n    let endLongCoord = way[\"destLong\"]; //console.log(endLongCoord)\n\n    let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord); //console.log(pixEnd)\n\n    ctx.lineTo(pixEnd[0], pixEnd[1]);\n    ctx.stroke();\n  } //M TODO i haven't done the optimization to minimize calls to stroke yet, this is something we can let the TA know\n  // or I can try to do tomorrow morning\n  // Maxime reply: don't worry about it too much! The map already renders really quickly, as is!\n\n\n  function traceWay(way) {\n    //console.log(way)\n    //probably should change wayslist into a hashmap\n    const ctx = ctxRef.current;\n    let startLatCoord = Number(way[\"startLat\"]);\n    let startLonCoord = Number(way[\"startLong\"]);\n    let pixStart = latLonCoordToPix(startLatCoord, startLonCoord);\n\n    switch (way[\"type\"]) {\n      case 'residential':\n        ctx.fillStyle = \"green\";\n        ctx.strokeStyle = \"green\";\n        ctx.lineWidth = 2;\n        break;\n\n      case 'service':\n        ctx.fillStyle = \"Coral\";\n        ctx.strokeStyle = \"Coral\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'secondary':\n        ctx.fillStyle = \"CornflowerBlue\";\n        ctx.strokeStyle = \"CornflowerBlue\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'track':\n        ctx.fillStyle = \"Chocolate\";\n        ctx.strokeStyle = \"Chocolate\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'tertiary':\n        ctx.fillStyle = \"DarkBlue\";\n        ctx.strokeStyle = \"DarkBlue\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'trunk':\n        ctx.fillStyle = \"DarkOrchid\";\n        ctx.strokeStyle = \"DarkOrchid\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'primary':\n        ctx.fillStyle = \"DarkViolet\";\n        ctx.strokeStyle = \"DarkViolet\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'service':\n        ctx.fillStyle = \"CornflowerBlue\";\n        ctx.strokeStyle = \"CornflowerBlue\";\n        ctx.lineWidth = 1;\n        break;\n    }\n\n    ctx.fillStyle = \"olivedrab\";\n    ctx.strokeStyle = \"olivedrab\";\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(pixStart[0], pixStart[1]);\n    let endLatCoord = Number(way[\"destLat\"]);\n    let endLongCoord = Number(way[\"destLong\"]);\n    let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord);\n    ctx.lineTo(pixEnd[0], pixEnd[1]);\n    ctx.stroke();\n  } //traces route from 2 selected points in blue\n  //M this disappears if you scroll or pan i think, im not sure how to fix it i will leave it for now\n  // and we can come back to this\n  // Maxime reply: I think I went ahead and fixed this!\n  // It was because of the redrawMap() method, which gets called anytime we scroll or pan,\n  // and ever time it gets called, it calls the clearCanvas() method to wipe the canvas\n  // (including the route we just drew), then it redraws all of the ways.\n  //TODO we could probably lump all this functionality directly into the requestRoute() method\n  // Since all we really need is to use the setRoute() method to store the route data\n\n\n  async function getRoute() {\n    // console.log(\"should draw the route\");\n    const routeTemp = await requestRoute(); // console.log(routeTemp);\n\n    setRoute(routeTemp); // drawRoute()\n    // Now we'll auto-zoom to a proper display size!\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n\n    const latRange = Math.abs(startLat - destLat);\n    const lonRange = Math.abs(startLon - destLon);\n    const routeTopLat = Math.max(startLat, destLat);\n    const routeLeftLon = Math.min(startLon, destLon);\n    const maxRange = Math.max(latRange, lonRange);\n    const centerLatPadding = (maxRange - latRange) / 2.0;\n    const centerLonPadding = (maxRange - lonRange) / 2.0;\n    const overallPadding = 0.1 * maxRange; // We'll add a border of 10% of the longest dimension of the path\n\n    const newTopLat = routeTopLat + centerLatPadding + overallPadding;\n    const newLeftLon = routeLeftLon - centerLonPadding - overallPadding;\n    const newLatLonRange = maxRange + 2 * overallPadding;\n    const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n    setMapWindow(newMapWindow);\n  }\n\n  function drawRoute() {\n    for (const way of route) {\n      traceRoute(way);\n    }\n  }\n\n  function clearMap() {\n    // clear out the clicked/entered-in points\n    setStartLat(\"\");\n    setStartLon(\"\");\n    setDestLat(\"\");\n    setDestLon(\"\"); // also clear out any loaded route\n\n    setRoute([]); // rerender the map\n    // redrawMap();\n  }\n\n  let scrollCounter = 0;\n  let scrollFinish;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Maps GUI\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 712,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Latitude\",\n      boxVal: startLat,\n      change: setStartLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 713,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Longitude\",\n      boxVal: startLon,\n      change: setStartLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 714,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Latitude\",\n      boxVal: destLat,\n      change: setDestLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 715,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Longitude\",\n      boxVal: destLon,\n      change: setDestLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 716,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: getRoute,\n      children: \"Map Route\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 717,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: clearMap,\n      children: \"Clear Map\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 718,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 719,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      onMouseDown: event => {\n        mouseDownX = event.pageX;\n        mouseDownY = event.pageY;\n      },\n      onMouseUp: event => {\n        //pixCoordToLatLon(event.pageX, event.pageY);\n        handleClickOrDrag(event.pageX, event.pageY);\n      },\n      onWheel: event => {\n        event.stopPropagation(); // scrollCounter++;\n        // // Scrolling!\n        // clearTimeout(scrollFinish)\n        // scrollFinish = setTimeout(() => {\n        //     // Not scrolling anymore\n        //     if (event.deltaY < 0) {\n        //         // Scrolling up\n        //         handleZoomInOut(false, event.pageX, event.pageY, scrollCounter);\n        //     } else {\n        //         // Scrolling down\n        //         handleZoomInOut(true, event.pageX, event.pageY, scrollCounter);\n        //     }\n        // }, SCROLL_WAIT);\n        // Scrolling!\n\n        if (event.deltaY < 0) {\n          // Scrolling up\n          handleZoomInOut(false, event.pageX, event.pageY, 1);\n        } else {\n          // Scrolling down\n          handleZoomInOut(true, event.pageX, event.pageY, 1);\n        }\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 723,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 711,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Route, \"FRDiDqMVgqVrezd6d2OcNKdYO1Q=\");\n\n_c = Route;\nexport default Route;\n\nvar _c;\n\n$RefreshReg$(_c, \"Route\");","map":{"version":3,"sources":["/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js"],"names":["TextBox","React","useState","useEffect","useRef","axios","Route","startLat","setStartLat","startLon","setStartLon","destLat","setDestLat","destLon","setDestLon","route","setRoute","CANVAS_SIDE_LENGTH","SCROLL_WAIT","CLICK_RANGE","mapWindow","setMapWindow","topLat","leftLon","latLonRange","mouseDownX","mouseDownY","TILE_WIDTH","topmostTileLat","leftmostTileLon","bottommostTileLat","current","rightmostTileLon","tilesLoadedRef","canvasRef","ctxRef","reloadCounter","canvas","width","height","getContext","redrawMap","loadTilesWithin","topLatLimit","leftLonLimit","bottomLatLimit","rightLonLimit","reloadNum","newTile","curLat","curLon","tileLoaded","ways","requestWays","getBoundingBox","drawTile","push","lat","lon","loadedTiles","loaded","checkTile","i","length","requestRoute","toSend","srclat","srclong","destlat","destlong","config","headers","res","post","coordinates","lat1","long1","lat2","long2","requestNearest","latSetter","lonSetter","then","response","data","newLat","newLon","newCoord","catch","error","console","log","clearLoadTiles","tilesLoadedTemp","mapBoundaries","getMapBoundaries","bottomLat","rightLon","saveTiles","tileBoundaries","tileTopLat","tileLeftLon","tileBottomLat","tileRightLon","deleteTile","clearCanvas","drawStartEndCircles","drawRoute","latLonCoordToPix","normalizedLat","normalizedLon","pixIfy","latLonVal","pixOverLatLonFactor","pixCoordToLatLon","left","top","normalizedLeft","offsetLeft","normalizedTop","offsetTop","returnLat","latLonIfy","returnLon","pixVal","latLonOverPixFactor","boxtopLat","boxleftLon","boxRange","handleClickOrDrag","mouseUpX","mouseUpY","xChange","yChange","Math","abs","ctx","fillStyle","latLonCoord","newLeftLon","newTopLat","newMapWindow","handleZoomInOut","zoomedOut","mouseX","mouseY","numScrolls","mouseLatLonCoord","zoomLatNormalized","zoomLonNormalized","latFraction","lonFraction","stepSize","pow","newLatLonRange","clearRect","tileToDraw","forEach","traceWay","drawCircle","radius","pixCoord","strokeStyle","lineWidth","beginPath","arc","PI","stroke","parseFloat","toString","traceRoute","way","startLatCoord","startLonCoord","pixStart","moveTo","endLatCoord","endLongCoord","pixEnd","lineTo","Number","getRoute","routeTemp","latRange","lonRange","routeTopLat","max","routeLeftLon","min","maxRange","centerLatPadding","centerLonPadding","overallPadding","clearMap","scrollCounter","scrollFinish","event","pageX","pageY","stopPropagation","deltaY"],"mappings":"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","sourcesContent":["import './App.css';\nimport TextBox from \"./TextBox\";\nimport React, {useState, useEffect, useRef} from 'react';\nimport axios from 'axios';\nimport \"react-awesome-button/dist/styles.css\";\n\nfunction Route() {\n    const [startLat, setStartLat] = useState(\"\");\n    const [startLon, setStartLon] = useState(\"\");\n    const [destLat, setDestLat] = useState(\"\");\n    const [destLon, setDestLon] = useState(\"\");\n    const [route, setRoute] = useState([]);\n    //const [ways, setWays] = useState([]);\n    const CANVAS_SIDE_LENGTH = 450;\n    const SCROLL_WAIT = 100;\n    const CLICK_RANGE = 5;\n    //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n    // are implemented\n    const [mapWindow, setMapWindow] = useState([41.8320, -71.4070, 0.0113])\n    const topLat = mapWindow[0];\n    const leftLon = mapWindow[1];\n    const latLonRange = mapWindow[2];\n    // const [topLat, setTopLat] = useState(41.8320);\n    // const [leftLon, setLeftLon] = useState(-71.4070);\n    // const [latLonRange, setLatLonRange] = useState(0.0113);\n    let mouseDownX;\n    let mouseDownY;\n    // We expect latitudes within the map range to be LESS than the topLat\n    // We expect longitudes within the map range to be GREATER than the leftLon\n    // In order to get bottomLat or rightLon, just subtract latLonRange from topLat, or add it to leftLon\n\n    const TILE_WIDTH = 0.0016; // this is an arbitrarily chosen-value, but it works well\n    let topmostTileLat = useRef(topLat);\n    let leftmostTileLon = useRef(leftLon);\n    let bottommostTileLat = useRef(topmostTileLat.current);\n    let rightmostTileLon = useRef(leftmostTileLon.current);\n    let tilesLoadedRef = useRef([]);\n    // Tiles should be JavaScript objects with properties topLat, leftLon, and an [] of ways\n    // Ways should be length-4 list of Doubles: [lat1, lon1, lat2, lon2]\n\n    const canvasRef = useRef();\n    let ctxRef = useRef();\n    let reloadCounter = useRef(0);\n\n    /**\n     * Code to run when the page loads\n     */\n    useEffect(() => {\n        //console.log(\"page loaded!\");\n        const canvas = canvasRef.current;\n        canvas.width = CANVAS_SIDE_LENGTH;\n        canvas.height = CANVAS_SIDE_LENGTH;\n        ctxRef.current = canvas.getContext(\"2d\");\n        // let ctx = ctxRef.current;\n        // ctx.fillStyle = \"green\";\n        // ctx.fillRect(0, 0, 100, 100);\n\n        // Loading starting tiles is taken care of by the automatic redrawMap() call\n        //const boundaries = getMapBoundaries();\n        //loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n    }, [ ]);\n\n    useEffect(() => {\n        //TODO if we uncomment the below console.log, we'll see that the map gets reloaded four times every\n        // time the canvas is clicked (once for each useState() parameter that gets changed)\n        // which is kinda wasteful of resources, though it doesn't impact user experience\n        // If we want to fix it, we could combine all four startLat/startLon/destLat/destLon\n        // into one const [routeEndCoords, setRouteEndCoords] = useState([\"\",\"\",\"\",\"\"])\n        //console.log(\"reload number \" + reloadCounter.current);\n        redrawMap();\n    })\n\n    async function loadTilesWithin(topLatLimit, leftLonLimit, bottomLatLimit, rightLonLimit, reloadNum) {\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n        // const tilesLoadedTemp = tilesLoadedRef.current;\n        let newTile;\n        let curLat = topLatLimit;\n        let curLon = leftLonLimit;\n        while (curLon < rightLonLimit) {\n            while (curLat > bottomLatLimit) {\n                if (reloadNum !== reloadCounter.current) {\n                    return;\n                }\n                // Check if the tile has already been loaded\n                //console.log(tileLoaded(curLat, curLon, tilesLoadedRef.current));\n                if (!tileLoaded(curLat, curLon, tilesLoadedRef.current)) {\n                    const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n                    //console.log(ways);\n                    newTile = {\"tileLat\": curLat, \"tileLon\": curLon, \"ways\": ways};\n                    // Tiles previously had a randomly-generated \"name\" property: \"name\":Math.round(Math.random()*100)\n                    // console.log(\"rendering tile for reload number \" + reloadNum);\n                    drawTile(newTile);\n\n                    // console.log(newTile);\n                    tilesLoadedRef.current.push(newTile);\n                }\n\n                curLat -= TILE_WIDTH;\n            }\n            // console.log(\"curLat: \" + curLat);\n            if (curLat < bottommostTileLat.current) {\n                bottommostTileLat.current = curLat;\n            }\n            curLat = topLatLimit;\n            curLon += TILE_WIDTH;\n        }\n        if (curLon > rightmostTileLon.current) {\n            rightmostTileLon.current = curLon;\n        }\n        // console.log(\"num tiles loaded: \" + tilesLoadedRef.current.length);\n        //tilesLoadedRef.current = tilesLoadedTemp;\n    }\n\n    /**\n     * Determines whether a tile with a given lat/lon coordinate has been cached on the client-side\n     * or note. Returns a boolean.\n     * @param lat - latitude coordinate of tile to check\n     * @param lon - longitude coordinate of tile to check\n     * @param loadedTiles - list of tiles that have been loaded already\n     * @returns {boolean} - whether or not the tile is cached already\n     */\n    function tileLoaded(lat, lon, loadedTiles) {\n        // console.log(\"checking tile \" + lat + \" \" + lon);\n        //console.log(\"num tiles checking: \" + loadedTiles.length);\n        let loaded = false;\n        let checkTile;\n        for (let i = 0; i < loadedTiles.length; i++) {\n            checkTile = loadedTiles[i];\n            loaded = loaded || (checkTile[\"tileLat\"] === lat && checkTile[\"tileLon\"] === lon);\n        }\n        return loaded;\n    }\n\n    /**\n     * Makes an axios request.\n     */\n    async function requestRoute() {\n        const toSend = {\n            srclat: startLat,\n            srclong: startLon,\n            destlat: destLat,\n            destlong: destLon\n        };\n        // console.log(toSend);\n\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n        const res = await axios.post(\n            \"http://localhost:4567/route\",\n            toSend,\n            config\n        );\n        // console.log(res[\"data\"][\"route\"]);\n        return res[\"data\"][\"route\"];\n    }\n\n    //uses post request to get ways within bounding box\n    async function requestWays(coordinates) {\n        const toSend = {\n            lat1: coordinates[0],\n            long1: coordinates[1],\n            lat2: coordinates[2],\n            long2: coordinates[3]\n        };\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n        const res = await axios.post(\n            \"http://localhost:4567/ways\",\n            toSend,\n            config\n        );\n        return res[\"data\"][\"ways\"];\n    }\n\n    /**\n     * Makes an axios request to get the coordinates of the node nearest to a clicked lat and lon.\n     */\n    function requestNearest(lat, lon, latSetter, lonSetter) {\n        const toSend = {\n            lat: lat,\n            lon: lon\n        };\n\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n\n        axios.post(\n            \"http://localhost:4567/nearest\",\n            toSend,\n            config\n        )\n            .then(response => {\n                // console.log(response.data);\n                return response.data;\n            })\n            .then((data) => {\n                const newLat = data[\"nearestLat\"];\n                const newLon = data[\"nearestLon\"];\n                return [newLat, newLon];\n            })\n            .then((newCoord) => {\n                latSetter(newCoord[0]);\n                lonSetter(newCoord[1]);\n                setRoute([]);\n                // redrawMap();\n            })\n            .catch(function (error) {\n                console.log(error);\n            });\n    }\n\n    function clearLoadTiles() {\n        const tilesLoadedTemp = tilesLoadedRef.current;\n        // First, purge old tiles\n        const mapBoundaries = getMapBoundaries();\n        //these are backwards\n        const bottomLat = mapBoundaries[2];\n        const rightLon = mapBoundaries[3];\n        let saveTiles = [];\n        // Iterate over all the loaded tiles and see if they're still useful\n        for (let i = 0; i < tilesLoadedTemp.length; i++) {\n            const checkTile = tilesLoadedTemp[i];\n            const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n            // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n            const tileTopLat = tileBoundaries[0];\n            const tileLeftLon = tileBoundaries[1];\n            const tileBottomLat = tileBoundaries[2];\n            const tileRightLon = tileBoundaries[3];\n            // We expect latitudes within the map range to be LESS than the topLat\n            // We expect longitudes within the map range to be GREATER than the leftLon\n            const deleteTile = (tileBottomLat > topLat) || (tileTopLat < bottomLat)\n                || (tileRightLon < leftLon) || (tileLeftLon > rightLon);\n            // if (tileBottomLat > topLat) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n            // }\n            // if (tileLeftLon > rightLon) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the right side\");\n            // }\n            // if (deleteTile) {\n            //     console.log(\"deleting tile\");\n            // }\n            if (!deleteTile) {\n                // console.log(\"rendering tile for reload number \" + reloadNum);\n                drawTile(tilesLoadedTemp[i]);\n                saveTiles.push(checkTile);\n            }\n        }\n        tilesLoadedRef.current = saveTiles;\n\n        // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n        // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n        while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[2] > topLat){\n            // console.log(\"adjusting loaded top boundary\");\n            topmostTileLat.current -= TILE_WIDTH;\n        }\n        while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[3] < leftLon){\n            // console.log(\"adjusting loaded left boundary\");\n            leftmostTileLon.current += TILE_WIDTH;\n        }\n        while (bottommostTileLat.current < bottomLat){\n            // console.log(\"adjusting loaded bottom boundary\");\n            bottommostTileLat.current += TILE_WIDTH;\n        }\n        while (rightmostTileLon.current > rightLon){\n            // console.log(\"adjusting loaded right boundary\");\n            rightmostTileLon.current -= TILE_WIDTH;\n        }\n\n        // Now, load new tiles\n        while (leftmostTileLon.current > leftLon) {\n            //console.log(\"gap at left\");\n            // loadTilesWithin(topmostTileLat.current, leftmostTileLon.current - TILE_WIDTH, bottommostTileLat.current, leftmostTileLon.current);\n            leftmostTileLon.current -= TILE_WIDTH;\n        }\n        while (topmostTileLat.current < topLat) {\n            //console.log(\"gap at top\");\n            // loadTilesWithin(topmostTileLat.current + TILE_WIDTH, leftmostTileLon.current, topmostTileLat.current, rightmostTileLon.current);\n            topmostTileLat.current += TILE_WIDTH;\n        }\n        while (bottommostTileLat.current >= bottomLat) {\n            //console.log(\"gap at bottom\");\n            /*loadTilesWithin(bottommostTileLat.current, leftmostTileLon.current - TILE_WIDTH,\n                bottommostTileLat.current - (2.0 * TILE_WIDTH), rightmostTileLon.current);*/\n            bottommostTileLat.current -= TILE_WIDTH;\n        }\n        while (rightmostTileLon.current <= rightLon) {\n            //console.log(\"gap at right\");\n            /*loadTilesWithin(topmostTileLat.current, rightmostTileLon.current + TILE_WIDTH,\n                bottommostTileLat.current, rightmostTileLon.current + (2.0 * TILE_WIDTH));*/\n            rightmostTileLon.current += TILE_WIDTH;\n        }\n        loadTilesWithin(topmostTileLat.current, leftmostTileLon.current,\n            bottommostTileLat.current, rightmostTileLon.current, reloadCounter.current);\n        // console.log(\"num tiles after loading: \" + tilesLoadedTemp.length);\n        //drawLoadedRect();\n    }\n\n    function redrawMap() {\n        clearCanvas();\n        clearLoadTiles();\n        drawStartEndCircles();\n        drawRoute();\n    }\n\n    /**\n     * Code to turn lat/lon coordinates into pixel coordinates for the canvas:\n     * takes in a latitude and longitude coordinate, returns a length-2 list with the\n     * corresponding pixel position on the canvas [left, top]\n     * @param lat - the latitude coordinate to turn into a pixel left coordinate\n     * @param lon - the longitude coordinate to turn into a pixel top coordinate\n     * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n     */\n    function latLonCoordToPix(lat, lon) {\n        const normalizedLat = topLat - lat;\n        const normalizedLon = lon - leftLon;\n        // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n    }\n\n    /**\n     * Converts a single latitude/longitude coordinate value into a pixel value.\n     * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n     * @returns {number} the pixel conversion of the lat/lon value\n     */\n    function pixIfy(latLonVal) {\n        const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n        return latLonVal * pixOverLatLonFactor;\n    }\n\n    /**\n     * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n     * and longitude coordinate.\n     * Returns a length-2 list with [lat, lon].\n     * @param left - the pixel left coordinate to turn into map latitude\n     * @param top - the pixel top coordinate to turn into map longitude\n     * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n     */\n    function pixCoordToLatLon(left, top) {\n        const canvas = canvasRef.current;\n        const normalizedLeft = left - canvas.offsetLeft;\n        const normalizedTop = top - canvas.offsetTop;\n        // console.log(normalizedLeft + \", \" + normalizedTop);\n        // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n        const returnLat = topLat - latLonIfy(normalizedTop);\n        const returnLon = leftLon + latLonIfy(normalizedLeft);\n        // console.log(returnLat, \", \", returnLon)\n        // console.log(latLonCoordToPix(returnLat, returnLon));\n\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [returnLat, returnLon];\n    }\n\n    /**\n     * Turns a single value in pixels into a value in latitude/longitude coordinates.\n     * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n     * @returns {number} the lat/lon conversion of the pixel value\n     */\n    function latLonIfy(pixVal) {\n        const latLonOverPixFactor =  latLonRange / CANVAS_SIDE_LENGTH;\n        return pixVal * latLonOverPixFactor;\n    }\n\n    /**\n     * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n     * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of the current map frame.\n     */\n    function getMapBoundaries() {\n        return getBoundingBox(topLat, leftLon, latLonRange);\n    }\n\n    /**\n     * Get the lat/lon boundaries of a passed square area with unknown side length.\n     * @param boxtopLat latitude coordinate of the northwest corner\n     * @param boxleftLon longitude coordinate of the northwest corner\n     * @param boxRange side length, in terms of lat/lon coordinates\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of a passed square.\n     */\n    function getBoundingBox(boxtopLat, boxleftLon, boxRange) {\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [boxtopLat, boxleftLon, boxtopLat - boxRange, boxleftLon + boxRange];\n    }\n\n    function handleClickOrDrag(mouseUpX, mouseUpY) {\n        const xChange = mouseUpX - mouseDownX; // positive if the map is dragged to the right\n        const yChange = mouseUpY - mouseDownY; // positive if the map is dragged downwards\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n\n        if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n            // This was a click!\n            const ctx = ctxRef.current;\n            ctx.fillStyle = \"green\";\n            // console.log(pixCoordToLatLon(mouseUpX, mouseUpY));\n            const latLonCoord = pixCoordToLatLon(mouseUpX, mouseUpY);\n            //if (startLat === 0 || startLat.toString() === \"\")\n            if (startLat === \"\") {\n                requestNearest(latLonCoord[0], latLonCoord[1], setStartLat, setStartLon);\n            } else {\n                requestNearest(latLonCoord[0], latLonCoord[1], setDestLat, setDestLon);\n            }\n        } else {\n            reloadCounter.current += 1;\n            // console.log(\"reload number \" + reloadCounter.current);\n            // This was a drag!\n            // REMEMBER: lat is y-value, lon is x-value!\n            //console.log(xChange, yChange);\n            //console.log(latLonIfy(xChange), latLonIfy(yChange));\n            //console.log(topLat + \", \" + leftLon);\n            //setLeftLon(leftLon - latLonIfy(xChange));\n            const newLeftLon = leftLon - latLonIfy(xChange);\n            /*\n             * positive values, dragging the map to the right\n             * moves the previous leftLon rightwards\n             * meaning that the new leftLon should be less than the previous leftLon\n             */\n            //setTopLat(topLat + latLonIfy(yChange));\n            const newTopLat = topLat + latLonIfy(yChange);\n            /*\n             * positive values, dragging the map downwards\n             * moves the previous topLat downwards\n             * meaning that the new topLat should be greater than the previous topLat\n             */\n            //console.log(topLat + \", \" + leftLon);\n            // redrawMap();\n            const newMapWindow = [newTopLat, newLeftLon, mapWindow[2]];\n            setMapWindow(newMapWindow);\n        }\n    }\n\n    function handleZoomInOut(zoomedOut, mouseX, mouseY, numScrolls) {\n        reloadCounter.current += 1;\n        // console.log(\"reload number \" + reloadCounter.current);\n        const mouseLatLonCoord = pixCoordToLatLon(mouseX, mouseY);\n        const zoomLatNormalized = topLat - mouseLatLonCoord[0];\n        const zoomLonNormalized = mouseLatLonCoord[1] - leftLon;\n        const latFraction = (zoomLatNormalized / latLonRange);\n        const lonFraction = (zoomLonNormalized / latLonRange);\n\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n        if (zoomedOut) {\n            const stepSize = (latLonRange * Math.pow(1.05, numScrolls)) - latLonRange;\n            //setLatLonRange(latLonRange + stepSize);\n            const newLatLonRange = latLonRange + stepSize;\n            // We're zooming out, so the topLat should move upwards\n            //setTopLat(topLat + (latFraction * stepSize));\n            const newTopLat = topLat + (latFraction * stepSize);\n            // and leftLon should move leftwards\n            //setLeftLon(leftLon - (lonFraction * stepSize));\n            const newLeftLon = leftLon - (lonFraction * stepSize);\n            const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n            setMapWindow(newMapWindow);\n        } else {\n            const stepSize = latLonRange - (latLonRange * Math.pow(0.95, numScrolls));\n            //setLatLonRange(latLonRange - stepSize);\n            const newLatLonRange = latLonRange - stepSize;\n            // We're zooming in, so the topLat should move downwards\n            //setTopLat(topLat - (latFraction * stepSize));\n            const newTopLat = topLat - (latFraction * stepSize);\n            // and leftLon should move inwards\n            //setLeftLon(leftLon + (lonFraction * stepSize));\n            const newLeftLon = leftLon + (lonFraction * stepSize);\n            const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n            setMapWindow(newMapWindow);\n        }\n        // redrawMap();\n    }\n\n    function clearCanvas() {\n        const ctx = ctxRef.current;\n        const canvas = canvasRef.current;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    function drawTile(tileToDraw) {\n        // const mapBoundaries = getMapBoundaries();\n        // // We expect latitudes within the map range to be LESS than the topLat\n        // // We expect longitudes within the map range to be GREATER than the leftLon\n        // const withinMapBoundaries = (tileToDraw[\"tileLat\"] < mapBoundaries[0])\n        //     && (tileToDraw[\"tileLat\"] > mapBoundaries[2])\n        //     && (tileToDraw[\"tileLon\"] > mapBoundaries[1])\n        //     && (tileToDraw[\"tileLon\"] < mapBoundaries[3]);\n        // if (!withinMapBoundaries) {\n        //     console.log(tileToDraw);\n        // }\n        tileToDraw[\"ways\"].forEach(traceWay);\n    }\n\n    function drawCircle(lat, lon, radius) {\n        const ctx = ctxRef.current;\n        const pixCoord = latLonCoordToPix(lat, lon);\n        ctx.strokeStyle = \"red\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.arc(pixCoord[0], pixCoord[1], radius, 0, 2 * Math.PI);\n        ctx.stroke();\n    }\n\n    function drawStartEndCircles() {\n        // And add the circles for the selected start/destination!\n        const radius = pixIfy(latLonRange / 100);\n        //console.log(\"startLat and startLon:\");\n        //console.log(startLat + \" \" + startLon);\n        if (!(parseFloat(startLon) === 0 || startLon.toString() === \"\"\n            || parseFloat(startLat) === 0 || startLat.toString() === \"\")){\n            // drawing start circle\n            drawCircle(startLat, startLon, radius);\n        }\n        if (!(parseFloat(destLon) === 0 || destLon.toString() === \"\"\n            || parseFloat(destLat) === 0 || destLat.toString() === \"\")){\n            // drawing destination circle\n            drawCircle(destLat, destLon, radius);\n        }\n    }\n\n    // function drawLoadedRect(){\n    //     const ctx = ctxRef.current;\n    //     const loadedPixBoxTopLeft = latLonCoordToPix(topmostTileLat.current, leftmostTileLon.current);\n    //     const loadedPixBoxBottomRight = latLonCoordToPix(bottommostTileLat.current, rightmostTileLon.current);\n    //     const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n    //     const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n    //     ctx.strokeStyle = \"red\";\n    //     ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n    // }\n    //\n    // function drawSquare(tileToDraw) {\n    //     const ctx = ctxRef.current;\n    //     ctx.fillStyle = \"lightgreen\";\n    //     const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n    //     const baseX = tileCoord[0];\n    //     const baseY = tileCoord[1];\n    //\n    //     const pixTileWidth = pixIfy(TILE_WIDTH);\n    //     // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n    //     //      Math.min(baseX + pixTileWidth, pixTileWidth),\n    //     //      Math.min(baseY + pixTileWidth, pixTileWidth));\n    //     ctx.strokeStyle = \"black\";\n    //     ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n    //         Math.min(baseX + pixTileWidth, pixTileWidth),\n    //         Math.min(baseY + pixTileWidth, pixTileWidth));\n    //     ctx.fillStyle = \"black\";\n    //     ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n    // }\n\n    //M TODO traceRoute and traceWay can be combined, but for now I am leaving as is because it works\n    // and I want to let you get started\n    // Maxime reply: yep! That makes sense, thank you!\n    function traceRoute(way) {\n        const ctx = ctxRef.current;\n        let startLatCoord = way[\"startLat\"]\n        let startLonCoord = way[\"startLong\"]\n        let pixStart = latLonCoordToPix(startLatCoord, startLonCoord)\n        ctx.fillStyle = \"blue\";\n        ctx.strokeStyle = \"blue\";\n        ctx.lineWidth = 4;\n        ctx.beginPath();\n        ctx.moveTo(pixStart[0], pixStart[1])\n        let endLatCoord = way[\"destLat\"]\n        //console.log(endLatCoord)\n        let endLongCoord = way[\"destLong\"]\n        //console.log(endLongCoord)\n        let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord)\n        //console.log(pixEnd)\n        ctx.lineTo(pixEnd[0], pixEnd[1])\n        ctx.stroke();\n    }\n\n    //M TODO i haven't done the optimization to minimize calls to stroke yet, this is something we can let the TA know\n    // or I can try to do tomorrow morning\n    // Maxime reply: don't worry about it too much! The map already renders really quickly, as is!\n    function traceWay(way) {\n        //console.log(way)\n        //probably should change wayslist into a hashmap\n        const ctx = ctxRef.current;\n        let startLatCoord = Number(way[\"startLat\"])\n        let startLonCoord = Number(way[\"startLong\"])\n        let pixStart = latLonCoordToPix(startLatCoord, startLonCoord)\n        switch (way[\"type\"]) {\n            case 'residential':\n                ctx.fillStyle = \"green\";\n                ctx.strokeStyle = \"green\";\n                ctx.lineWidth = 2;\n                break;\n            case 'service':\n                ctx.fillStyle = \"Coral\";\n                ctx.strokeStyle = \"Coral\";\n                ctx.lineWidth = 1;\n                break;\n            case 'secondary':\n                ctx.fillStyle = \"CornflowerBlue\";\n                ctx.strokeStyle = \"CornflowerBlue\";\n                ctx.lineWidth = 1;\n                break;\n            case 'track':\n                ctx.fillStyle = \"Chocolate\";\n                ctx.strokeStyle = \"Chocolate\";\n                ctx.lineWidth = 1;\n                break;\n            case 'tertiary':\n                ctx.fillStyle = \"DarkBlue\";\n                ctx.strokeStyle = \"DarkBlue\";\n                ctx.lineWidth = 1;\n                break;\n            case 'trunk':\n                ctx.fillStyle = \"DarkOrchid\";\n                ctx.strokeStyle = \"DarkOrchid\";\n                ctx.lineWidth = 1;\n                break;\n            case 'primary':\n                ctx.fillStyle = \"DarkViolet\";\n                ctx.strokeStyle = \"DarkViolet\";\n                ctx.lineWidth = 1;\n                break;\n            case 'service':\n                ctx.fillStyle = \"CornflowerBlue\";\n                ctx.strokeStyle = \"CornflowerBlue\";\n                ctx.lineWidth = 1;\n                break;\n        }\n        ctx.fillStyle = \"olivedrab\";\n        ctx.strokeStyle = \"olivedrab\";\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(pixStart[0], pixStart[1])\n        let endLatCoord = Number(way[\"destLat\"])\n        let endLongCoord = Number(way[\"destLong\"])\n        let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord)\n        ctx.lineTo(pixEnd[0], pixEnd[1])\n        ctx.stroke();\n    }\n\n    //traces route from 2 selected points in blue\n    //M this disappears if you scroll or pan i think, im not sure how to fix it i will leave it for now\n    // and we can come back to this\n    // Maxime reply: I think I went ahead and fixed this!\n    // It was because of the redrawMap() method, which gets called anytime we scroll or pan,\n    // and ever time it gets called, it calls the clearCanvas() method to wipe the canvas\n    // (including the route we just drew), then it redraws all of the ways.\n    //TODO we could probably lump all this functionality directly into the requestRoute() method\n    // Since all we really need is to use the setRoute() method to store the route data\n    async function getRoute() {\n        // console.log(\"should draw the route\");\n        const routeTemp = await requestRoute();\n        // console.log(routeTemp);\n        setRoute(routeTemp);\n        // drawRoute()\n\n        // Now we'll auto-zoom to a proper display size!\n        // We expect latitudes within the map range to be LESS than the topLat\n        // We expect longitudes within the map range to be GREATER than the leftLon\n        const latRange = Math.abs(startLat - destLat);\n        const lonRange = Math.abs(startLon - destLon);\n        const routeTopLat = Math.max(startLat, destLat);\n        const routeLeftLon = Math.min(startLon, destLon);\n        const maxRange = Math.max(latRange, lonRange);\n        const centerLatPadding = (maxRange - latRange) / 2.0;\n        const centerLonPadding = (maxRange - lonRange) / 2.0;\n        const overallPadding = 0.1 * maxRange; // We'll add a border of 10% of the longest dimension of the path\n        const newTopLat = routeTopLat + centerLatPadding + overallPadding;\n        const newLeftLon = routeLeftLon - centerLonPadding - overallPadding;\n        const newLatLonRange = maxRange + (2 * overallPadding);\n        const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n        setMapWindow(newMapWindow);\n    }\n\n    function drawRoute() {\n        for (const way of route) {\n            traceRoute(way)\n        }\n    }\n\n    function clearMap() {\n        // clear out the clicked/entered-in points\n        setStartLat(\"\");\n        setStartLon(\"\");\n        setDestLat(\"\");\n        setDestLon(\"\");\n\n        // also clear out any loaded route\n        setRoute([]);\n\n        // rerender the map\n        // redrawMap();\n    }\n\n    let scrollCounter = 0;\n    let scrollFinish;\n\n    return (\n        <div>\n            <h1>Maps GUI</h1>\n            <TextBox label={\"Source Latitude\"} boxVal={startLat} change={setStartLat}/>\n            <TextBox label={\"Source Longitude\"} boxVal={startLon} change={setStartLon}/>\n            <TextBox label={\"Destination Latitude\"} boxVal={destLat} change={setDestLat}/>\n            <TextBox label={\"Destination Longitude\"} boxVal={destLon} change={setDestLon}/>\n            <button onClick={getRoute}>Map Route</button>\n            <button onClick={clearMap}>Clear Map</button>\n            <br/>\n            {/*{route.map((coord, index) =>*/}\n            {/*    <p key={index}>{coord[0]}, {coord[1]}</p>*/}\n            {/*)}*/}\n            <canvas ref={canvasRef} onMouseDown={(event) => {\n                mouseDownX = event.pageX;\n                mouseDownY = event.pageY;\n            }} onMouseUp={(event) => {\n                //pixCoordToLatLon(event.pageX, event.pageY);\n                handleClickOrDrag(event.pageX, event.pageY);\n            }} onWheel={(event) => {\n                event.stopPropagation();\n                // scrollCounter++;\n                // // Scrolling!\n                // clearTimeout(scrollFinish)\n                // scrollFinish = setTimeout(() => {\n                //     // Not scrolling anymore\n                //     if (event.deltaY < 0) {\n                //         // Scrolling up\n                //         handleZoomInOut(false, event.pageX, event.pageY, scrollCounter);\n                //     } else {\n                //         // Scrolling down\n                //         handleZoomInOut(true, event.pageX, event.pageY, scrollCounter);\n                //     }\n                // }, SCROLL_WAIT);\n                // Scrolling!\n                if (event.deltaY < 0) {\n                    // Scrolling up\n                    handleZoomInOut(false, event.pageX, event.pageY, 1);\n                } else {\n                    // Scrolling down\n                    handleZoomInOut(true, event.pageX, event.pageY, 1);\n                }\n            }}/>\n        </div>\n    );\n}\n\nexport default Route;"]},"metadata":{},"sourceType":"module"}