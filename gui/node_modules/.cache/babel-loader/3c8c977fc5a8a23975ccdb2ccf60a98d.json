{"ast":null,"code":"var _jsxFileName = \"/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js\",\n    _s = $RefreshSig$();\n\nimport './App.css';\nimport TextBox from \"./TextBox\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport axios from 'axios';\nimport { AwesomeButton } from \"react-awesome-button\";\nimport \"react-awesome-button/dist/styles.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Route() {\n  _s();\n\n  const [startLat, setStartLat] = useState(0);\n  const [startLon, setStartLon] = useState(0);\n  const [destLat, setDestLat] = useState(0);\n  const [destLon, setDestLon] = useState(0);\n  const [route, setRoute] = useState([]); //const [ways, setWays] = useState([]);\n\n  const CANVAS_SIDE_LENGTH = 450;\n  const SCROLL_WAIT = 40;\n  const CLICK_RANGE = 5; //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n  // are implemented\n  //M changed the names here to be topLat and leftLon\n\n  let topLat = 41.832038;\n  let leftLon = -71.406957;\n  let latLonRange = 0.011275;\n  let mouseDownX;\n  let mouseDownY; // So in order to render the starting map, it'll have to render 64 tiles, I think\n  // On Brown campus, that gives approximately 4,500 ways in just one tile...\n  // We expect latitudes within the map range to be LESS than the leftLat\n  // We expect longitudes within the map range to be GREATER than the topLon\n  // In order to get rightLat or bottomLon, just subtract latLonRange from leftLat, or add it to topLon\n  // But for testing purposes, unless the above values are changed:\n  // rightLat = 41.801763\n  // bottomLon = -71.380682\n\n  const TILE_WIDTH = 0.003909375; // one eighth of starting latLonRange\n  //M changed these name descriptors\n\n  let topmostTileLat = topLat;\n  let leftMostTileLon = leftLon;\n  let bottommostTileLat = topmostTileLat;\n  let rightMostTileLon = leftMostTileLon;\n  let tilesLoaded = []; // Tiles should be JavaScript objects with properties leftLat, topLon, and an [] of ways\n  // Ways should be length-4 list of Doubles? [lat1, lon1, lat2, lon2]?\n\n  const canvasRef = useRef();\n  let ctxRef = useRef();\n  /**\n   * Makes an axios request.\n   */\n\n  const requestRoute = () => {\n    const toSend = {\n      srclat: startLat,\n      srclong: startLon,\n      destlat: destLat,\n      destlong: destLon\n    }; //console.log(toSend);\n\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    }; //Install and import this!\n\n    axios.post(\"http://localhost:4567/route\", toSend, config).then(response => {\n      console.log(response.data); // TODO: make sure that the \"route\" here corresponds to the correct data we want back\n\n      setRoute(response.data[\"route\"]);\n    }).catch(function (error) {\n      console.log(error);\n    });\n  };\n  /**\n   * Code to run when the page loads\n   */\n\n\n  useEffect(() => {\n    //console.log(\"page loaded!\");\n    const canvas = canvasRef.current;\n    canvas.width = CANVAS_SIDE_LENGTH;\n    canvas.height = CANVAS_SIDE_LENGTH;\n    ctxRef.current = canvas.getContext(\"2d\"); // let ctx = ctxRef.current;\n    // ctx.fillStyle = \"green\";\n    // ctx.fillRect(0, 0, 100, 100);\n    // Load tiles\n\n    loadStartingTiles();\n  }, []);\n\n  function loadStartingTiles() {\n    console.log(\"Loading starting tiles\");\n    const boundaries = getMapBoundaries();\n    loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n  }\n\n  async function loadTilesWithin(bottomLatLimit, leftLonLimit, topLatLimit, rightLonLimit) {\n    console.log(\"bottomLatLimit\");\n    console.log(bottomLatLimit);\n    console.log(\"left\");\n    console.log(leftLonLimit);\n    console.log(\"top\");\n    console.log(topLatLimit);\n    console.log(\"right\");\n    console.log(rightLonLimit);\n\n    if (topLatLimit > topmostTileLat) {\n      topmostTileLat = topLatLimit;\n    }\n\n    if (leftLonLimit < leftMostTileLon) {\n      leftMostTileLon = leftLonLimit;\n    }\n\n    let newTile;\n    let curLat = topLatLimit;\n    let curLon = leftLonLimit;\n\n    while (curLon < rightLonLimit) {\n      while (curLat > bottomLatLimit) {\n        const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n        newTile = {\n          \"tileLat\": curLat,\n          \"tileLon\": curLon,\n          \"ways\": ways,\n          \"name\": Math.round(Math.random() * 100)\n        };\n        drawTile(newTile);\n        tilesLoaded.push(newTile);\n        curLat -= TILE_WIDTH;\n        console.log(\"curlat\");\n        console.log(curLat);\n      }\n\n      if (curLat > bottommostTileLat) {\n        bottommostTileLat = curLat;\n      } //curLat = topLatLimit;\n\n\n      curLon += TILE_WIDTH;\n      console.log(\"curlon\");\n      console.log(curLon);\n    }\n\n    if (curLon > rightMostTileLon) {\n      rightMostTileLon = curLon;\n    }\n  } //uses post request to get ways within bounding box\n\n\n  async function requestWays(coordinates) {\n    const toSend = {\n      lat1: coordinates[0],\n      long1: coordinates[1],\n      lat2: coordinates[2],\n      long2: coordinates[3]\n    };\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    const res = await axios.post(\"http://localhost:4567/ways\", toSend, config);\n    return res[\"data\"][\"ways\"];\n  }\n\n  function clearLoadTiles() {\n    clearCanvas(); // First, purge old tiles\n\n    const mapBoundaries = getMapBoundaries(); //these are backwards\n    //M flipped these\n\n    const bottomLat = mapBoundaries[3];\n    const rightLon = mapBoundaries[2];\n    let saveTiles = []; // Iterate over all the loaded tiles and see if they're still useful\n\n    for (let i = 0; i < tilesLoaded.length; i++) {\n      const checkTile = tilesLoaded[i];\n      const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n      const tileTopLat = tileBoundaries[0];\n      const tileLeftLon = tileBoundaries[1];\n      const tileBottomLat = tileBoundaries[2];\n      const tileRightLon = tileBoundaries[3]; // We expect latitudes within the map range to be LESS than the leftLat\n      // We expect longitudes within the map range to be GREATER than the topLon\n\n      const deleteTile = tileRightLon > leftLon || tileLeftLon < rightLon || tileBottomLat < topLat || tileTopLat > bottomLat; // const keepTileLeftRight = (tileRightLat < leftLat) || (tileLeftLat > rightLat);\n      // if (tileRightLat > leftLat) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the left side\");\n      // }\n      // const keepTileUpDown = (tileBottomLon > topLon) || (tileTopLon < bottomLon);\n      // if (tileTopLon > bottomLon) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n      // }\n      // let keepTile = keepTileLeftRight && keepTileUpDown;\n\n      if (!deleteTile) {\n        drawTile(tilesLoaded[i]);\n        saveTiles.push(checkTile);\n      }\n    }\n\n    tilesLoaded = saveTiles; // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n    //M switched from leftLat to topLon\n\n    while (getBoundingBox(topmostTileLat, leftMostTileLon, TILE_WIDTH)[2] > topLat) {\n      console.log(\"adjusting loaded left boundary\");\n      leftMostTileLon -= TILE_WIDTH;\n    } //M see above\n\n\n    while (getBoundingBox(topmostTileLat, leftMostTileLon, TILE_WIDTH)[3] < leftLon) {\n      console.log(\"adjusting loaded top boundary\");\n      topmostTileLat += TILE_WIDTH;\n    } //M switched rightLat and bottomLon\n\n\n    while (rightMostTileLon < rightLon) {\n      console.log(\"adjusting loaded right boundary\");\n      rightMostTileLon += TILE_WIDTH;\n    }\n\n    while (bottommostTileLat > bottomLat) {\n      console.log(\"adjusting loaded bottom boundary\");\n      bottommostTileLat -= TILE_WIDTH;\n    } // Now, load new tiles\n\n\n    while (leftMostTileLon < leftLon) {\n      console.log(\"gap at left\"); //MAXIME swapped fields here(highesttilelon with leftmost + widht and lowestTile and leftmost\n\n      loadTilesWithin(bottommostTileLat, leftMostTileLon + TILE_WIDTH, topmostTileLat, rightMostTileLon); //leftmostTileLat += TILE_WIDTH;\n    }\n\n    while (rightMostTileLon > rightLon) {\n      console.log(\"gap at right\");\n      loadTilesWithin(bottommostTileLat, leftMostTileLon, topmostTileLat, rightMostTileLon - TILE_WIDTH);\n    }\n\n    while (topmostTileLat > topLat) {\n      console.log(\"gap at top\");\n      loadTilesWithin(bottommostTileLat, leftMostTileLon, topmostTileLat + TILE_WIDTH, rightMostTileLon - TILE_WIDTH);\n    }\n\n    while (bottommostTileLat < bottomLat) {\n      console.log(\"gap at bottom\");\n      loadTilesWithin(bottommostTileLat + TILE_WIDTH, leftMostTileLon, topmostTileLat, rightMostTileLon);\n    } //console.log(tilesLoaded.length);\n    //drawLoadedRect();\n\n  }\n  /*function drawLoadedRect(){\n      const ctx = ctxRef.current;\n      const loadedPixBoxTopLeft = latLonCoordToPix(leftmostTileLat, highestTileLon);\n      const loadedPixBoxBottomRight = latLonCoordToPix(rightmostTileLat, lowestTileLon);\n      const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n      const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n      ctx.strokeStyle = \"red\";\n      ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n  }\n    */\n\n  /**\n   * Code to turn lon/lat coordinates into pixel coordinates for the canvas:\n   * takes in a latitude and longitude coordinate, returns a length-2 list with the\n   * corresponding pixel position on the canvas [left, top]\n   * @param lat - the latitude coordinate to turn into a pixel left coordinate\n   * @param lon - the longitude coordinate to turn into a pixel top coordinate\n   * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n   */\n\n\n  function latLonCoordToPix(lat, lon) {\n    const normalizedLat = topLat - lat;\n    const normalizedLon = lon - leftLon; // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n    // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n  }\n  /**\n   * Turns a latitude/longitude coordinate value into a pixel value.\n   * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n   * @returns {number} the pixel conversion of the lat/lon value\n   */\n\n\n  function pixIfy(latLonVal) {\n    const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n    return latLonVal * pixOverLatLonFactor;\n  }\n  /**\n   * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n   * and longitude coordinate\n   * Returns a length-2 list with [lat, lon]\n   * @param left - the pixel left coordinate to turn into map latitude\n   * @param top - the pixel top coordinate to turn into map longitude\n   * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n   */\n\n\n  function pixCoordToLatLon(left, top) {\n    const canvas = canvasRef.current;\n    const normalizedLeft = left - canvas.offsetLeft;\n    const normalizedTop = top - canvas.offsetTop; // console.log(normalizedLeft + \", \" + normalizedTop);\n    // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n    const returnLat = leftLat - latLonIfy(normalizedLeft);\n    const returnLon = topLon + latLonIfy(normalizedTop); // console.log(returnLat, \", \", returnLon)\n    // console.log(latLonCoordToPix(returnLat, returnLon));\n\n    return [returnLon, returnLat];\n  }\n  /**\n   * Turns a value in pixels into a value in latitude/longitude coordinates.\n   * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n   * @returns {number} the lat/lon conversion of the pixel value\n   */\n\n\n  function latLonIfy(pixVal) {\n    const latLonOverPixFactor = latLonRange / CANVAS_SIDE_LENGTH;\n    return pixVal * latLonOverPixFactor;\n  }\n  /**\n   * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n   * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of the current map frame.\n   */\n\n\n  function getMapBoundaries() {\n    return getBoundingBox(topLat, leftLon, latLonRange);\n  }\n\n  function getBoundingBox(boxTopLat, boxLeftLon, boxRange) {\n    return [boxTopLat, boxLeftLon, boxTopLat - boxRange, boxLeftLon + boxRange];\n  } // console.log(latLonCoordToPix(41.801763, -71.380682));\n\n\n  function handleClickOrDrag(mouseUpX, mouseUpY) {\n    const xChange = mouseUpX - mouseDownX;\n    const yChange = mouseDownY - mouseUpY; // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n      console.log(\"Clicked!\");\n      const ctx = ctxRef.current;\n      ctx.fillStyle = \"green\"; //TODO: insert the nearest call here\n    } else {\n      console.log(\"Dragged!\"); // console.log(xChange, yChange);\n      //console.log(latLonIfy(xChange), latLonIfy(yChange));\n      //console.log(leftLat + \", \" + topLon);\n      // TODO: this may want to get changed to a setParamName() function call when setState is used\n      //MAXIME swapped these\n\n      topLat += latLonIfy(yChange);\n      leftLon += latLonIfy(xChange); //console.log(leftLat + \", \" + topLon);\n\n      clearLoadTiles();\n    }\n  }\n\n  function clearCanvas() {\n    const ctx = ctxRef.current;\n    const canvas = canvasRef.current;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  function drawTile(tileToDraw) {\n    //console.log(\"drawing tile\");\n    // console.log(tileToDraw);\n    // const ctx = ctxRef.current;\n    // ctx.fillStyle = \"lightgreen\";\n    // const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n    // const baseX = tileCoord[0];\n    // const baseY = tileCoord[1];\n    //\n    // const pixTileWidth = pixIfy(TILE_WIDTH);\n    // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n    //      Math.min(baseX + pixTileWidth, pixTileWidth),\n    //      Math.min(baseY + pixTileWidth, pixTileWidth));\n    //  ctx.strokeStyle = \"black\";\n    //  ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n    //      Math.min(baseX + pixTileWidth, pixTileWidth),\n    //      Math.min(baseY + pixTileWidth, pixTileWidth));\n    //  ctx.fillStyle = \"black\";\n    // ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n    //console.log(tileToDraw);\n    //console.log(tileToDraw[\"ways\"]);\n    tileToDraw[\"ways\"].forEach(traceWay);\n  } // function drawWays(tileToDraw) {\n  //     const canvas = $('#canvas')[0]; // Getting a reference to the <canvas> element that has an ID of 'canvas'\n  //     canvas.width = TILE_WIDTH;\n  //     canvas.height = TILE_WIDTH;\n  //     tileToDraw.ways.forEach(traceWay)\n  // }\n\n\n  function traceWay(way) {\n    //console.log(way)\n    //probably should change wayslist into a hashmap\n    const ctx = ctxRef.current;\n    const canvas = canvasRef.current; //let c = document.getElementById(\"myCanvas\");\n    //let ctx = c.getContext(\"2d\");\n\n    let startLatCoord = way[\"startLat\"];\n    let startLonCoord = way[\"startLong\"];\n    let pixStart = latLonCoordToPix(startLatCoord, startLonCoord); //console.log(pixStart)\n\n    ctx.fillStyle = \"black\";\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(pixStart[0], pixStart[1]);\n    let endLatCoord = way[\"destLat\"]; //console.log(endLatCoord)\n\n    let endLongCoord = way[\"destLong\"]; //console.log(endLongCoord)\n\n    let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord); //console.log(pixEnd)\n\n    ctx.lineTo(pixEnd[0], pixEnd[1]);\n    ctx.stroke();\n  }\n\n  let scrollFinish;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Test title\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 433,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Latitude\",\n      change: setStartLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 434,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Longitude\",\n      change: setStartLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 435,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Latitude\",\n      change: setDestLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 436,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Longitude\",\n      change: setDestLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 437,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(AwesomeButton, {\n      type: \"primary\",\n      onPress: requestRoute,\n      children: \"Submit!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 438,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 439,\n      columnNumber: 13\n    }, this), route.map((coord, index) => /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [coord[0], \", \", coord[1]]\n    }, index, true, {\n      fileName: _jsxFileName,\n      lineNumber: 441,\n      columnNumber: 17\n    }, this)), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      onMouseDown: event => {\n        mouseDownX = event.pageX;\n        mouseDownY = event.pageY;\n      },\n      onMouseUp: event => {\n        //pixCoordToLatLon(event.pageX, event.pageY);\n        handleClickOrDrag(event.pageX, event.pageY);\n      },\n      onWheel: event => {\n        event.stopPropagation(); // console.log(\"scrolling\");\n\n        clearTimeout(scrollFinish);\n        scrollFinish = setTimeout(() => {\n          // console.log(\"Not scrolling anymore\");\n          if (event.deltaY < 0) {\n            console.log(\"Scrolled up\");\n          } else {\n            console.log(\"Scrolled down\");\n          }\n        }, SCROLL_WAIT);\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 443,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 432,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Route, \"oMsN6JFjd0Rg09WLtcTIh6Wt6/w=\");\n\n_c = Route;\nexport default Route;\n\nvar _c;\n\n$RefreshReg$(_c, \"Route\");","map":{"version":3,"sources":["/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js"],"names":["TextBox","React","useState","useEffect","useRef","axios","AwesomeButton","Route","startLat","setStartLat","startLon","setStartLon","destLat","setDestLat","destLon","setDestLon","route","setRoute","CANVAS_SIDE_LENGTH","SCROLL_WAIT","CLICK_RANGE","topLat","leftLon","latLonRange","mouseDownX","mouseDownY","TILE_WIDTH","topmostTileLat","leftMostTileLon","bottommostTileLat","rightMostTileLon","tilesLoaded","canvasRef","ctxRef","requestRoute","toSend","srclat","srclong","destlat","destlong","config","headers","post","then","response","console","log","data","catch","error","canvas","current","width","height","getContext","loadStartingTiles","boundaries","getMapBoundaries","loadTilesWithin","bottomLatLimit","leftLonLimit","topLatLimit","rightLonLimit","newTile","curLat","curLon","ways","requestWays","getBoundingBox","Math","round","random","drawTile","push","coordinates","lat1","long1","lat2","long2","res","clearLoadTiles","clearCanvas","mapBoundaries","bottomLat","rightLon","saveTiles","i","length","checkTile","tileBoundaries","tileTopLat","tileLeftLon","tileBottomLat","tileRightLon","deleteTile","latLonCoordToPix","lat","lon","normalizedLat","normalizedLon","pixIfy","latLonVal","pixOverLatLonFactor","pixCoordToLatLon","left","top","normalizedLeft","offsetLeft","normalizedTop","offsetTop","returnLat","leftLat","latLonIfy","returnLon","topLon","pixVal","latLonOverPixFactor","boxTopLat","boxLeftLon","boxRange","handleClickOrDrag","mouseUpX","mouseUpY","xChange","yChange","abs","ctx","fillStyle","clearRect","tileToDraw","forEach","traceWay","way","startLatCoord","startLonCoord","pixStart","lineWidth","beginPath","moveTo","endLatCoord","endLongCoord","pixEnd","lineTo","stroke","scrollFinish","map","coord","index","event","pageX","pageY","stopPropagation","clearTimeout","setTimeout","deltaY"],"mappings":"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","sourcesContent":["import './App.css';\nimport TextBox from \"./TextBox\";\nimport React, {useState, useEffect, useRef} from 'react';\nimport axios from 'axios';\nimport { AwesomeButton } from \"react-awesome-button\";\nimport \"react-awesome-button/dist/styles.css\";\n\nfunction Route() {\n    const [startLat, setStartLat] = useState(0);\n    const [startLon, setStartLon] = useState(0);\n    const [destLat, setDestLat] = useState(0);\n    const [destLon, setDestLon] = useState(0);\n    const [route, setRoute] = useState([]);\n    //const [ways, setWays] = useState([]);\n    const CANVAS_SIDE_LENGTH = 450;\n    const SCROLL_WAIT = 40;\n    const CLICK_RANGE = 5;\n    //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n    // are implemented\n    //M changed the names here to be topLat and leftLon\n    let topLat = 41.832038;\n    let leftLon = -71.406957;\n    let latLonRange = 0.011275;\n    let mouseDownX;\n    let mouseDownY;\n    // So in order to render the starting map, it'll have to render 64 tiles, I think\n    // On Brown campus, that gives approximately 4,500 ways in just one tile...\n\n    // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    // In order to get rightLat or bottomLon, just subtract latLonRange from leftLat, or add it to topLon\n    // But for testing purposes, unless the above values are changed:\n    // rightLat = 41.801763\n    // bottomLon = -71.380682\n\n    const TILE_WIDTH = 0.003909375; // one eighth of starting latLonRange\n    //M changed these name descriptors\n    let topmostTileLat = topLat;\n    let leftMostTileLon = leftLon;\n    let bottommostTileLat = topmostTileLat;\n    let rightMostTileLon = leftMostTileLon;\n    let tilesLoaded = [];\n    // Tiles should be JavaScript objects with properties leftLat, topLon, and an [] of ways\n    // Ways should be length-4 list of Doubles? [lat1, lon1, lat2, lon2]?\n\n\n    const canvasRef = useRef();\n    let ctxRef = useRef();\n\n    /**\n     * Makes an axios request.\n     */\n    const requestRoute = () => {\n        const toSend = {\n            srclat: startLat,\n            srclong: startLon,\n            destlat: destLat,\n            destlong: destLon\n        };\n        //console.log(toSend);\n\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n\n        //Install and import this!\n        axios.post(\n            \"http://localhost:4567/route\",\n            toSend,\n            config\n        )\n            .then(response => {\n                console.log(response.data);\n                // TODO: make sure that the \"route\" here corresponds to the correct data we want back\n                setRoute(response.data[\"route\"]);\n            })\n            .catch(function (error) {\n                console.log(error);\n            });\n    }\n\n    /**\n     * Code to run when the page loads\n     */\n    useEffect(() => {\n        //console.log(\"page loaded!\");\n        const canvas = canvasRef.current;\n        canvas.width = CANVAS_SIDE_LENGTH;\n        canvas.height = CANVAS_SIDE_LENGTH;\n        ctxRef.current = canvas.getContext(\"2d\");\n        // let ctx = ctxRef.current;\n        // ctx.fillStyle = \"green\";\n        // ctx.fillRect(0, 0, 100, 100);\n\n        // Load tiles\n        loadStartingTiles();\n    }, []);\n\n    function loadStartingTiles() {\n        console.log(\"Loading starting tiles\");\n        const boundaries = getMapBoundaries();\n        loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n    }\n\n    async function loadTilesWithin(bottomLatLimit, leftLonLimit, topLatLimit, rightLonLimit) {\n        console.log(\"bottomLatLimit\")\n        console.log(bottomLatLimit)\n        console.log(\"left\")\n        console.log(leftLonLimit)\n        console.log(\"top\")\n        console.log(topLatLimit)\n        console.log(\"right\")\n        console.log(rightLonLimit)\n        if (topLatLimit > topmostTileLat){\n            topmostTileLat = topLatLimit;\n        }\n        if (leftLonLimit < leftMostTileLon) {\n            leftMostTileLon = leftLonLimit;\n        }\n        let newTile;\n        let curLat = topLatLimit;\n        let curLon = leftLonLimit;\n        while (curLon < rightLonLimit) {\n            while (curLat > bottomLatLimit) {\n                const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n                newTile = {\"tileLat\": curLat, \"tileLon\": curLon, \"ways\": ways, \"name\":Math.round(Math.random()*100)};\n                drawTile(newTile);\n                tilesLoaded.push(newTile);\n                curLat -= TILE_WIDTH;\n                console.log(\"curlat\")\n                console.log(curLat)\n            }\n            if (curLat > bottommostTileLat) {\n                bottommostTileLat = curLat;\n            }\n            //curLat = topLatLimit;\n            curLon += TILE_WIDTH;\n            console.log(\"curlon\")\n            console.log(curLon)\n        }\n        if (curLon > rightMostTileLon) {\n            rightMostTileLon = curLon;\n        }\n    }\n\n    //uses post request to get ways within bounding box\n        async function requestWays(coordinates) {\n            const toSend = {\n                lat1: coordinates[0],\n                long1: coordinates[1],\n                lat2: coordinates[2],\n                long2: coordinates[3]\n            };\n            let config = {\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    'Access-Control-Allow-Origin': '*',\n                }\n            }\n            const res = await axios.post(\n                \"http://localhost:4567/ways\",\n                toSend,\n                config\n            );\n            return res[\"data\"][\"ways\"];\n        }\n    function clearLoadTiles() {\n        clearCanvas();\n\n        // First, purge old tiles\n        const mapBoundaries = getMapBoundaries();\n        //these are backwards\n        //M flipped these\n        const bottomLat = mapBoundaries[3];\n        const rightLon = mapBoundaries[2];\n        let saveTiles = [];\n        // Iterate over all the loaded tiles and see if they're still useful\n        for (let i = 0; i < tilesLoaded.length; i++) {\n            const checkTile = tilesLoaded[i];\n            const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n            const tileTopLat = tileBoundaries[0];\n            const tileLeftLon = tileBoundaries[1];\n            const tileBottomLat = tileBoundaries[2];\n            const tileRightLon = tileBoundaries[3];\n            // We expect latitudes within the map range to be LESS than the leftLat\n            // We expect longitudes within the map range to be GREATER than the topLon\n            const deleteTile = (tileRightLon > leftLon) || (tileLeftLon < rightLon)\n                || (tileBottomLat < topLat) || (tileTopLat > bottomLat);\n            // const keepTileLeftRight = (tileRightLat < leftLat) || (tileLeftLat > rightLat);\n            // if (tileRightLat > leftLat) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the left side\");\n            // }\n            // const keepTileUpDown = (tileBottomLon > topLon) || (tileTopLon < bottomLon);\n            // if (tileTopLon > bottomLon) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n            // }\n            // let keepTile = keepTileLeftRight && keepTileUpDown;\n            if (!deleteTile) {\n                drawTile(tilesLoaded[i]);\n                saveTiles.push(checkTile);\n            }\n        }\n        tilesLoaded = saveTiles;\n\n        // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n        //M switched from leftLat to topLon\n        while (getBoundingBox(topmostTileLat, leftMostTileLon, TILE_WIDTH)[2] > topLat){\n            console.log(\"adjusting loaded left boundary\");\n            leftMostTileLon -= TILE_WIDTH;\n        }\n        //M see above\n        while (getBoundingBox(topmostTileLat, leftMostTileLon, TILE_WIDTH)[3] < leftLon){\n            console.log(\"adjusting loaded top boundary\");\n            topmostTileLat += TILE_WIDTH;\n        }\n        //M switched rightLat and bottomLon\n        while (rightMostTileLon < rightLon){\n            console.log(\"adjusting loaded right boundary\");\n            rightMostTileLon += TILE_WIDTH;\n        }\n        while (bottommostTileLat > bottomLat){\n            console.log(\"adjusting loaded bottom boundary\");\n            bottommostTileLat-= TILE_WIDTH;\n        }\n\n        // Now, load new tiles\n        while (leftMostTileLon < leftLon) {\n            console.log(\"gap at left\");\n            //MAXIME swapped fields here(highesttilelon with leftmost + widht and lowestTile and leftmost\n            loadTilesWithin(bottommostTileLat, leftMostTileLon + TILE_WIDTH, topmostTileLat, rightMostTileLon);\n            //leftmostTileLat += TILE_WIDTH;\n        }\n        while (rightMostTileLon > rightLon) {\n            console.log(\"gap at right\");\n            loadTilesWithin(bottommostTileLat, leftMostTileLon,  topmostTileLat, rightMostTileLon - TILE_WIDTH);\n        }\n        while (topmostTileLat > topLat) {\n            console.log(\"gap at top\");\n            loadTilesWithin(bottommostTileLat, leftMostTileLon,  topmostTileLat + TILE_WIDTH, rightMostTileLon - TILE_WIDTH);\n        }\n        while (bottommostTileLat < bottomLat) {\n            console.log(\"gap at bottom\");\n            loadTilesWithin(bottommostTileLat + TILE_WIDTH, leftMostTileLon,  topmostTileLat, rightMostTileLon);\n        }\n        //console.log(tilesLoaded.length);\n        //drawLoadedRect();\n    }\n\n    /*function drawLoadedRect(){\n        const ctx = ctxRef.current;\n        const loadedPixBoxTopLeft = latLonCoordToPix(leftmostTileLat, highestTileLon);\n        const loadedPixBoxBottomRight = latLonCoordToPix(rightmostTileLat, lowestTileLon);\n        const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n        const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n        ctx.strokeStyle = \"red\";\n        ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n    }\n\n     */\n\n    /**\n     * Code to turn lon/lat coordinates into pixel coordinates for the canvas:\n     * takes in a latitude and longitude coordinate, returns a length-2 list with the\n     * corresponding pixel position on the canvas [left, top]\n     * @param lat - the latitude coordinate to turn into a pixel left coordinate\n     * @param lon - the longitude coordinate to turn into a pixel top coordinate\n     * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n     */\n    function latLonCoordToPix(lat, lon) {\n        const normalizedLat = topLat - lat;\n        const normalizedLon = lon - leftLon;\n        // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n        // We expect latitudes within the map range to be LESS than the leftLat\n        // We expect longitudes within the map range to be GREATER than the topLon\n\n        return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n    }\n\n    /**\n     * Turns a latitude/longitude coordinate value into a pixel value.\n     * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n     * @returns {number} the pixel conversion of the lat/lon value\n     */\n    function pixIfy(latLonVal) {\n        const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n        return latLonVal * pixOverLatLonFactor;\n    }\n\n    /**\n     * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n     * and longitude coordinate\n     * Returns a length-2 list with [lat, lon]\n     * @param left - the pixel left coordinate to turn into map latitude\n     * @param top - the pixel top coordinate to turn into map longitude\n     * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n     */\n    function pixCoordToLatLon(left, top) {\n        const canvas = canvasRef.current;\n        const normalizedLeft = left - canvas.offsetLeft;\n        const normalizedTop = top - canvas.offsetTop;\n        // console.log(normalizedLeft + \", \" + normalizedTop);\n        // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n        const returnLat = leftLat - latLonIfy(normalizedLeft);\n        const returnLon = topLon + latLonIfy(normalizedTop);\n        // console.log(returnLat, \", \", returnLon)\n        // console.log(latLonCoordToPix(returnLat, returnLon));\n        return [returnLon, returnLat];\n    }\n\n    /**\n     * Turns a value in pixels into a value in latitude/longitude coordinates.\n     * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n     * @returns {number} the lat/lon conversion of the pixel value\n     */\n    function latLonIfy(pixVal) {\n        const latLonOverPixFactor =  latLonRange / CANVAS_SIDE_LENGTH;\n        return pixVal * latLonOverPixFactor;\n    }\n\n    /**\n     * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n     * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of the current map frame.\n     */\n    function getMapBoundaries() {\n        return getBoundingBox(topLat, leftLon, latLonRange);\n    }\n\n    function getBoundingBox(boxTopLat, boxLeftLon, boxRange) {\n        return [boxTopLat, boxLeftLon, boxTopLat - boxRange, boxLeftLon + boxRange];\n    }\n\n    // console.log(latLonCoordToPix(41.801763, -71.380682));\n\n    function handleClickOrDrag(mouseUpX, mouseUpY) {\n        const xChange = mouseUpX - mouseDownX;\n        const yChange = mouseDownY - mouseUpY;\n        // We expect latitudes within the map range to be LESS than the leftLat\n        // We expect longitudes within the map range to be GREATER than the topLon\n\n        if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n            console.log(\"Clicked!\");\n            const ctx = ctxRef.current;\n            ctx.fillStyle = \"green\";\n\n            //TODO: insert the nearest call here\n        } else {\n            console.log(\"Dragged!\");\n            // console.log(xChange, yChange);\n            //console.log(latLonIfy(xChange), latLonIfy(yChange));\n            //console.log(leftLat + \", \" + topLon);\n            // TODO: this may want to get changed to a setParamName() function call when setState is used\n            //MAXIME swapped these\n            topLat += latLonIfy(yChange);\n            leftLon += latLonIfy(xChange);\n            //console.log(leftLat + \", \" + topLon);\n            clearLoadTiles();\n        }\n    }\n\n    function clearCanvas() {\n        const ctx = ctxRef.current;\n        const canvas = canvasRef.current;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    function drawTile(tileToDraw) {\n        //console.log(\"drawing tile\");\n        // console.log(tileToDraw);\n        // const ctx = ctxRef.current;\n        // ctx.fillStyle = \"lightgreen\";\n        // const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n        // const baseX = tileCoord[0];\n        // const baseY = tileCoord[1];\n        //\n        // const pixTileWidth = pixIfy(TILE_WIDTH);\n        // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n        //      Math.min(baseX + pixTileWidth, pixTileWidth),\n        //      Math.min(baseY + pixTileWidth, pixTileWidth));\n        //  ctx.strokeStyle = \"black\";\n        //  ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n        //      Math.min(baseX + pixTileWidth, pixTileWidth),\n        //      Math.min(baseY + pixTileWidth, pixTileWidth));\n        //  ctx.fillStyle = \"black\";\n        // ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n        //console.log(tileToDraw);\n        //console.log(tileToDraw[\"ways\"]);\n        tileToDraw[\"ways\"].forEach(traceWay);\n    }\n\n    // function drawWays(tileToDraw) {\n    //     const canvas = $('#canvas')[0]; // Getting a reference to the <canvas> element that has an ID of 'canvas'\n    //     canvas.width = TILE_WIDTH;\n    //     canvas.height = TILE_WIDTH;\n    //     tileToDraw.ways.forEach(traceWay)\n    // }\n\n    function traceWay(way) {\n        //console.log(way)\n        //probably should change wayslist into a hashmap\n        const ctx = ctxRef.current;\n        const canvas = canvasRef.current;\n        //let c = document.getElementById(\"myCanvas\");\n        //let ctx = c.getContext(\"2d\");\n        let startLatCoord = way[\"startLat\"]\n        let startLonCoord = way[\"startLong\"]\n        let pixStart = latLonCoordToPix(startLatCoord, startLonCoord)\n        //console.log(pixStart)\n        ctx.fillStyle = \"black\";\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(pixStart[0], pixStart[1])\n        let endLatCoord = way[\"destLat\"]\n        //console.log(endLatCoord)\n        let endLongCoord = way[\"destLong\"]\n        //console.log(endLongCoord)\n        let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord)\n        //console.log(pixEnd)\n        ctx.lineTo(pixEnd[0], pixEnd[1])\n        ctx.stroke();\n    }\n\n    let scrollFinish;\n\n    return (\n        <div>\n            <h1>Test title</h1>\n            <TextBox label={\"Source Latitude\"} change={setStartLat}/>\n            <TextBox label={\"Source Longitude\"} change={setStartLon}/>\n            <TextBox label={\"Destination Latitude\"} change={setDestLat}/>\n            <TextBox label={\"Destination Longitude\"} change={setDestLon}/>\n            <AwesomeButton type=\"primary\" onPress={requestRoute}>Submit!</AwesomeButton>\n            <br/>\n            {route.map((coord, index) =>\n                <p key={index}>{coord[0]}, {coord[1]}</p>\n            )}\n            <canvas ref={canvasRef} onMouseDown={(event) => {\n                mouseDownX = event.pageX;\n                mouseDownY = event.pageY;\n            }} onMouseUp={(event) => {\n                //pixCoordToLatLon(event.pageX, event.pageY);\n                handleClickOrDrag(event.pageX, event.pageY);\n            }} onWheel={(event) => {\n                event.stopPropagation();\n                // console.log(\"scrolling\");\n                clearTimeout(scrollFinish)\n                scrollFinish = setTimeout(() => {\n                    // console.log(\"Not scrolling anymore\");\n                    if (event.deltaY < 0) {\n                        console.log(\"Scrolled up\");\n                    } else {\n                        console.log(\"Scrolled down\");\n                    }\n                }, SCROLL_WAIT);\n            }}/>\n        </div>\n    );\n}\n\nexport default Route;"]},"metadata":{},"sourceType":"module"}