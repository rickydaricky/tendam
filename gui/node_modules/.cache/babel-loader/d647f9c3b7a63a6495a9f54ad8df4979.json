{"ast":null,"code":"var _jsxFileName = \"/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js\",\n    _s = $RefreshSig$();\n\nimport './App.css';\nimport TextBox from \"./TextBox\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport axios from 'axios';\nimport { AwesomeButton } from \"react-awesome-button\";\nimport \"react-awesome-button/dist/styles.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Route() {\n  _s();\n\n  const [startLat, setStartLat] = useState(0);\n  const [startLon, setStartLon] = useState(0);\n  const [destLat, setDestLat] = useState(0);\n  const [destLon, setDestLon] = useState(0);\n  const [route, setRoute] = useState([]); //const [ways, setWays] = useState([]);\n\n  const CANVAS_SIDE_LENGTH = 450;\n  const SCROLL_WAIT = 40;\n  const CLICK_RANGE = 5; //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n  // are implemented\n  //M changed the names here to be topLat and leftLon\n\n  let topLat = 41.832038;\n  let leftLon = -71.406957;\n  let latLonRange = 0.011275;\n  let mouseDownX;\n  let mouseDownY; // So in order to render the starting map, it'll have to render 64 tiles, I think\n  // On Brown campus, that gives approximately 4,500 ways in just one tile...\n  // We expect latitudes within the map range to be LESS than the leftLat\n  // We expect longitudes within the map range to be GREATER than the topLon\n  // In order to get rightLat or bottomLon, just subtract latLonRange from leftLat, or add it to topLon\n  // But for testing purposes, unless the above values are changed:\n  // rightLat = 41.801763\n  // bottomLon = -71.380682\n\n  const TILE_WIDTH = 0.003909375; // one eighth of starting latLonRange\n\n  let topmostTileLat = topLat;\n  let leftMostTileLon = leftLon;\n  let bottommostTileLat = leftmostTileLat;\n  let lowestTileLon = highestTileLon;\n  let tilesLoaded = []; // Tiles should be JavaScript objects with properties leftLat, topLon, and an [] of ways\n  // Ways should be length-4 list of Doubles? [lat1, lon1, lat2, lon2]?\n\n  const canvasRef = useRef();\n  let ctxRef = useRef();\n  /**\n   * Makes an axios request.\n   */\n\n  const requestRoute = () => {\n    const toSend = {\n      srclat: startLat,\n      srclong: startLon,\n      destlat: destLat,\n      destlong: destLon\n    }; //console.log(toSend);\n\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    }; //Install and import this!\n\n    axios.post(\"http://localhost:4567/route\", toSend, config).then(response => {\n      console.log(response.data); // TODO: make sure that the \"route\" here corresponds to the correct data we want back\n\n      setRoute(response.data[\"route\"]);\n    }).catch(function (error) {\n      console.log(error);\n    });\n  };\n  /**\n   * Code to run when the page loads\n   */\n\n\n  useEffect(() => {\n    //console.log(\"page loaded!\");\n    const canvas = canvasRef.current;\n    canvas.width = CANVAS_SIDE_LENGTH;\n    canvas.height = CANVAS_SIDE_LENGTH;\n    ctxRef.current = canvas.getContext(\"2d\"); // let ctx = ctxRef.current;\n    // ctx.fillStyle = \"green\";\n    // ctx.fillRect(0, 0, 100, 100);\n    // Load tiles\n\n    loadStartingTiles();\n  }, []);\n\n  function loadStartingTiles() {\n    console.log(\"Loading starting tiles\");\n    const boundaries = getMapBoundaries();\n    loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n  }\n\n  async function loadTilesWithin(leftLatLimit, topLonLimit, rightLatLimit, bottomLonLimit) {\n    if (leftLatLimit > leftmostTileLat) {\n      leftmostTileLat = leftLatLimit;\n    }\n\n    if (topLonLimit < highestTileLon) {\n      highestTileLon = topLonLimit;\n    }\n\n    let newTile;\n    let curLat = leftLatLimit;\n    let curLon = topLonLimit; //requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n    //drawTile()\n\n    while (curLon < bottomLonLimit) {\n      while (curLat > rightLatLimit) {\n        //get ways and maybe it updates the state of the ways variable?\n        //i dont know if this should be a function or not\n        //requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n        const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH)); //console.log(ways);\n\n        newTile = {\n          \"tileLat\": curLat,\n          \"tileLon\": curLon,\n          \"ways\": ways,\n          \"name\": Math.round(Math.random() * 100)\n        }; //is it supposed to be called setWays or ways here?\n\n        drawTile(newTile); // TODO: here, \"ways\" should hold a list of ways within the tile range\n        // NOTE: you can get lat1/lon1 lat2/lon2 coordinates for the tile\n        // by calling getBoudingBox(tileLat, tileLon, TILE_WIDTH);\n        // TODO: drawTile might want to call the eventual method for drawing ways\n        // console.log(newTile);\n\n        tilesLoaded.push(newTile);\n        curLat -= TILE_WIDTH;\n      }\n\n      if (curLon < rightmostTileLat) {\n        rightmostTileLat = curLat;\n      }\n\n      curLat = leftLatLimit;\n      curLon += TILE_WIDTH;\n    }\n\n    if (curLat > lowestTileLon) {\n      lowestTileLon = curLon;\n    }\n  } //uses post request to get ways within bounding box\n\n\n  async function requestWays(coordinates) {\n    const toSend = {\n      lat1: coordinates[0],\n      long1: coordinates[1],\n      lat2: coordinates[2],\n      long2: coordinates[3]\n    }; //console.log(\"this is what is getting passed to the post request\")\n    //console.log(toSend);\n\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    const res = await axios.post(\"http://localhost:4567/ways\", toSend, config);\n    return res[\"data\"][\"ways\"];\n  }\n\n  function clearLoadTiles() {\n    clearCanvas(); // First, purge old tiles\n\n    const mapBoundaries = getMapBoundaries(); //these are backwards\n    //M flipped these\n\n    const rightLat = mapBoundaries[3];\n    const bottomLon = mapBoundaries[2];\n    let saveTiles = []; // Iterate over all the loaded tiles and see if they're still useful\n\n    for (let i = 0; i < tilesLoaded.length; i++) {\n      const checkTile = tilesLoaded[i];\n      const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n      const tileLeftLat = tileBoundaries[0];\n      const tileTopLon = tileBoundaries[1];\n      const tileRightLat = tileBoundaries[2];\n      const tileBottomLon = tileBoundaries[3]; // We expect latitudes within the map range to be LESS than the leftLat\n      // We expect longitudes within the map range to be GREATER than the topLon\n\n      const deleteTile = tileRightLat > leftLat || tileLeftLat < rightLat || tileBottomLon < topLon || tileTopLon > bottomLon; // const keepTileLeftRight = (tileRightLat < leftLat) || (tileLeftLat > rightLat);\n      // if (tileRightLat > leftLat) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the left side\");\n      // }\n      // const keepTileUpDown = (tileBottomLon > topLon) || (tileTopLon < bottomLon);\n      // if (tileTopLon > bottomLon) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n      // }\n      // let keepTile = keepTileLeftRight && keepTileUpDown;\n\n      if (!deleteTile) {\n        drawTile(tilesLoaded[i]);\n        saveTiles.push(checkTile);\n      }\n    }\n\n    tilesLoaded = saveTiles; // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n    //M switched from leftLat to topLon\n\n    while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[2] > leftLat) {\n      console.log(\"adjusting loaded left boundary\");\n      leftmostTileLat -= TILE_WIDTH;\n    } //M see above\n\n\n    while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[3] < topLon) {\n      console.log(\"adjusting loaded top boundary\");\n      highestTileLon += TILE_WIDTH;\n    } //M switched rightLat and bottomLon\n\n\n    while (rightmostTileLat < rightLat) {\n      console.log(\"adjusting loaded right boundary\");\n      rightmostTileLat += TILE_WIDTH;\n    }\n\n    while (lowestTileLon > bottomLon) {\n      console.log(\"adjusting loaded bottom boundary\");\n      lowestTileLon -= TILE_WIDTH;\n    } // Now, load new tiles\n\n\n    while (leftmostTileLat < leftLat) {\n      console.log(\"gap at left\"); //MAXIME swapped fields here(highesttilelon with leftmost + widht and lowestTile and leftmost\n\n      loadTilesWithin(highestTileLon, leftmostTileLat + TILE_WIDTH, lowestTileLon, leftmostTileLat); //leftmostTileLat += TILE_WIDTH;\n    }\n\n    while (rightmostTileLat > rightLat) {\n      console.log(\"gap at right\");\n      loadTilesWithin(highestTileLon, rightmostTileLat, lowestTileLon, rightmostTileLat - TILE_WIDTH);\n    }\n\n    while (highestTileLon > topLon) {\n      console.log(\"gap at top\");\n      loadTilesWithin(highestTileLon - TILE_WIDTH, leftmostTileLat, highestTileLon, rightmostTileLat);\n    }\n\n    while (lowestTileLon < bottomLon) {\n      console.log(\"gap at bottom\");\n      loadTilesWithin(lowestTileLon, leftmostTileLat, lowestTileLon + TILE_WIDTH, rightmostTileLat);\n    } //console.log(tilesLoaded.length);\n    //drawLoadedRect();\n\n  }\n  /*function drawLoadedRect(){\n      const ctx = ctxRef.current;\n      const loadedPixBoxTopLeft = latLonCoordToPix(leftmostTileLat, highestTileLon);\n      const loadedPixBoxBottomRight = latLonCoordToPix(rightmostTileLat, lowestTileLon);\n      const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n      const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n      ctx.strokeStyle = \"red\";\n      ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n  }\n    */\n\n  /**\n   * Code to turn lon/lat coordinates into pixel coordinates for the canvas:\n   * takes in a latitude and longitude coordinate, returns a length-2 list with the\n   * corresponding pixel position on the canvas [left, top]\n   * @param lat - the latitude coordinate to turn into a pixel left coordinate\n   * @param lon - the longitude coordinate to turn into a pixel top coordinate\n   * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n   */\n\n\n  function latLonCoordToPix(lat, lon) {\n    const normalizedLat = leftLat - lat;\n    const normalizedLon = lon - topLon; // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n    // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n  }\n  /**\n   * Turns a latitude/longitude coordinate value into a pixel value.\n   * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n   * @returns {number} the pixel conversion of the lat/lon value\n   */\n\n\n  function pixIfy(latLonVal) {\n    const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n    return latLonVal * pixOverLatLonFactor;\n  }\n  /**\n   * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n   * and longitude coordinate\n   * Returns a length-2 list with [lat, lon]\n   * @param left - the pixel left coordinate to turn into map latitude\n   * @param top - the pixel top coordinate to turn into map longitude\n   * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n   */\n\n\n  function pixCoordToLatLon(left, top) {\n    const canvas = canvasRef.current;\n    const normalizedLeft = left - canvas.offsetLeft;\n    const normalizedTop = top - canvas.offsetTop; // console.log(normalizedLeft + \", \" + normalizedTop);\n    // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n    const returnLat = leftLat - latLonIfy(normalizedLeft);\n    const returnLon = topLon + latLonIfy(normalizedTop); // console.log(returnLat, \", \", returnLon)\n    // console.log(latLonCoordToPix(returnLat, returnLon));\n\n    return [returnLon, returnLat];\n  }\n  /**\n   * Turns a value in pixels into a value in latitude/longitude coordinates.\n   * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n   * @returns {number} the lat/lon conversion of the pixel value\n   */\n\n\n  function latLonIfy(pixVal) {\n    const latLonOverPixFactor = latLonRange / CANVAS_SIDE_LENGTH;\n    return pixVal * latLonOverPixFactor;\n  }\n  /**\n   * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n   * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of the current map frame.\n   */\n\n\n  function getMapBoundaries() {\n    return getBoundingBox(leftLat, topLon, latLonRange);\n  }\n  /**\n   * Get the lat/lon boundaries of a passed square area with unknown side length.\n   * @param boxLeftLat latitude coordinate of the northwest corner\n   * @param boxTopLon longitude coordinate of the northwest corner\n   * @param boxRange side length, in terms of lat/lon coordinates\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of a passed square.\n   */\n\n\n  function getBoundingBox(boxLeftLat, boxTopLon, boxRange) {\n    return [boxLeftLat, boxTopLon, boxLeftLat - boxRange, boxTopLon + boxRange];\n  } // console.log(latLonCoordToPix(41.801763, -71.380682));\n\n\n  function handleClickOrDrag(mouseUpX, mouseUpY) {\n    const xChange = mouseUpX - mouseDownX;\n    const yChange = mouseDownY - mouseUpY; // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n      console.log(\"Clicked!\");\n      const ctx = ctxRef.current;\n      ctx.fillStyle = \"green\"; //TODO: insert the nearest call here\n    } else {\n      console.log(\"Dragged!\"); // console.log(xChange, yChange);\n      //console.log(latLonIfy(xChange), latLonIfy(yChange));\n      //console.log(leftLat + \", \" + topLon);\n      // TODO: this may want to get changed to a setParamName() function call when setState is used\n      //MAXIME swapped these\n\n      leftLat += latLonIfy(yChange);\n      topLon += latLonIfy(xChange); //console.log(leftLat + \", \" + topLon);\n\n      clearLoadTiles();\n    }\n  }\n\n  function clearCanvas() {\n    const ctx = ctxRef.current;\n    const canvas = canvasRef.current;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  function drawTile(tileToDraw) {\n    //console.log(\"drawing tile\");\n    // console.log(tileToDraw);\n    // const ctx = ctxRef.current;\n    // ctx.fillStyle = \"lightgreen\";\n    // const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n    // const baseX = tileCoord[0];\n    // const baseY = tileCoord[1];\n    //\n    // const pixTileWidth = pixIfy(TILE_WIDTH);\n    // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n    //      Math.min(baseX + pixTileWidth, pixTileWidth),\n    //      Math.min(baseY + pixTileWidth, pixTileWidth));\n    //  ctx.strokeStyle = \"black\";\n    //  ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n    //      Math.min(baseX + pixTileWidth, pixTileWidth),\n    //      Math.min(baseY + pixTileWidth, pixTileWidth));\n    //  ctx.fillStyle = \"black\";\n    // ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n    //console.log(tileToDraw);\n    //console.log(tileToDraw[\"ways\"]);\n    tileToDraw[\"ways\"].forEach(traceWay);\n  } // function drawWays(tileToDraw) {\n  //     const canvas = $('#canvas')[0]; // Getting a reference to the <canvas> element that has an ID of 'canvas'\n  //     canvas.width = TILE_WIDTH;\n  //     canvas.height = TILE_WIDTH;\n  //     tileToDraw.ways.forEach(traceWay)\n  // }\n\n\n  function traceWay(way) {\n    //console.log(way)\n    //probably should change wayslist into a hashmap\n    const ctx = ctxRef.current;\n    const canvas = canvasRef.current; //let c = document.getElementById(\"myCanvas\");\n    //let ctx = c.getContext(\"2d\");\n\n    let startLatCoord = way[\"startLat\"];\n    let startLonCoord = way[\"startLong\"];\n    let pixStart = latLonCoordToPix(startLatCoord, startLonCoord); //console.log(pixStart)\n\n    ctx.fillStyle = \"black\";\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(pixStart[0], pixStart[1]);\n    let endLatCoord = way[\"destLat\"]; //console.log(endLatCoord)\n\n    let endLongCoord = way[\"destLong\"]; //console.log(endLongCoord)\n\n    let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord); //console.log(pixEnd)\n\n    ctx.lineTo(pixEnd[0], pixEnd[1]);\n    ctx.stroke();\n  }\n\n  let scrollFinish;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Test title\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 445,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Latitude\",\n      change: setStartLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 446,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Longitude\",\n      change: setStartLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 447,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Latitude\",\n      change: setDestLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 448,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Longitude\",\n      change: setDestLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 449,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(AwesomeButton, {\n      type: \"primary\",\n      onPress: requestRoute,\n      children: \"Submit!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 450,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 451,\n      columnNumber: 13\n    }, this), route.map((coord, index) => /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [coord[0], \", \", coord[1]]\n    }, index, true, {\n      fileName: _jsxFileName,\n      lineNumber: 453,\n      columnNumber: 17\n    }, this)), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      onMouseDown: event => {\n        mouseDownX = event.pageX;\n        mouseDownY = event.pageY;\n      },\n      onMouseUp: event => {\n        //pixCoordToLatLon(event.pageX, event.pageY);\n        handleClickOrDrag(event.pageX, event.pageY);\n      },\n      onWheel: event => {\n        event.stopPropagation(); // console.log(\"scrolling\");\n\n        clearTimeout(scrollFinish);\n        scrollFinish = setTimeout(() => {\n          // console.log(\"Not scrolling anymore\");\n          if (event.deltaY < 0) {\n            console.log(\"Scrolled up\");\n          } else {\n            console.log(\"Scrolled down\");\n          }\n        }, SCROLL_WAIT);\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 455,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 444,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Route, \"oMsN6JFjd0Rg09WLtcTIh6Wt6/w=\");\n\n_c = Route;\nexport default Route;\n\nvar _c;\n\n$RefreshReg$(_c, \"Route\");","map":{"version":3,"sources":["/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js"],"names":["TextBox","React","useState","useEffect","useRef","axios","AwesomeButton","Route","startLat","setStartLat","startLon","setStartLon","destLat","setDestLat","destLon","setDestLon","route","setRoute","CANVAS_SIDE_LENGTH","SCROLL_WAIT","CLICK_RANGE","topLat","leftLon","latLonRange","mouseDownX","mouseDownY","TILE_WIDTH","topmostTileLat","leftMostTileLon","bottommostTileLat","leftmostTileLat","lowestTileLon","highestTileLon","tilesLoaded","canvasRef","ctxRef","requestRoute","toSend","srclat","srclong","destlat","destlong","config","headers","post","then","response","console","log","data","catch","error","canvas","current","width","height","getContext","loadStartingTiles","boundaries","getMapBoundaries","loadTilesWithin","leftLatLimit","topLonLimit","rightLatLimit","bottomLonLimit","newTile","curLat","curLon","ways","requestWays","getBoundingBox","Math","round","random","drawTile","push","rightmostTileLat","coordinates","lat1","long1","lat2","long2","res","clearLoadTiles","clearCanvas","mapBoundaries","rightLat","bottomLon","saveTiles","i","length","checkTile","tileBoundaries","tileLeftLat","tileTopLon","tileRightLat","tileBottomLon","deleteTile","leftLat","topLon","latLonCoordToPix","lat","lon","normalizedLat","normalizedLon","pixIfy","latLonVal","pixOverLatLonFactor","pixCoordToLatLon","left","top","normalizedLeft","offsetLeft","normalizedTop","offsetTop","returnLat","latLonIfy","returnLon","pixVal","latLonOverPixFactor","boxLeftLat","boxTopLon","boxRange","handleClickOrDrag","mouseUpX","mouseUpY","xChange","yChange","abs","ctx","fillStyle","clearRect","tileToDraw","forEach","traceWay","way","startLatCoord","startLonCoord","pixStart","lineWidth","beginPath","moveTo","endLatCoord","endLongCoord","pixEnd","lineTo","stroke","scrollFinish","map","coord","index","event","pageX","pageY","stopPropagation","clearTimeout","setTimeout","deltaY"],"mappings":"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","sourcesContent":["import './App.css';\nimport TextBox from \"./TextBox\";\nimport React, {useState, useEffect, useRef} from 'react';\nimport axios from 'axios';\nimport { AwesomeButton } from \"react-awesome-button\";\nimport \"react-awesome-button/dist/styles.css\";\n\nfunction Route() {\n    const [startLat, setStartLat] = useState(0);\n    const [startLon, setStartLon] = useState(0);\n    const [destLat, setDestLat] = useState(0);\n    const [destLon, setDestLon] = useState(0);\n    const [route, setRoute] = useState([]);\n    //const [ways, setWays] = useState([]);\n    const CANVAS_SIDE_LENGTH = 450;\n    const SCROLL_WAIT = 40;\n    const CLICK_RANGE = 5;\n    //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n    // are implemented\n    //M changed the names here to be topLat and leftLon\n    let topLat = 41.832038;\n    let leftLon = -71.406957;\n    let latLonRange = 0.011275;\n    let mouseDownX;\n    let mouseDownY;\n    // So in order to render the starting map, it'll have to render 64 tiles, I think\n    // On Brown campus, that gives approximately 4,500 ways in just one tile...\n\n    // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    // In order to get rightLat or bottomLon, just subtract latLonRange from leftLat, or add it to topLon\n    // But for testing purposes, unless the above values are changed:\n    // rightLat = 41.801763\n    // bottomLon = -71.380682\n\n    const TILE_WIDTH = 0.003909375; // one eighth of starting latLonRange\n    let topmostTileLat = topLat;\n    let leftMostTileLon = leftLon;\n    let bottommostTileLat = leftmostTileLat;\n    let lowestTileLon = highestTileLon;\n    let tilesLoaded = [];\n    // Tiles should be JavaScript objects with properties leftLat, topLon, and an [] of ways\n    // Ways should be length-4 list of Doubles? [lat1, lon1, lat2, lon2]?\n\n\n    const canvasRef = useRef();\n    let ctxRef = useRef();\n\n    /**\n     * Makes an axios request.\n     */\n    const requestRoute = () => {\n        const toSend = {\n            srclat: startLat,\n            srclong: startLon,\n            destlat: destLat,\n            destlong: destLon\n        };\n        //console.log(toSend);\n\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n\n        //Install and import this!\n        axios.post(\n            \"http://localhost:4567/route\",\n            toSend,\n            config\n        )\n            .then(response => {\n                console.log(response.data);\n                // TODO: make sure that the \"route\" here corresponds to the correct data we want back\n                setRoute(response.data[\"route\"]);\n            })\n            .catch(function (error) {\n                console.log(error);\n            });\n    }\n\n    /**\n     * Code to run when the page loads\n     */\n    useEffect(() => {\n        //console.log(\"page loaded!\");\n        const canvas = canvasRef.current;\n        canvas.width = CANVAS_SIDE_LENGTH;\n        canvas.height = CANVAS_SIDE_LENGTH;\n        ctxRef.current = canvas.getContext(\"2d\");\n        // let ctx = ctxRef.current;\n        // ctx.fillStyle = \"green\";\n        // ctx.fillRect(0, 0, 100, 100);\n\n        // Load tiles\n        loadStartingTiles();\n    }, []);\n\n    function loadStartingTiles() {\n        console.log(\"Loading starting tiles\");\n        const boundaries = getMapBoundaries();\n        loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n    }\n\n    async function loadTilesWithin(leftLatLimit, topLonLimit, rightLatLimit, bottomLonLimit) {\n        if (leftLatLimit > leftmostTileLat) {\n            leftmostTileLat = leftLatLimit;\n        }\n        if (topLonLimit < highestTileLon) {\n            highestTileLon = topLonLimit;\n        }\n        let newTile;\n        let curLat = leftLatLimit;\n        let curLon = topLonLimit;\n        //requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n        //drawTile()\n        while (curLon < bottomLonLimit) {\n            while (curLat > rightLatLimit) {\n                //get ways and maybe it updates the state of the ways variable?\n                //i dont know if this should be a function or not\n                //requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n                const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n                //console.log(ways);\n                newTile = {\"tileLat\": curLat, \"tileLon\": curLon, \"ways\": ways, \"name\":Math.round(Math.random()*100)};\n                //is it supposed to be called setWays or ways here?\n                drawTile(newTile);\n                // TODO: here, \"ways\" should hold a list of ways within the tile range\n                // NOTE: you can get lat1/lon1 lat2/lon2 coordinates for the tile\n                // by calling getBoudingBox(tileLat, tileLon, TILE_WIDTH);\n\n                // TODO: drawTile might want to call the eventual method for drawing ways\n\n                // console.log(newTile);\n                tilesLoaded.push(newTile);\n                curLat -= TILE_WIDTH;\n            }\n            if (curLon < rightmostTileLat) {\n                rightmostTileLat = curLat;\n            }\n            curLat = leftLatLimit;\n            curLon += TILE_WIDTH;\n        }\n        if (curLat > lowestTileLon) {\n            lowestTileLon = curLon;\n        }\n    }\n\n    //uses post request to get ways within bounding box\n        async function requestWays(coordinates) {\n            const toSend = {\n                lat1: coordinates[0],\n                long1: coordinates[1],\n                lat2: coordinates[2],\n                long2: coordinates[3]\n            };\n            //console.log(\"this is what is getting passed to the post request\")\n            //console.log(toSend);\n\n            let config = {\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    'Access-Control-Allow-Origin': '*',\n                }\n            }\n            const res = await axios.post(\n                \"http://localhost:4567/ways\",\n                toSend,\n                config\n            );\n            return res[\"data\"][\"ways\"];\n        }\n    function clearLoadTiles() {\n        clearCanvas();\n\n        // First, purge old tiles\n        const mapBoundaries = getMapBoundaries();\n        //these are backwards\n        //M flipped these\n        const rightLat = mapBoundaries[3];\n        const bottomLon = mapBoundaries[2];\n        let saveTiles = [];\n        // Iterate over all the loaded tiles and see if they're still useful\n        for (let i = 0; i < tilesLoaded.length; i++) {\n            const checkTile = tilesLoaded[i];\n            const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n            const tileLeftLat = tileBoundaries[0];\n            const tileTopLon = tileBoundaries[1];\n            const tileRightLat = tileBoundaries[2];\n            const tileBottomLon = tileBoundaries[3];\n            // We expect latitudes within the map range to be LESS than the leftLat\n            // We expect longitudes within the map range to be GREATER than the topLon\n            const deleteTile = (tileRightLat > leftLat) || (tileLeftLat < rightLat)\n                || (tileBottomLon < topLon) || (tileTopLon > bottomLon);\n            // const keepTileLeftRight = (tileRightLat < leftLat) || (tileLeftLat > rightLat);\n            // if (tileRightLat > leftLat) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the left side\");\n            // }\n            // const keepTileUpDown = (tileBottomLon > topLon) || (tileTopLon < bottomLon);\n            // if (tileTopLon > bottomLon) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n            // }\n            // let keepTile = keepTileLeftRight && keepTileUpDown;\n            if (!deleteTile) {\n                drawTile(tilesLoaded[i]);\n                saveTiles.push(checkTile);\n            }\n        }\n        tilesLoaded = saveTiles;\n\n        // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n        //M switched from leftLat to topLon\n        while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[2] > leftLat){\n            console.log(\"adjusting loaded left boundary\");\n            leftmostTileLat -= TILE_WIDTH;\n        }\n        //M see above\n        while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[3] < topLon){\n            console.log(\"adjusting loaded top boundary\");\n            highestTileLon += TILE_WIDTH;\n        }\n        //M switched rightLat and bottomLon\n        while (rightmostTileLat < rightLat){\n            console.log(\"adjusting loaded right boundary\");\n            rightmostTileLat += TILE_WIDTH;\n        }\n        while (lowestTileLon > bottomLon){\n            console.log(\"adjusting loaded bottom boundary\");\n            lowestTileLon -= TILE_WIDTH;\n        }\n\n        // Now, load new tiles\n        while (leftmostTileLat < leftLat) {\n            console.log(\"gap at left\");\n            //MAXIME swapped fields here(highesttilelon with leftmost + widht and lowestTile and leftmost\n            loadTilesWithin(highestTileLon, leftmostTileLat + TILE_WIDTH, lowestTileLon, leftmostTileLat);\n            //leftmostTileLat += TILE_WIDTH;\n        }\n        while (rightmostTileLat > rightLat) {\n            console.log(\"gap at right\");\n            loadTilesWithin(highestTileLon, rightmostTileLat,  lowestTileLon, rightmostTileLat - TILE_WIDTH,);\n        }\n        while (highestTileLon > topLon) {\n            console.log(\"gap at top\");\n            loadTilesWithin(highestTileLon - TILE_WIDTH, leftmostTileLat, highestTileLon ,rightmostTileLat);\n        }\n        while (lowestTileLon < bottomLon) {\n            console.log(\"gap at bottom\");\n            loadTilesWithin(lowestTileLon, leftmostTileLat,lowestTileLon + TILE_WIDTH, rightmostTileLat );\n        }\n        //console.log(tilesLoaded.length);\n        //drawLoadedRect();\n    }\n\n    /*function drawLoadedRect(){\n        const ctx = ctxRef.current;\n        const loadedPixBoxTopLeft = latLonCoordToPix(leftmostTileLat, highestTileLon);\n        const loadedPixBoxBottomRight = latLonCoordToPix(rightmostTileLat, lowestTileLon);\n        const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n        const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n        ctx.strokeStyle = \"red\";\n        ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n    }\n\n     */\n\n    /**\n     * Code to turn lon/lat coordinates into pixel coordinates for the canvas:\n     * takes in a latitude and longitude coordinate, returns a length-2 list with the\n     * corresponding pixel position on the canvas [left, top]\n     * @param lat - the latitude coordinate to turn into a pixel left coordinate\n     * @param lon - the longitude coordinate to turn into a pixel top coordinate\n     * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n     */\n    function latLonCoordToPix(lat, lon) {\n        const normalizedLat = leftLat - lat;\n        const normalizedLon = lon - topLon;\n        // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n        // We expect latitudes within the map range to be LESS than the leftLat\n        // We expect longitudes within the map range to be GREATER than the topLon\n\n        return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n    }\n\n    /**\n     * Turns a latitude/longitude coordinate value into a pixel value.\n     * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n     * @returns {number} the pixel conversion of the lat/lon value\n     */\n    function pixIfy(latLonVal) {\n        const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n        return latLonVal * pixOverLatLonFactor;\n    }\n\n    /**\n     * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n     * and longitude coordinate\n     * Returns a length-2 list with [lat, lon]\n     * @param left - the pixel left coordinate to turn into map latitude\n     * @param top - the pixel top coordinate to turn into map longitude\n     * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n     */\n    function pixCoordToLatLon(left, top) {\n        const canvas = canvasRef.current;\n        const normalizedLeft = left - canvas.offsetLeft;\n        const normalizedTop = top - canvas.offsetTop;\n        // console.log(normalizedLeft + \", \" + normalizedTop);\n        // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n        const returnLat = leftLat - latLonIfy(normalizedLeft);\n        const returnLon = topLon + latLonIfy(normalizedTop);\n        // console.log(returnLat, \", \", returnLon)\n        // console.log(latLonCoordToPix(returnLat, returnLon));\n        return [returnLon, returnLat];\n    }\n\n    /**\n     * Turns a value in pixels into a value in latitude/longitude coordinates.\n     * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n     * @returns {number} the lat/lon conversion of the pixel value\n     */\n    function latLonIfy(pixVal) {\n        const latLonOverPixFactor =  latLonRange / CANVAS_SIDE_LENGTH;\n        return pixVal * latLonOverPixFactor;\n    }\n\n    /**\n     * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n     * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of the current map frame.\n     */\n    function getMapBoundaries() {\n        return getBoundingBox(leftLat, topLon, latLonRange);\n    }\n\n    /**\n     * Get the lat/lon boundaries of a passed square area with unknown side length.\n     * @param boxLeftLat latitude coordinate of the northwest corner\n     * @param boxTopLon longitude coordinate of the northwest corner\n     * @param boxRange side length, in terms of lat/lon coordinates\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of a passed square.\n     */\n    function getBoundingBox(boxLeftLat, boxTopLon, boxRange) {\n        return [boxLeftLat, boxTopLon, boxLeftLat - boxRange, boxTopLon + boxRange];\n    }\n\n    // console.log(latLonCoordToPix(41.801763, -71.380682));\n\n    function handleClickOrDrag(mouseUpX, mouseUpY) {\n        const xChange = mouseUpX - mouseDownX;\n        const yChange = mouseDownY - mouseUpY;\n        // We expect latitudes within the map range to be LESS than the leftLat\n        // We expect longitudes within the map range to be GREATER than the topLon\n\n        if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n            console.log(\"Clicked!\");\n            const ctx = ctxRef.current;\n            ctx.fillStyle = \"green\";\n\n            //TODO: insert the nearest call here\n        } else {\n            console.log(\"Dragged!\");\n            // console.log(xChange, yChange);\n            //console.log(latLonIfy(xChange), latLonIfy(yChange));\n            //console.log(leftLat + \", \" + topLon);\n            // TODO: this may want to get changed to a setParamName() function call when setState is used\n            //MAXIME swapped these\n            leftLat += latLonIfy(yChange);\n            topLon += latLonIfy(xChange);\n            //console.log(leftLat + \", \" + topLon);\n            clearLoadTiles();\n        }\n    }\n\n    function clearCanvas() {\n        const ctx = ctxRef.current;\n        const canvas = canvasRef.current;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    function drawTile(tileToDraw) {\n        //console.log(\"drawing tile\");\n        // console.log(tileToDraw);\n        // const ctx = ctxRef.current;\n        // ctx.fillStyle = \"lightgreen\";\n        // const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n        // const baseX = tileCoord[0];\n        // const baseY = tileCoord[1];\n        //\n        // const pixTileWidth = pixIfy(TILE_WIDTH);\n        // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n        //      Math.min(baseX + pixTileWidth, pixTileWidth),\n        //      Math.min(baseY + pixTileWidth, pixTileWidth));\n        //  ctx.strokeStyle = \"black\";\n        //  ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n        //      Math.min(baseX + pixTileWidth, pixTileWidth),\n        //      Math.min(baseY + pixTileWidth, pixTileWidth));\n        //  ctx.fillStyle = \"black\";\n        // ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n        //console.log(tileToDraw);\n        //console.log(tileToDraw[\"ways\"]);\n        tileToDraw[\"ways\"].forEach(traceWay);\n    }\n\n    // function drawWays(tileToDraw) {\n    //     const canvas = $('#canvas')[0]; // Getting a reference to the <canvas> element that has an ID of 'canvas'\n    //     canvas.width = TILE_WIDTH;\n    //     canvas.height = TILE_WIDTH;\n    //     tileToDraw.ways.forEach(traceWay)\n    // }\n\n    function traceWay(way) {\n        //console.log(way)\n        //probably should change wayslist into a hashmap\n        const ctx = ctxRef.current;\n        const canvas = canvasRef.current;\n        //let c = document.getElementById(\"myCanvas\");\n        //let ctx = c.getContext(\"2d\");\n        let startLatCoord = way[\"startLat\"]\n        let startLonCoord = way[\"startLong\"]\n        let pixStart = latLonCoordToPix(startLatCoord, startLonCoord)\n        //console.log(pixStart)\n        ctx.fillStyle = \"black\";\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(pixStart[0], pixStart[1])\n        let endLatCoord = way[\"destLat\"]\n        //console.log(endLatCoord)\n        let endLongCoord = way[\"destLong\"]\n        //console.log(endLongCoord)\n        let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord)\n        //console.log(pixEnd)\n        ctx.lineTo(pixEnd[0], pixEnd[1])\n        ctx.stroke();\n    }\n\n    let scrollFinish;\n\n    return (\n        <div>\n            <h1>Test title</h1>\n            <TextBox label={\"Source Latitude\"} change={setStartLat}/>\n            <TextBox label={\"Source Longitude\"} change={setStartLon}/>\n            <TextBox label={\"Destination Latitude\"} change={setDestLat}/>\n            <TextBox label={\"Destination Longitude\"} change={setDestLon}/>\n            <AwesomeButton type=\"primary\" onPress={requestRoute}>Submit!</AwesomeButton>\n            <br/>\n            {route.map((coord, index) =>\n                <p key={index}>{coord[0]}, {coord[1]}</p>\n            )}\n            <canvas ref={canvasRef} onMouseDown={(event) => {\n                mouseDownX = event.pageX;\n                mouseDownY = event.pageY;\n            }} onMouseUp={(event) => {\n                //pixCoordToLatLon(event.pageX, event.pageY);\n                handleClickOrDrag(event.pageX, event.pageY);\n            }} onWheel={(event) => {\n                event.stopPropagation();\n                // console.log(\"scrolling\");\n                clearTimeout(scrollFinish)\n                scrollFinish = setTimeout(() => {\n                    // console.log(\"Not scrolling anymore\");\n                    if (event.deltaY < 0) {\n                        console.log(\"Scrolled up\");\n                    } else {\n                        console.log(\"Scrolled down\");\n                    }\n                }, SCROLL_WAIT);\n            }}/>\n        </div>\n    );\n}\n\nexport default Route;"]},"metadata":{},"sourceType":"module"}