{"ast":null,"code":"var _jsxFileName = \"/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js\",\n    _s = $RefreshSig$();\n\nimport './App.css';\nimport TextBox from \"./TextBox\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport axios from 'axios';\nimport { AwesomeButton } from \"react-awesome-button\";\nimport \"react-awesome-button/dist/styles.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Route() {\n  _s();\n\n  const [startLat, setStartLat] = useState(0);\n  const [startLon, setStartLon] = useState(0);\n  const [destLat, setDestLat] = useState(0);\n  const [destLon, setDestLon] = useState(0);\n  const [route, setRoute] = useState([]); //const [ways, setWays] = useState([]);\n\n  const CANVAS_SIDE_LENGTH = 450;\n  const SCROLL_WAIT = 40;\n  const CLICK_RANGE = 5; //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n  // are implemented\n\n  let leftLat = 41.833038;\n  let topLon = -71.411957;\n  let latLonRange = 0.031275;\n  let mouseDownX;\n  let mouseDownY; // So in order to render the starting map, it'll have to render 64 tiles, I think\n  // On Brown campus, that gives approximately 4,500 ways in just one tile...\n  // We expect latitudes within the map range to be LESS than the leftLat\n  // We expect longitudes within the map range to be GREATER than the topLon\n  // In order to get rightLat or bottomLon, just subtract latLonRange from leftLat, or add it to topLon\n  // But for testing purposes, unless the above values are changed:\n  // rightLat = 41.801763\n  // bottomLon = -71.380682\n\n  const TILE_WIDTH = 0.003909375; // one eighth of starting latLonRange\n\n  let leftmostTileLat = leftLat;\n  let highestTileLon = topLon;\n  let rightmostTileLat = leftmostTileLat;\n  let lowestTileLon = highestTileLon;\n  let tilesLoaded = []; // Tiles should be JavaScript objects with properties leftLat, topLon, and an [] of ways\n  // Ways should be length-4 list of Doubles? [lat1, lon1, lat2, lon2]?\n\n  const canvasRef = useRef();\n  let ctxRef = useRef();\n  /**\n   * Makes an axios request.\n   */\n\n  const requestRoute = () => {\n    const toSend = {\n      srclat: startLat,\n      srclong: startLon,\n      destlat: destLat,\n      destlong: destLon\n    }; //console.log(toSend);\n\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    }; //Install and import this!\n\n    axios.post(\"http://localhost:4567/route\", toSend, config).then(response => {\n      console.log(response.data); // TODO: make sure that the \"route\" here corresponds to the correct data we want back\n\n      setRoute(response.data[\"route\"]);\n    }).catch(function (error) {\n      console.log(error);\n    });\n  };\n  /**\n   * Code to run when the page loads\n   */\n\n\n  useEffect(() => {\n    //console.log(\"page loaded!\");\n    const canvas = canvasRef.current;\n    canvas.width = CANVAS_SIDE_LENGTH;\n    canvas.height = CANVAS_SIDE_LENGTH;\n    ctxRef.current = canvas.getContext(\"2d\"); // let ctx = ctxRef.current;\n    // ctx.fillStyle = \"green\";\n    // ctx.fillRect(0, 0, 100, 100);\n    // Load tiles\n\n    loadStartingTiles();\n  }, []);\n\n  function loadStartingTiles() {\n    console.log(\"Loading starting tiles\");\n    const boundaries = getMapBoundaries();\n    loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n  }\n\n  async function loadTilesWithin(leftLatLimit, topLonLimit, rightLatLimit, bottomLonLimit) {\n    if (leftLatLimit > leftmostTileLat) {\n      leftmostTileLat = leftLatLimit;\n    }\n\n    if (topLonLimit < highestTileLon) {\n      highestTileLon = topLonLimit;\n    }\n\n    let newTile;\n    let curLat = leftLatLimit;\n    let curLon = topLonLimit; //requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n    //drawTile()\n\n    while (curLon < bottomLonLimit) {\n      while (curLat > rightLatLimit) {\n        //get ways and maybe it updates the state of the ways variable?\n        //i dont know if this should be a function or not\n        //requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n        const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH)); //console.log(ways);\n\n        newTile = {\n          \"tileLat\": curLat,\n          \"tileLon\": curLon,\n          \"ways\": ways,\n          \"name\": Math.round(Math.random() * 100)\n        }; //is it supposed to be called setWays or ways here?\n\n        drawTile(newTile); // TODO: here, \"ways\" should hold a list of ways within the tile range\n        // NOTE: you can get lat1/lon1 lat2/lon2 coordinates for the tile\n        // by calling getBoudingBox(tileLat, tileLon, TILE_WIDTH);\n        // TODO: drawTile might want to call the eventual method for drawing ways\n        // console.log(newTile);\n\n        tilesLoaded.push(newTile);\n        curLat -= TILE_WIDTH;\n        return;\n      }\n\n      if (curLat < rightmostTileLat) {\n        rightmostTileLat = curLat;\n      }\n\n      curLat = leftLatLimit;\n      curLon += TILE_WIDTH;\n    }\n\n    if (curLon > lowestTileLon) {\n      lowestTileLon = curLon;\n    }\n  } //uses post request to get ways within bounding box\n  //todo something is going on here\n\n\n  async function requestWays(coordinates) {\n    const toSend = {\n      lat1: coordinates[0],\n      long1: coordinates[1],\n      lat2: coordinates[2],\n      long2: coordinates[3]\n    }; //console.log(\"this is what is getting passed to the post request\")\n    //console.log(toSend);\n\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    const res = await axios.post(\"http://localhost:4567/ways\", toSend, config); // console.log(res);\n    // console.log(res[\"data\"])\n    //const data = await res.json();\n    //console.log(data);\n\n    return res[\"data\"][\"ways\"]; // .then(response => {\n    //     //console.log(response.data);\n    //     //setWays(response.data[\"ways\"]);\n    //     return response.data[\"ways\"];\n    // })\n    // .catch(function (error) {\n    //     console.error(error.response.data);\n    // });\n  }\n\n  function clearLoadTiles() {\n    clearCanvas(); // First, purge old tiles\n\n    const mapBoundaries = getMapBoundaries();\n    const rightLat = mapBoundaries[2];\n    const bottomLon = mapBoundaries[3];\n    let saveTiles = []; // Iterate over all the loaded tiles and see if they're still useful\n\n    for (let i = 0; i < tilesLoaded.length; i++) {\n      const checkTile = tilesLoaded[i];\n      const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n      const tileLeftLat = tileBoundaries[0];\n      const tileTopLon = tileBoundaries[1];\n      const tileRightLat = tileBoundaries[2];\n      const tileBottomLon = tileBoundaries[3]; // We expect latitudes within the map range to be LESS than the leftLat\n      // We expect longitudes within the map range to be GREATER than the topLon\n\n      const deleteTile = tileRightLat > leftLat || tileLeftLat < rightLat || tileBottomLon < topLon || tileTopLon > bottomLon; // const keepTileLeftRight = (tileRightLat < leftLat) || (tileLeftLat > rightLat);\n      // if (tileRightLat > leftLat) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the left side\");\n      // }\n      // const keepTileUpDown = (tileBottomLon > topLon) || (tileTopLon < bottomLon);\n      // if (tileTopLon > bottomLon) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n      // }\n      // let keepTile = keepTileLeftRight && keepTileUpDown;\n\n      if (!deleteTile) {\n        drawTile(tilesLoaded[i]);\n        saveTiles.push(checkTile);\n      }\n    }\n\n    tilesLoaded = saveTiles; // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n\n    while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[2] > leftLat) {\n      //console.log(\"adjusting loaded left boundary\");\n      leftmostTileLat -= TILE_WIDTH;\n    }\n\n    while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[3] < topLon) {\n      //console.log(\"adjusting loaded top boundary\");\n      highestTileLon += TILE_WIDTH;\n    }\n\n    while (rightmostTileLat < rightLat) {\n      //console.log(\"adjusting loaded right boundary\");\n      rightmostTileLat += TILE_WIDTH;\n    }\n\n    while (lowestTileLon > bottomLon) {\n      //console.log(\"adjusting loaded bottom boundary\");\n      lowestTileLon -= TILE_WIDTH;\n    } // Now, load new tiles\n\n\n    while (leftmostTileLat < leftLat) {\n      //console.log(\"gap at left\");\n      loadTilesWithin(leftmostTileLat + TILE_WIDTH, highestTileLon, leftmostTileLat, lowestTileLon); //leftmostTileLat += TILE_WIDTH;\n    }\n\n    while (rightmostTileLat > rightLat) {\n      //console.log(\"gap at right\");\n      loadTilesWithin(rightmostTileLat, highestTileLon, rightmostTileLat - TILE_WIDTH, lowestTileLon);\n    }\n\n    while (highestTileLon > topLon) {\n      //console.log(\"gap at top\");\n      loadTilesWithin(leftmostTileLat, highestTileLon - TILE_WIDTH, rightmostTileLat, highestTileLon);\n    }\n\n    while (lowestTileLon < bottomLon) {\n      //console.log(\"gap at bottom\");\n      loadTilesWithin(leftmostTileLat, lowestTileLon, rightmostTileLat, lowestTileLon + TILE_WIDTH);\n    } //console.log(tilesLoaded.length);\n    //drawLoadedRect();\n\n  }\n\n  function drawLoadedRect() {\n    const ctx = ctxRef.current;\n    const loadedPixBoxTopLeft = latLonCoordToPix(leftmostTileLat, highestTileLon);\n    const loadedPixBoxBottomRight = latLonCoordToPix(rightmostTileLat, lowestTileLon);\n    const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n    const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n    ctx.strokeStyle = \"red\";\n    ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n  }\n  /**\n   * Code to turn lon/lat coordinates into pixel coordinates for the canvas:\n   * takes in a latitude and longitude coordinate, returns a length-2 list with the\n   * corresponding pixel position on the canvas [left, top]\n   * @param lat - the latitude coordinate to turn into a pixel left coordinate\n   * @param lon - the longitude coordinate to turn into a pixel top coordinate\n   * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n   */\n\n\n  function latLonCoordToPix(lat, lon) {\n    const normalizedLat = leftLat - lat;\n    const normalizedLon = lon - topLon; // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n    // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    return [pixIfy(normalizedLat), pixIfy(normalizedLon)];\n  }\n  /**\n   * Turns a latitude/longitude coordinate value into a pixel value.\n   * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n   * @returns {number} the pixel conversion of the lat/lon value\n   */\n\n\n  function pixIfy(latLonVal) {\n    const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n    return latLonVal * pixOverLatLonFactor;\n  }\n  /**\n   * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n   * and longitude coordinate\n   * Returns a length-2 list with [lat, lon]\n   * @param left - the pixel left coordinate to turn into map latitude\n   * @param top - the pixel top coordinate to turn into map longitude\n   * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n   */\n\n\n  function pixCoordToLatLon(left, top) {\n    const canvas = canvasRef.current;\n    const normalizedLeft = left - canvas.offsetLeft;\n    const normalizedTop = top - canvas.offsetTop; // console.log(normalizedLeft + \", \" + normalizedTop);\n    // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n    const returnLat = leftLat - latLonIfy(normalizedLeft);\n    const returnLon = topLon + latLonIfy(normalizedTop); // console.log(returnLat, \", \", returnLon)\n    // console.log(latLonCoordToPix(returnLat, returnLon));\n\n    return [returnLat, returnLon];\n  }\n  /**\n   * Turns a value in pixels into a value in latitude/longitude coordinates.\n   * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n   * @returns {number} the lat/lon conversion of the pixel value\n   */\n\n\n  function latLonIfy(pixVal) {\n    const latLonOverPixFactor = latLonRange / CANVAS_SIDE_LENGTH;\n    return pixVal * latLonOverPixFactor;\n  }\n  /**\n   * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n   * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of the current map frame.\n   */\n\n\n  function getMapBoundaries() {\n    return getBoundingBox(leftLat, topLon, latLonRange);\n  }\n  /**\n   * Get the lat/lon boundaries of a passed square area with unknown side length.\n   * @param boxLeftLat latitude coordinate of the northwest corner\n   * @param boxTopLon longitude coordinate of the northwest corner\n   * @param boxRange side length, in terms of lat/lon coordinates\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of a passed square.\n   */\n\n\n  function getBoundingBox(boxLeftLat, boxTopLon, boxRange) {\n    return [boxLeftLat, boxTopLon, boxLeftLat - boxRange, boxTopLon + boxRange];\n  } // console.log(latLonCoordToPix(41.801763, -71.380682));\n\n\n  function handleClickOrDrag(mouseUpX, mouseUpY) {\n    const xChange = mouseUpX - mouseDownX;\n    const yChange = mouseDownY - mouseUpY; // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n      console.log(\"Clicked!\");\n      const ctx = ctxRef.current;\n      ctx.fillStyle = \"green\"; //TODO: insert the nearest call here\n    } else {\n      console.log(\"Dragged!\"); // console.log(xChange, yChange);\n      //console.log(latLonIfy(xChange), latLonIfy(yChange));\n      //console.log(leftLat + \", \" + topLon);\n      // TODO: this may want to get changed to a setParamName() function call when setState is used\n\n      leftLat += latLonIfy(xChange);\n      topLon += latLonIfy(yChange); //console.log(leftLat + \", \" + topLon);\n\n      clearLoadTiles();\n    }\n  }\n\n  function clearCanvas() {\n    const ctx = ctxRef.current;\n    const canvas = canvasRef.current;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  function drawTile(tileToDraw) {\n    //console.log(\"drawing tile\");\n    // console.log(tileToDraw);\n    // const ctx = ctxRef.current;\n    // ctx.fillStyle = \"lightgreen\";\n    // const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n    // const baseX = tileCoord[0];\n    // const baseY = tileCoord[1];\n    //\n    // const pixTileWidth = pixIfy(TILE_WIDTH);\n    // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n    //      Math.min(baseX + pixTileWidth, pixTileWidth),\n    //      Math.min(baseY + pixTileWidth, pixTileWidth));\n    //  ctx.strokeStyle = \"black\";\n    //  ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n    //      Math.min(baseX + pixTileWidth, pixTileWidth),\n    //      Math.min(baseY + pixTileWidth, pixTileWidth));\n    //  ctx.fillStyle = \"black\";\n    // ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n    //console.log(tileToDraw);\n    //console.log(tileToDraw[\"ways\"]);\n    tileToDraw[\"ways\"].forEach(traceWay);\n  } // function drawWays(tileToDraw) {\n  //     const canvas = $('#canvas')[0]; // Getting a reference to the <canvas> element that has an ID of 'canvas'\n  //     canvas.width = TILE_WIDTH;\n  //     canvas.height = TILE_WIDTH;\n  //     tileToDraw.ways.forEach(traceWay)\n  // }\n\n\n  function traceWay(way) {\n    console.log(way); //probably should change wayslist into a hashmap\n\n    const ctx = ctxRef.current;\n    const canvas = canvasRef.current; //let c = document.getElementById(\"myCanvas\");\n    //let ctx = c.getContext(\"2d\");\n\n    let startLatCoord = way[\"startLat\"];\n    let startLonCoord = way[\"startLong\"];\n    let pixStart = latLonCoordToPix(startLatCoord, startLonCoord); //console.log(pixStart)\n\n    ctx.fillStyle = \"black\";\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(pixStart[0], pixStart[1]);\n    let endLatCoord = way[\"destLat\"]; //console.log(endLatCoord)\n\n    let endLongCoord = way[\"destLong\"]; //console.log(endLongCoord)\n\n    let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord);\n    console.log(pixEnd);\n    ctx.lineTo(pixEnd[0], pixEnd[1]);\n    ctx.stroke();\n  }\n\n  let scrollFinish;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Test title\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 449,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Latitude\",\n      change: setStartLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 450,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Longitude\",\n      change: setStartLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 451,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Latitude\",\n      change: setDestLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 452,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Longitude\",\n      change: setDestLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 453,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(AwesomeButton, {\n      type: \"primary\",\n      onPress: requestRoute,\n      children: \"Submit!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 454,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 455,\n      columnNumber: 13\n    }, this), route.map((coord, index) => /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [coord[0], \", \", coord[1]]\n    }, index, true, {\n      fileName: _jsxFileName,\n      lineNumber: 457,\n      columnNumber: 17\n    }, this)), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      onMouseDown: event => {\n        mouseDownX = event.pageX;\n        mouseDownY = event.pageY;\n      },\n      onMouseUp: event => {\n        //pixCoordToLatLon(event.pageX, event.pageY);\n        handleClickOrDrag(event.pageX, event.pageY);\n      },\n      onWheel: event => {\n        event.stopPropagation(); // console.log(\"scrolling\");\n\n        clearTimeout(scrollFinish);\n        scrollFinish = setTimeout(() => {\n          // console.log(\"Not scrolling anymore\");\n          if (event.deltaY < 0) {\n            console.log(\"Scrolled up\");\n          } else {\n            console.log(\"Scrolled down\");\n          }\n        }, SCROLL_WAIT);\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 459,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 448,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Route, \"oMsN6JFjd0Rg09WLtcTIh6Wt6/w=\");\n\n_c = Route;\nexport default Route;\n\nvar _c;\n\n$RefreshReg$(_c, \"Route\");","map":{"version":3,"sources":["/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js"],"names":["TextBox","React","useState","useEffect","useRef","axios","AwesomeButton","Route","startLat","setStartLat","startLon","setStartLon","destLat","setDestLat","destLon","setDestLon","route","setRoute","CANVAS_SIDE_LENGTH","SCROLL_WAIT","CLICK_RANGE","leftLat","topLon","latLonRange","mouseDownX","mouseDownY","TILE_WIDTH","leftmostTileLat","highestTileLon","rightmostTileLat","lowestTileLon","tilesLoaded","canvasRef","ctxRef","requestRoute","toSend","srclat","srclong","destlat","destlong","config","headers","post","then","response","console","log","data","catch","error","canvas","current","width","height","getContext","loadStartingTiles","boundaries","getMapBoundaries","loadTilesWithin","leftLatLimit","topLonLimit","rightLatLimit","bottomLonLimit","newTile","curLat","curLon","ways","requestWays","getBoundingBox","Math","round","random","drawTile","push","coordinates","lat1","long1","lat2","long2","res","clearLoadTiles","clearCanvas","mapBoundaries","rightLat","bottomLon","saveTiles","i","length","checkTile","tileBoundaries","tileLeftLat","tileTopLon","tileRightLat","tileBottomLon","deleteTile","drawLoadedRect","ctx","loadedPixBoxTopLeft","latLonCoordToPix","loadedPixBoxBottomRight","loadedPixBoxWidth","loadedPixBoxHeight","strokeStyle","strokeRect","lat","lon","normalizedLat","normalizedLon","pixIfy","latLonVal","pixOverLatLonFactor","pixCoordToLatLon","left","top","normalizedLeft","offsetLeft","normalizedTop","offsetTop","returnLat","latLonIfy","returnLon","pixVal","latLonOverPixFactor","boxLeftLat","boxTopLon","boxRange","handleClickOrDrag","mouseUpX","mouseUpY","xChange","yChange","abs","fillStyle","clearRect","tileToDraw","forEach","traceWay","way","startLatCoord","startLonCoord","pixStart","lineWidth","beginPath","moveTo","endLatCoord","endLongCoord","pixEnd","lineTo","stroke","scrollFinish","map","coord","index","event","pageX","pageY","stopPropagation","clearTimeout","setTimeout","deltaY"],"mappings":"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","sourcesContent":["import './App.css';\nimport TextBox from \"./TextBox\";\nimport React, {useState, useEffect, useRef} from 'react';\nimport axios from 'axios';\nimport { AwesomeButton } from \"react-awesome-button\";\nimport \"react-awesome-button/dist/styles.css\";\n\nfunction Route() {\n    const [startLat, setStartLat] = useState(0);\n    const [startLon, setStartLon] = useState(0);\n    const [destLat, setDestLat] = useState(0);\n    const [destLon, setDestLon] = useState(0);\n    const [route, setRoute] = useState([]);\n    //const [ways, setWays] = useState([]);\n    const CANVAS_SIDE_LENGTH = 450;\n    const SCROLL_WAIT = 40;\n    const CLICK_RANGE = 5;\n    //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n    // are implemented\n    let leftLat = 41.833038;\n    let topLon = -71.411957;\n    let latLonRange = 0.031275;\n    let mouseDownX;\n    let mouseDownY;\n    // So in order to render the starting map, it'll have to render 64 tiles, I think\n    // On Brown campus, that gives approximately 4,500 ways in just one tile...\n\n    // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    // In order to get rightLat or bottomLon, just subtract latLonRange from leftLat, or add it to topLon\n    // But for testing purposes, unless the above values are changed:\n    // rightLat = 41.801763\n    // bottomLon = -71.380682\n\n    const TILE_WIDTH = 0.003909375; // one eighth of starting latLonRange\n    let leftmostTileLat = leftLat;\n    let highestTileLon = topLon;\n    let rightmostTileLat = leftmostTileLat;\n    let lowestTileLon = highestTileLon;\n    let tilesLoaded = [];\n    // Tiles should be JavaScript objects with properties leftLat, topLon, and an [] of ways\n    // Ways should be length-4 list of Doubles? [lat1, lon1, lat2, lon2]?\n\n\n    const canvasRef = useRef();\n    let ctxRef = useRef();\n\n    /**\n     * Makes an axios request.\n     */\n    const requestRoute = () => {\n        const toSend = {\n            srclat: startLat,\n            srclong: startLon,\n            destlat: destLat,\n            destlong: destLon\n        };\n        //console.log(toSend);\n\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n\n        //Install and import this!\n        axios.post(\n            \"http://localhost:4567/route\",\n            toSend,\n            config\n        )\n            .then(response => {\n                console.log(response.data);\n                // TODO: make sure that the \"route\" here corresponds to the correct data we want back\n                setRoute(response.data[\"route\"]);\n            })\n            .catch(function (error) {\n                console.log(error);\n            });\n    }\n\n    /**\n     * Code to run when the page loads\n     */\n    useEffect(() => {\n        //console.log(\"page loaded!\");\n        const canvas = canvasRef.current;\n        canvas.width = CANVAS_SIDE_LENGTH;\n        canvas.height = CANVAS_SIDE_LENGTH;\n        ctxRef.current = canvas.getContext(\"2d\");\n        // let ctx = ctxRef.current;\n        // ctx.fillStyle = \"green\";\n        // ctx.fillRect(0, 0, 100, 100);\n\n        // Load tiles\n        loadStartingTiles();\n    }, []);\n\n    function loadStartingTiles() {\n        console.log(\"Loading starting tiles\");\n        const boundaries = getMapBoundaries();\n        loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n    }\n\n    async function loadTilesWithin(leftLatLimit, topLonLimit, rightLatLimit, bottomLonLimit) {\n        if (leftLatLimit > leftmostTileLat) {\n            leftmostTileLat = leftLatLimit;\n        }\n        if (topLonLimit < highestTileLon) {\n            highestTileLon = topLonLimit;\n        }\n        let newTile;\n        let curLat = leftLatLimit;\n        let curLon = topLonLimit;\n        //requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n        //drawTile()\n        while (curLon < bottomLonLimit) {\n            while (curLat > rightLatLimit) {\n                //get ways and maybe it updates the state of the ways variable?\n                //i dont know if this should be a function or not\n                //requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n                const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n                //console.log(ways);\n                newTile = {\"tileLat\": curLat, \"tileLon\": curLon, \"ways\": ways, \"name\":Math.round(Math.random()*100)};\n                //is it supposed to be called setWays or ways here?\n                drawTile(newTile);\n                // TODO: here, \"ways\" should hold a list of ways within the tile range\n                // NOTE: you can get lat1/lon1 lat2/lon2 coordinates for the tile\n                // by calling getBoudingBox(tileLat, tileLon, TILE_WIDTH);\n\n                // TODO: drawTile might want to call the eventual method for drawing ways\n\n                // console.log(newTile);\n                tilesLoaded.push(newTile);\n                curLat -= TILE_WIDTH;\n                return;\n            }\n            if (curLat < rightmostTileLat) {\n                rightmostTileLat = curLat;\n            }\n            curLat = leftLatLimit;\n            curLon += TILE_WIDTH;\n        }\n        if (curLon > lowestTileLon) {\n            lowestTileLon = curLon;\n        }\n    }\n\n    //uses post request to get ways within bounding box\n    //todo something is going on here\n        async function requestWays(coordinates) {\n            const toSend = {\n                lat1: coordinates[0],\n                long1: coordinates[1],\n                lat2: coordinates[2],\n                long2: coordinates[3]\n            };\n            //console.log(\"this is what is getting passed to the post request\")\n            //console.log(toSend);\n\n            let config = {\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    'Access-Control-Allow-Origin': '*',\n                }\n            }\n            const res = await axios.post(\n                \"http://localhost:4567/ways\",\n                toSend,\n                config\n            );\n            // console.log(res);\n            // console.log(res[\"data\"])\n            //const data = await res.json();\n            //console.log(data);\n            return res[\"data\"][\"ways\"];\n                // .then(response => {\n                //     //console.log(response.data);\n                //     //setWays(response.data[\"ways\"]);\n                //     return response.data[\"ways\"];\n                // })\n                // .catch(function (error) {\n                //     console.error(error.response.data);\n                // });\n        }\n    function clearLoadTiles() {\n        clearCanvas();\n\n        // First, purge old tiles\n        const mapBoundaries = getMapBoundaries();\n        const rightLat = mapBoundaries[2];\n        const bottomLon = mapBoundaries[3];\n        let saveTiles = [];\n        // Iterate over all the loaded tiles and see if they're still useful\n        for (let i = 0; i < tilesLoaded.length; i++) {\n            const checkTile = tilesLoaded[i];\n            const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n            const tileLeftLat = tileBoundaries[0];\n            const tileTopLon = tileBoundaries[1];\n            const tileRightLat = tileBoundaries[2];\n            const tileBottomLon = tileBoundaries[3];\n            // We expect latitudes within the map range to be LESS than the leftLat\n            // We expect longitudes within the map range to be GREATER than the topLon\n            const deleteTile = (tileRightLat > leftLat) || (tileLeftLat < rightLat)\n                || (tileBottomLon < topLon) || (tileTopLon > bottomLon);\n            // const keepTileLeftRight = (tileRightLat < leftLat) || (tileLeftLat > rightLat);\n            // if (tileRightLat > leftLat) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the left side\");\n            // }\n            // const keepTileUpDown = (tileBottomLon > topLon) || (tileTopLon < bottomLon);\n            // if (tileTopLon > bottomLon) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n            // }\n            // let keepTile = keepTileLeftRight && keepTileUpDown;\n            if (!deleteTile) {\n                drawTile(tilesLoaded[i]);\n                saveTiles.push(checkTile);\n            }\n        }\n        tilesLoaded = saveTiles;\n\n        // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n        while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[2] > leftLat){\n            //console.log(\"adjusting loaded left boundary\");\n            leftmostTileLat -= TILE_WIDTH;\n        }\n        while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[3] < topLon){\n            //console.log(\"adjusting loaded top boundary\");\n            highestTileLon += TILE_WIDTH;\n        }\n        while (rightmostTileLat < rightLat){\n            //console.log(\"adjusting loaded right boundary\");\n            rightmostTileLat += TILE_WIDTH;\n        }\n        while (lowestTileLon > bottomLon){\n            //console.log(\"adjusting loaded bottom boundary\");\n            lowestTileLon -= TILE_WIDTH;\n        }\n\n        // Now, load new tiles\n        while (leftmostTileLat < leftLat) {\n            //console.log(\"gap at left\");\n            loadTilesWithin(leftmostTileLat + TILE_WIDTH, highestTileLon, leftmostTileLat, lowestTileLon);\n            //leftmostTileLat += TILE_WIDTH;\n        }\n        while (rightmostTileLat > rightLat) {\n            //console.log(\"gap at right\");\n            loadTilesWithin(rightmostTileLat, highestTileLon, rightmostTileLat - TILE_WIDTH, lowestTileLon);\n        }\n        while (highestTileLon > topLon) {\n            //console.log(\"gap at top\");\n            loadTilesWithin(leftmostTileLat, highestTileLon - TILE_WIDTH, rightmostTileLat, highestTileLon);\n        }\n        while (lowestTileLon < bottomLon) {\n            //console.log(\"gap at bottom\");\n            loadTilesWithin(leftmostTileLat, lowestTileLon, rightmostTileLat, lowestTileLon + TILE_WIDTH);\n        }\n        //console.log(tilesLoaded.length);\n        //drawLoadedRect();\n    }\n\n    function drawLoadedRect(){\n        const ctx = ctxRef.current;\n        const loadedPixBoxTopLeft = latLonCoordToPix(leftmostTileLat, highestTileLon);\n        const loadedPixBoxBottomRight = latLonCoordToPix(rightmostTileLat, lowestTileLon);\n        const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n        const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n        ctx.strokeStyle = \"red\";\n        ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n    }\n\n    /**\n     * Code to turn lon/lat coordinates into pixel coordinates for the canvas:\n     * takes in a latitude and longitude coordinate, returns a length-2 list with the\n     * corresponding pixel position on the canvas [left, top]\n     * @param lat - the latitude coordinate to turn into a pixel left coordinate\n     * @param lon - the longitude coordinate to turn into a pixel top coordinate\n     * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n     */\n    function latLonCoordToPix(lat, lon) {\n        const normalizedLat = leftLat - lat;\n        const normalizedLon = lon - topLon;\n        // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n        // We expect latitudes within the map range to be LESS than the leftLat\n        // We expect longitudes within the map range to be GREATER than the topLon\n\n        return [pixIfy(normalizedLat), pixIfy(normalizedLon)];\n    }\n\n    /**\n     * Turns a latitude/longitude coordinate value into a pixel value.\n     * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n     * @returns {number} the pixel conversion of the lat/lon value\n     */\n    function pixIfy(latLonVal) {\n        const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n        return latLonVal * pixOverLatLonFactor;\n    }\n\n    /**\n     * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n     * and longitude coordinate\n     * Returns a length-2 list with [lat, lon]\n     * @param left - the pixel left coordinate to turn into map latitude\n     * @param top - the pixel top coordinate to turn into map longitude\n     * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n     */\n    function pixCoordToLatLon(left, top) {\n        const canvas = canvasRef.current;\n        const normalizedLeft = left - canvas.offsetLeft;\n        const normalizedTop = top - canvas.offsetTop;\n        // console.log(normalizedLeft + \", \" + normalizedTop);\n        // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n        const returnLat = leftLat - latLonIfy(normalizedLeft);\n        const returnLon = topLon + latLonIfy(normalizedTop);\n        // console.log(returnLat, \", \", returnLon)\n        // console.log(latLonCoordToPix(returnLat, returnLon));\n        return [returnLat, returnLon];\n    }\n\n    /**\n     * Turns a value in pixels into a value in latitude/longitude coordinates.\n     * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n     * @returns {number} the lat/lon conversion of the pixel value\n     */\n    function latLonIfy(pixVal) {\n        const latLonOverPixFactor =  latLonRange / CANVAS_SIDE_LENGTH;\n        return pixVal * latLonOverPixFactor;\n    }\n\n    /**\n     * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n     * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of the current map frame.\n     */\n    function getMapBoundaries() {\n        return getBoundingBox(leftLat, topLon, latLonRange);\n    }\n\n    /**\n     * Get the lat/lon boundaries of a passed square area with unknown side length.\n     * @param boxLeftLat latitude coordinate of the northwest corner\n     * @param boxTopLon longitude coordinate of the northwest corner\n     * @param boxRange side length, in terms of lat/lon coordinates\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of a passed square.\n     */\n    function getBoundingBox(boxLeftLat, boxTopLon, boxRange) {\n        return [boxLeftLat, boxTopLon, boxLeftLat - boxRange, boxTopLon + boxRange];\n    }\n\n    // console.log(latLonCoordToPix(41.801763, -71.380682));\n\n    function handleClickOrDrag(mouseUpX, mouseUpY) {\n        const xChange = mouseUpX - mouseDownX;\n        const yChange = mouseDownY - mouseUpY;\n        // We expect latitudes within the map range to be LESS than the leftLat\n        // We expect longitudes within the map range to be GREATER than the topLon\n\n        if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n            console.log(\"Clicked!\");\n            const ctx = ctxRef.current;\n            ctx.fillStyle = \"green\";\n\n            //TODO: insert the nearest call here\n        } else {\n            console.log(\"Dragged!\");\n            // console.log(xChange, yChange);\n            //console.log(latLonIfy(xChange), latLonIfy(yChange));\n            //console.log(leftLat + \", \" + topLon);\n            // TODO: this may want to get changed to a setParamName() function call when setState is used\n            leftLat += latLonIfy(xChange);\n            topLon += latLonIfy(yChange);\n            //console.log(leftLat + \", \" + topLon);\n            clearLoadTiles();\n        }\n    }\n\n    function clearCanvas() {\n        const ctx = ctxRef.current;\n        const canvas = canvasRef.current;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    function drawTile(tileToDraw) {\n        //console.log(\"drawing tile\");\n        // console.log(tileToDraw);\n        // const ctx = ctxRef.current;\n        // ctx.fillStyle = \"lightgreen\";\n        // const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n        // const baseX = tileCoord[0];\n        // const baseY = tileCoord[1];\n        //\n        // const pixTileWidth = pixIfy(TILE_WIDTH);\n        // ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n        //      Math.min(baseX + pixTileWidth, pixTileWidth),\n        //      Math.min(baseY + pixTileWidth, pixTileWidth));\n        //  ctx.strokeStyle = \"black\";\n        //  ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n        //      Math.min(baseX + pixTileWidth, pixTileWidth),\n        //      Math.min(baseY + pixTileWidth, pixTileWidth));\n        //  ctx.fillStyle = \"black\";\n        // ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n        //console.log(tileToDraw);\n        //console.log(tileToDraw[\"ways\"]);\n        tileToDraw[\"ways\"].forEach(traceWay);\n    }\n\n    // function drawWays(tileToDraw) {\n    //     const canvas = $('#canvas')[0]; // Getting a reference to the <canvas> element that has an ID of 'canvas'\n    //     canvas.width = TILE_WIDTH;\n    //     canvas.height = TILE_WIDTH;\n    //     tileToDraw.ways.forEach(traceWay)\n    // }\n\n    function traceWay(way) {\n        console.log(way)\n        //probably should change wayslist into a hashmap\n        const ctx = ctxRef.current;\n        const canvas = canvasRef.current;\n        //let c = document.getElementById(\"myCanvas\");\n        //let ctx = c.getContext(\"2d\");\n        let startLatCoord = way[\"startLat\"]\n        let startLonCoord = way[\"startLong\"]\n        let pixStart = latLonCoordToPix(startLatCoord, startLonCoord)\n        //console.log(pixStart)\n        ctx.fillStyle = \"black\";\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(pixStart[0], pixStart[1])\n        let endLatCoord = way[\"destLat\"]\n        //console.log(endLatCoord)\n        let endLongCoord = way[\"destLong\"]\n        //console.log(endLongCoord)\n        let pixEnd = latLonCoordToPix(endLatCoord, endLongCoord)\n        console.log(pixEnd)\n        ctx.lineTo(pixEnd[0], pixEnd[1])\n        ctx.stroke();\n    }\n\n    let scrollFinish;\n\n    return (\n        <div>\n            <h1>Test title</h1>\n            <TextBox label={\"Source Latitude\"} change={setStartLat}/>\n            <TextBox label={\"Source Longitude\"} change={setStartLon}/>\n            <TextBox label={\"Destination Latitude\"} change={setDestLat}/>\n            <TextBox label={\"Destination Longitude\"} change={setDestLon}/>\n            <AwesomeButton type=\"primary\" onPress={requestRoute}>Submit!</AwesomeButton>\n            <br/>\n            {route.map((coord, index) =>\n                <p key={index}>{coord[0]}, {coord[1]}</p>\n            )}\n            <canvas ref={canvasRef} onMouseDown={(event) => {\n                mouseDownX = event.pageX;\n                mouseDownY = event.pageY;\n            }} onMouseUp={(event) => {\n                //pixCoordToLatLon(event.pageX, event.pageY);\n                handleClickOrDrag(event.pageX, event.pageY);\n            }} onWheel={(event) => {\n                event.stopPropagation();\n                // console.log(\"scrolling\");\n                clearTimeout(scrollFinish)\n                scrollFinish = setTimeout(() => {\n                    // console.log(\"Not scrolling anymore\");\n                    if (event.deltaY < 0) {\n                        console.log(\"Scrolled up\");\n                    } else {\n                        console.log(\"Scrolled down\");\n                    }\n                }, SCROLL_WAIT);\n            }}/>\n        </div>\n    );\n}\n\nexport default Route;"]},"metadata":{},"sourceType":"module"}