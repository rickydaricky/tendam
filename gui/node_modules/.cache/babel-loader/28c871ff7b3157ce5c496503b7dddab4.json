{"ast":null,"code":"var _jsxFileName = \"/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js\",\n    _s = $RefreshSig$();\n\nimport './App.css';\nimport TextBox from \"./TextBox\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport axios from 'axios';\nimport { AwesomeButton } from \"react-awesome-button\";\nimport \"react-awesome-button/dist/styles.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Route() {\n  _s();\n\n  const [startLat, setStartLat] = useState(0);\n  const [startLon, setStartLon] = useState(0);\n  const [destLat, setDestLat] = useState(0);\n  const [destLon, setDestLon] = useState(0);\n  const [route, setRoute] = useState([]);\n  const CANVAS_SIDE_LENGTH = 450;\n  const SCROLL_WAIT = 40;\n  const CLICK_RANGE = 5; //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n  // are implemented\n\n  let leftLat = 41.833038;\n  let topLon = -71.411957;\n  let latLonRange = 0.031275;\n  let mouseDownX;\n  let mouseDownY; // So in order to render the starting map, it'll have to render 64 tiles, I think\n  // On Brown campus, that gives approximately 4,500 ways in just one tile...\n  // We expect latitudes within the map range to be LESS than the leftLat\n  // We expect longitudes within the map range to be GREATER than the topLon\n  // In order to get rightLat or bottomLon, just subtract latLonRange from leftLat, or add it to topLon\n  // But for testing purposes, unless the above values are changed:\n  // rightLat = 41.801763\n  // bottomLon = -71.380682\n\n  const TILE_WIDTH = 0.003909375; // one eighth of starting latLonRange\n\n  let leftmostTileLat = leftLat;\n  let highestTileLon = topLon;\n  let rightmostTileLat = leftmostTileLat;\n  let lowestTileLon = highestTileLon;\n  let tilesLoaded = []; // Tiles should be JavaScript objects with properties leftLat, topLon, and an [] of ways\n  // Ways should be length-4 list of Doubles? [lat1, lon1, lat2, lon2]?\n\n  const canvasRef = useRef();\n  let ctxRef = useRef();\n  /**\n   * Makes an axios request.\n   */\n\n  const requestRoute = () => {\n    const toSend = {\n      srclat: startLat,\n      srclong: startLon,\n      destlat: destLat,\n      destlong: destLon\n    }; //console.log(toSend);\n\n    let config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    }; //Install and import this!\n\n    axios.post(\"http://localhost:4567/route\", toSend, config).then(response => {\n      console.log(response.data); // TODO: make sure that the \"route\" here corresponds to the correct data we want back\n\n      setRoute(response.data[\"route\"]);\n    }).catch(function (error) {\n      console.log(error);\n    });\n  };\n  /**\n   * Code to run when the page loads\n   */\n\n\n  useEffect(() => {\n    //console.log(\"page loaded!\");\n    const canvas = canvasRef.current;\n    canvas.width = CANVAS_SIDE_LENGTH;\n    canvas.height = CANVAS_SIDE_LENGTH;\n    ctxRef.current = canvas.getContext(\"2d\"); // let ctx = ctxRef.current;\n    // ctx.fillStyle = \"green\";\n    // ctx.fillRect(0, 0, 100, 100);\n    // Load tiles\n\n    loadStartingTiles();\n  }, []);\n\n  function loadStartingTiles() {\n    console.log(\"Loading starting tiles\");\n    const boundaries = getMapBoundaries();\n    loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n  }\n\n  function loadTilesWithin(leftLatLimit, topLonLimit, rightLatLimit, bottomLonLimit) {\n    if (leftLatLimit > leftmostTileLat) {\n      leftmostTileLat = leftLatLimit;\n    }\n\n    if (topLonLimit < highestTileLon) {\n      highestTileLon = topLonLimit;\n    }\n\n    let newTile;\n    let curLat = leftLatLimit;\n    let curLon = topLonLimit;\n\n    while (curLon < bottomLonLimit) {\n      while (curLat > rightLatLimit) {\n        newTile = {\n          \"tileLat\": curLat,\n          \"tileLon\": curLon,\n          \"ways\": [],\n          \"name\": Math.round(Math.random() * 100)\n        };\n        drawTile(newTile); // TODO: here, \"ways\" should hold a list of ways within the tile range\n        // NOTE: you can get lat1/lon1 lat2/lon2 coordinates for the tile\n        // by calling getBoudingBox(tileLat, tileLon, TILE_WIDTH);\n        // TODO: drawTile might want to call the eventual method for drawing ways\n        // console.log(newTile);\n\n        tilesLoaded.push(newTile);\n        curLat -= TILE_WIDTH;\n      }\n\n      if (curLat < rightmostTileLat) {\n        rightmostTileLat = curLat;\n      }\n\n      curLat = leftLatLimit;\n      curLon += TILE_WIDTH;\n    }\n\n    if (curLon > lowestTileLon) {\n      lowestTileLon = curLon;\n    }\n  }\n\n  function clearLoadTiles() {\n    clearCanvas(); // First, purge old tiles\n\n    const mapBoundaries = getMapBoundaries();\n    const rightLat = mapBoundaries[2];\n    const bottomLon = mapBoundaries[3];\n    let saveTiles = []; // Iterate over all the loaded tiles and see if they're still useful\n\n    for (let i = 0; i < tilesLoaded.length; i++) {\n      const checkTile = tilesLoaded[i];\n      const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n      const tileLeftLat = tileBoundaries[0];\n      const tileTopLon = tileBoundaries[1];\n      const tileRightLat = tileBoundaries[2];\n      const tileBottomLon = tileBoundaries[3]; // We expect latitudes within the map range to be LESS than the leftLat\n      // We expect longitudes within the map range to be GREATER than the topLon\n\n      const deleteTile = tileRightLat > leftLat || tileLeftLat < rightLat || tileBottomLon < topLon || tileTopLon > bottomLon; // const keepTileLeftRight = (tileRightLat < leftLat) || (tileLeftLat > rightLat);\n      // if (tileRightLat > leftLat) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the left side\");\n      // }\n      // const keepTileUpDown = (tileBottomLon > topLon) || (tileTopLon < bottomLon);\n      // if (tileTopLon > bottomLon) {\n      //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n      // }\n      // let keepTile = keepTileLeftRight && keepTileUpDown;\n\n      if (!deleteTile) {\n        drawTile(tilesLoaded[i]);\n        saveTiles.push(checkTile);\n      }\n    }\n\n    tilesLoaded = saveTiles; // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n\n    while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[2] > leftLat) {\n      //console.log(\"adjusting loaded left boundary\");\n      leftmostTileLat -= TILE_WIDTH;\n    }\n\n    while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[3] < topLon) {\n      //console.log(\"adjusting loaded top boundary\");\n      highestTileLon += TILE_WIDTH;\n    }\n\n    while (rightmostTileLat < rightLat) {\n      //console.log(\"adjusting loaded right boundary\");\n      rightmostTileLat += TILE_WIDTH;\n    }\n\n    while (lowestTileLon > bottomLon) {\n      //console.log(\"adjusting loaded bottom boundary\");\n      lowestTileLon -= TILE_WIDTH;\n    } // Now, load new tiles\n\n\n    while (leftmostTileLat < leftLat) {\n      //console.log(\"gap at left\");\n      loadTilesWithin(leftmostTileLat + TILE_WIDTH, highestTileLon, leftmostTileLat, lowestTileLon); //leftmostTileLat += TILE_WIDTH;\n    }\n\n    while (rightmostTileLat > rightLat) {\n      //console.log(\"gap at right\");\n      loadTilesWithin(rightmostTileLat, highestTileLon, rightmostTileLat - TILE_WIDTH, lowestTileLon);\n    }\n\n    while (highestTileLon > topLon) {\n      //console.log(\"gap at top\");\n      loadTilesWithin(leftmostTileLat, highestTileLon - TILE_WIDTH, rightmostTileLat, highestTileLon);\n    }\n\n    while (lowestTileLon < bottomLon) {\n      //console.log(\"gap at bottom\");\n      loadTilesWithin(leftmostTileLat, lowestTileLon, rightmostTileLat, lowestTileLon + TILE_WIDTH);\n    } //console.log(tilesLoaded.length);\n    //drawLoadedRect();\n\n  }\n\n  function drawLoadedRect() {\n    const ctx = ctxRef.current;\n    const loadedPixBoxTopLeft = latLonCoordToPix(leftmostTileLat, highestTileLon);\n    const loadedPixBoxBottomRight = latLonCoordToPix(rightmostTileLat, lowestTileLon);\n    const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n    const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n    ctx.strokeStyle = \"red\";\n    ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n  }\n  /**\n   * Code to turn lon/lat coordinates into pixel coordinates for the canvas:\n   * takes in a latitude and longitude coordinate, returns a length-2 list with the\n   * corresponding pixel position on the canvas [left, top]\n   * @param lat - the latitude coordinate to turn into a pixel left coordinate\n   * @param lon - the longitude coordinate to turn into a pixel top coordinate\n   * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n   */\n\n\n  function latLonCoordToPix(lat, lon) {\n    const normalizedLat = leftLat - lat;\n    const normalizedLon = lon - topLon; // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n    // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    return [pixIfy(normalizedLat), pixIfy(normalizedLon)];\n  }\n  /**\n   * Turns a latitude/longitude coordinate value into a pixel value.\n   * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n   * @returns {number} the pixel conversion of the lat/lon value\n   */\n\n\n  function pixIfy(latLonVal) {\n    const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n    return latLonVal * pixOverLatLonFactor;\n  }\n  /**\n   * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n   * and longitude coordinate\n   * Returns a length-2 list with [lat, lon]\n   * @param left - the pixel left coordinate to turn into map latitude\n   * @param top - the pixel top coordinate to turn into map longitude\n   * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n   */\n\n\n  function pixCoordToLatLon(left, top) {\n    const canvas = canvasRef.current;\n    const normalizedLeft = left - canvas.offsetLeft;\n    const normalizedTop = top - canvas.offsetTop; // console.log(normalizedLeft + \", \" + normalizedTop);\n    // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n    const returnLat = leftLat - latLonIfy(normalizedLeft);\n    const returnLon = topLon + latLonIfy(normalizedTop); // console.log(returnLat, \", \", returnLon)\n    // console.log(latLonCoordToPix(returnLat, returnLon));\n\n    return [returnLat, returnLon];\n  }\n  /**\n   * Turns a value in pixels into a value in latitude/longitude coordinates.\n   * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n   * @returns {number} the lat/lon conversion of the pixel value\n   */\n\n\n  function latLonIfy(pixVal) {\n    const latLonOverPixFactor = latLonRange / CANVAS_SIDE_LENGTH;\n    return pixVal * latLonOverPixFactor;\n  }\n  /**\n   * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n   * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of the current map frame.\n   */\n\n\n  function getMapBoundaries() {\n    return getBoundingBox(leftLat, topLon, latLonRange);\n  }\n  /**\n   * Get the lat/lon boundaries of a passed square area with unknown side length.\n   * @param boxLeftLat latitude coordinate of the northwest corner\n   * @param boxTopLon longitude coordinate of the northwest corner\n   * @param boxRange side length, in terms of lat/lon coordinates\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of a passed square.\n   */\n\n\n  function getBoundingBox(boxLeftLat, boxTopLon, boxRange) {\n    return [boxLeftLat, boxTopLon, boxLeftLat - boxRange, boxTopLon + boxRange];\n  } // console.log(latLonCoordToPix(41.801763, -71.380682));\n\n\n  function handleClickOrDrag(mouseUpX, mouseUpY) {\n    const xChange = mouseUpX - mouseDownX;\n    const yChange = mouseDownY - mouseUpY; // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n      console.log(\"Clicked!\");\n      const ctx = ctxRef.current;\n      ctx.fillStyle = \"green\"; //TODO: insert the nearest call here\n    } else {\n      console.log(\"Dragged!\"); // console.log(xChange, yChange);\n      //console.log(latLonIfy(xChange), latLonIfy(yChange));\n      //console.log(leftLat + \", \" + topLon);\n      // TODO: this may want to get changed to a setParamName() function call when setState is used\n\n      leftLat += latLonIfy(xChange);\n      topLon += latLonIfy(yChange); //console.log(leftLat + \", \" + topLon);\n\n      clearLoadTiles();\n    }\n  }\n\n  function clearCanvas() {\n    let ctx = ctxRef.current;\n    const canvas = canvasRef.current;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  function drawTile(tileToDraw) {\n    //console.log(\"drawing tile\");\n    // console.log(tileToDraw);\n    const ctx = ctxRef.current;\n    ctx.fillStyle = \"lightgreen\";\n    const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n    const baseX = tileCoord[0];\n    const baseY = tileCoord[1];\n    const pixTileWidth = pixIfy(TILE_WIDTH);\n    ctx.fillRect(Math.max(baseX, 0), Math.max(baseY, 0), Math.min(baseX + pixTileWidth, pixTileWidth), Math.min(baseY + pixTileWidth, pixTileWidth));\n    ctx.strokeStyle = \"black\";\n    ctx.strokeRect(Math.max(baseX, 0), Math.max(baseY, 0), Math.min(baseX + pixTileWidth, pixTileWidth), Math.min(baseY + pixTileWidth, pixTileWidth));\n    ctx.fillStyle = \"black\";\n    ctx.fillText(tileToDraw[\"name\"], baseX + pixTileWidth / 2.0, baseY + pixTileWidth / 2.0);\n  }\n\n  let scrollFinish;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Test title\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 367,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Latitude\",\n      change: setStartLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 368,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Source Longitude\",\n      change: setStartLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 369,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Latitude\",\n      change: setDestLat\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 370,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Longitude\",\n      change: setDestLon\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 371,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(AwesomeButton, {\n      type: \"primary\",\n      onPress: requestRoute,\n      children: \"Submit!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 372,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 373,\n      columnNumber: 13\n    }, this), route.map((coord, index) => /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [coord[0], \", \", coord[1]]\n    }, index, true, {\n      fileName: _jsxFileName,\n      lineNumber: 375,\n      columnNumber: 17\n    }, this)), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      onMouseDown: event => {\n        mouseDownX = event.pageX;\n        mouseDownY = event.pageY;\n      },\n      onMouseUp: event => {\n        //pixCoordToLatLon(event.pageX, event.pageY);\n        handleClickOrDrag(event.pageX, event.pageY);\n      },\n      onWheel: event => {\n        event.stopPropagation(); // console.log(\"scrolling\");\n\n        clearTimeout(scrollFinish);\n        scrollFinish = setTimeout(() => {\n          // console.log(\"Not scrolling anymore\");\n          if (event.deltaY < 0) {\n            console.log(\"Scrolled up\");\n          } else {\n            console.log(\"Scrolled down\");\n          }\n        }, SCROLL_WAIT);\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 377,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 366,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Route, \"oMsN6JFjd0Rg09WLtcTIh6Wt6/w=\");\n\n_c = Route;\nexport default Route;\n\nvar _c;\n\n$RefreshReg$(_c, \"Route\");","map":{"version":3,"sources":["/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js"],"names":["TextBox","React","useState","useEffect","useRef","axios","AwesomeButton","Route","startLat","setStartLat","startLon","setStartLon","destLat","setDestLat","destLon","setDestLon","route","setRoute","CANVAS_SIDE_LENGTH","SCROLL_WAIT","CLICK_RANGE","leftLat","topLon","latLonRange","mouseDownX","mouseDownY","TILE_WIDTH","leftmostTileLat","highestTileLon","rightmostTileLat","lowestTileLon","tilesLoaded","canvasRef","ctxRef","requestRoute","toSend","srclat","srclong","destlat","destlong","config","headers","post","then","response","console","log","data","catch","error","canvas","current","width","height","getContext","loadStartingTiles","boundaries","getMapBoundaries","loadTilesWithin","leftLatLimit","topLonLimit","rightLatLimit","bottomLonLimit","newTile","curLat","curLon","Math","round","random","drawTile","push","clearLoadTiles","clearCanvas","mapBoundaries","rightLat","bottomLon","saveTiles","i","length","checkTile","tileBoundaries","getBoundingBox","tileLeftLat","tileTopLon","tileRightLat","tileBottomLon","deleteTile","drawLoadedRect","ctx","loadedPixBoxTopLeft","latLonCoordToPix","loadedPixBoxBottomRight","loadedPixBoxWidth","loadedPixBoxHeight","strokeStyle","strokeRect","lat","lon","normalizedLat","normalizedLon","pixIfy","latLonVal","pixOverLatLonFactor","pixCoordToLatLon","left","top","normalizedLeft","offsetLeft","normalizedTop","offsetTop","returnLat","latLonIfy","returnLon","pixVal","latLonOverPixFactor","boxLeftLat","boxTopLon","boxRange","handleClickOrDrag","mouseUpX","mouseUpY","xChange","yChange","abs","fillStyle","clearRect","tileToDraw","tileCoord","baseX","baseY","pixTileWidth","fillRect","max","min","fillText","scrollFinish","map","coord","index","event","pageX","pageY","stopPropagation","clearTimeout","setTimeout","deltaY"],"mappings":";;;AAAA,OAAO,WAAP;AACA,OAAOA,OAAP,MAAoB,WAApB;AACA,OAAOC,KAAP,IAAeC,QAAf,EAAyBC,SAAzB,EAAoCC,MAApC,QAAiD,OAAjD;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,SAASC,aAAT,QAA8B,sBAA9B;AACA,OAAO,sCAAP;;;AAEA,SAASC,KAAT,GAAiB;AAAA;;AACb,QAAM,CAACC,QAAD,EAAWC,WAAX,IAA0BP,QAAQ,CAAC,CAAD,CAAxC;AACA,QAAM,CAACQ,QAAD,EAAWC,WAAX,IAA0BT,QAAQ,CAAC,CAAD,CAAxC;AACA,QAAM,CAACU,OAAD,EAAUC,UAAV,IAAwBX,QAAQ,CAAC,CAAD,CAAtC;AACA,QAAM,CAACY,OAAD,EAAUC,UAAV,IAAwBb,QAAQ,CAAC,CAAD,CAAtC;AACA,QAAM,CAACc,KAAD,EAAQC,QAAR,IAAoBf,QAAQ,CAAC,EAAD,CAAlC;AACA,QAAMgB,kBAAkB,GAAG,GAA3B;AACA,QAAMC,WAAW,GAAG,EAApB;AACA,QAAMC,WAAW,GAAG,CAApB,CARa,CASb;AACA;;AACA,MAAIC,OAAO,GAAG,SAAd;AACA,MAAIC,MAAM,GAAG,CAAC,SAAd;AACA,MAAIC,WAAW,GAAG,QAAlB;AACA,MAAIC,UAAJ;AACA,MAAIC,UAAJ,CAfa,CAgBb;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA,QAAMC,UAAU,GAAG,WAAnB,CA3Ba,CA2BmB;;AAChC,MAAIC,eAAe,GAAGN,OAAtB;AACA,MAAIO,cAAc,GAAGN,MAArB;AACA,MAAIO,gBAAgB,GAAGF,eAAvB;AACA,MAAIG,aAAa,GAAGF,cAApB;AACA,MAAIG,WAAW,GAAG,EAAlB,CAhCa,CAiCb;AACA;;AAGA,QAAMC,SAAS,GAAG5B,MAAM,EAAxB;AACA,MAAI6B,MAAM,GAAG7B,MAAM,EAAnB;AAEA;AACJ;AACA;;AACI,QAAM8B,YAAY,GAAG,MAAM;AACvB,UAAMC,MAAM,GAAG;AACXC,MAAAA,MAAM,EAAE5B,QADG;AAEX6B,MAAAA,OAAO,EAAE3B,QAFE;AAGX4B,MAAAA,OAAO,EAAE1B,OAHE;AAIX2B,MAAAA,QAAQ,EAAEzB;AAJC,KAAf,CADuB,CAOvB;;AAEA,QAAI0B,MAAM,GAAG;AACTC,MAAAA,OAAO,EAAE;AACL,wBAAgB,kBADX;AAEL,uCAA+B;AAF1B;AADA,KAAb,CATuB,CAgBvB;;AACApC,IAAAA,KAAK,CAACqC,IAAN,CACI,6BADJ,EAEIP,MAFJ,EAGIK,MAHJ,EAKKG,IALL,CAKUC,QAAQ,IAAI;AACdC,MAAAA,OAAO,CAACC,GAAR,CAAYF,QAAQ,CAACG,IAArB,EADc,CAEd;;AACA9B,MAAAA,QAAQ,CAAC2B,QAAQ,CAACG,IAAT,CAAc,OAAd,CAAD,CAAR;AACH,KATL,EAUKC,KAVL,CAUW,UAAUC,KAAV,EAAiB;AACpBJ,MAAAA,OAAO,CAACC,GAAR,CAAYG,KAAZ;AACH,KAZL;AAaH,GA9BD;AAgCA;AACJ;AACA;;;AACI9C,EAAAA,SAAS,CAAC,MAAM;AACZ;AACA,UAAM+C,MAAM,GAAGlB,SAAS,CAACmB,OAAzB;AACAD,IAAAA,MAAM,CAACE,KAAP,GAAelC,kBAAf;AACAgC,IAAAA,MAAM,CAACG,MAAP,GAAgBnC,kBAAhB;AACAe,IAAAA,MAAM,CAACkB,OAAP,GAAiBD,MAAM,CAACI,UAAP,CAAkB,IAAlB,CAAjB,CALY,CAMZ;AACA;AACA;AAEA;;AACAC,IAAAA,iBAAiB;AACpB,GAZQ,EAYN,EAZM,CAAT;;AAcA,WAASA,iBAAT,GAA6B;AACzBV,IAAAA,OAAO,CAACC,GAAR,CAAY,wBAAZ;AACA,UAAMU,UAAU,GAAGC,gBAAgB,EAAnC;AACAC,IAAAA,eAAe,CAACF,UAAU,CAAC,CAAD,CAAX,EAAgBA,UAAU,CAAC,CAAD,CAA1B,EAA+BA,UAAU,CAAC,CAAD,CAAzC,EAA8CA,UAAU,CAAC,CAAD,CAAxD,CAAf;AACH;;AAED,WAASE,eAAT,CAAyBC,YAAzB,EAAuCC,WAAvC,EAAoDC,aAApD,EAAmEC,cAAnE,EAAmF;AAC/E,QAAIH,YAAY,GAAGhC,eAAnB,EAAoC;AAChCA,MAAAA,eAAe,GAAGgC,YAAlB;AACH;;AACD,QAAIC,WAAW,GAAGhC,cAAlB,EAAkC;AAC9BA,MAAAA,cAAc,GAAGgC,WAAjB;AACH;;AACD,QAAIG,OAAJ;AACA,QAAIC,MAAM,GAAGL,YAAb;AACA,QAAIM,MAAM,GAAGL,WAAb;;AACA,WAAOK,MAAM,GAAGH,cAAhB,EAAgC;AAC5B,aAAOE,MAAM,GAAGH,aAAhB,EAA+B;AAC3BE,QAAAA,OAAO,GAAG;AAAC,qBAAWC,MAAZ;AAAoB,qBAAWC,MAA/B;AAAuC,kBAAQ,EAA/C;AAAmD,kBAAOC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAc,GAAzB;AAA1D,SAAV;AACAC,QAAAA,QAAQ,CAACN,OAAD,CAAR,CAF2B,CAG3B;AACA;AACA;AAEA;AAEA;;AACAhC,QAAAA,WAAW,CAACuC,IAAZ,CAAiBP,OAAjB;AACAC,QAAAA,MAAM,IAAItC,UAAV;AACH;;AACD,UAAIsC,MAAM,GAAGnC,gBAAb,EAA+B;AAC3BA,QAAAA,gBAAgB,GAAGmC,MAAnB;AACH;;AACDA,MAAAA,MAAM,GAAGL,YAAT;AACAM,MAAAA,MAAM,IAAIvC,UAAV;AACH;;AACD,QAAIuC,MAAM,GAAGnC,aAAb,EAA4B;AACxBA,MAAAA,aAAa,GAAGmC,MAAhB;AACH;AACJ;;AAED,WAASM,cAAT,GAA0B;AACtBC,IAAAA,WAAW,GADW,CAGtB;;AACA,UAAMC,aAAa,GAAGhB,gBAAgB,EAAtC;AACA,UAAMiB,QAAQ,GAAGD,aAAa,CAAC,CAAD,CAA9B;AACA,UAAME,SAAS,GAAGF,aAAa,CAAC,CAAD,CAA/B;AACA,QAAIG,SAAS,GAAG,EAAhB,CAPsB,CAQtB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG9C,WAAW,CAAC+C,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AACzC,YAAME,SAAS,GAAGhD,WAAW,CAAC8C,CAAD,CAA7B;AACA,YAAMG,cAAc,GAAGC,cAAc,CAACF,SAAS,CAAC,SAAD,CAAV,EAAuBA,SAAS,CAAC,SAAD,CAAhC,EAA6CrD,UAA7C,CAArC;AACA,YAAMwD,WAAW,GAAGF,cAAc,CAAC,CAAD,CAAlC;AACA,YAAMG,UAAU,GAAGH,cAAc,CAAC,CAAD,CAAjC;AACA,YAAMI,YAAY,GAAGJ,cAAc,CAAC,CAAD,CAAnC;AACA,YAAMK,aAAa,GAAGL,cAAc,CAAC,CAAD,CAApC,CANyC,CAOzC;AACA;;AACA,YAAMM,UAAU,GAAIF,YAAY,GAAG/D,OAAhB,IAA6B6D,WAAW,GAAGR,QAA3C,IACXW,aAAa,GAAG/D,MADL,IACiB6D,UAAU,GAAGR,SADjD,CATyC,CAWzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAI,CAACW,UAAL,EAAiB;AACbjB,QAAAA,QAAQ,CAACtC,WAAW,CAAC8C,CAAD,CAAZ,CAAR;AACAD,QAAAA,SAAS,CAACN,IAAV,CAAeS,SAAf;AACH;AACJ;;AACDhD,IAAAA,WAAW,GAAG6C,SAAd,CAlCsB,CAoCtB;;AACA,WAAOK,cAAc,CAACtD,eAAD,EAAkBC,cAAlB,EAAkCF,UAAlC,CAAd,CAA4D,CAA5D,IAAiEL,OAAxE,EAAgF;AAC5E;AACAM,MAAAA,eAAe,IAAID,UAAnB;AACH;;AACD,WAAOuD,cAAc,CAACtD,eAAD,EAAkBC,cAAlB,EAAkCF,UAAlC,CAAd,CAA4D,CAA5D,IAAiEJ,MAAxE,EAA+E;AAC3E;AACAM,MAAAA,cAAc,IAAIF,UAAlB;AACH;;AACD,WAAOG,gBAAgB,GAAG6C,QAA1B,EAAmC;AAC/B;AACA7C,MAAAA,gBAAgB,IAAIH,UAApB;AACH;;AACD,WAAOI,aAAa,GAAG6C,SAAvB,EAAiC;AAC7B;AACA7C,MAAAA,aAAa,IAAIJ,UAAjB;AACH,KApDqB,CAsDtB;;;AACA,WAAOC,eAAe,GAAGN,OAAzB,EAAkC;AAC9B;AACAqC,MAAAA,eAAe,CAAC/B,eAAe,GAAGD,UAAnB,EAA+BE,cAA/B,EAA+CD,eAA/C,EAAgEG,aAAhE,CAAf,CAF8B,CAG9B;AACH;;AACD,WAAOD,gBAAgB,GAAG6C,QAA1B,EAAoC;AAChC;AACAhB,MAAAA,eAAe,CAAC7B,gBAAD,EAAmBD,cAAnB,EAAmCC,gBAAgB,GAAGH,UAAtD,EAAkEI,aAAlE,CAAf;AACH;;AACD,WAAOF,cAAc,GAAGN,MAAxB,EAAgC;AAC5B;AACAoC,MAAAA,eAAe,CAAC/B,eAAD,EAAkBC,cAAc,GAAGF,UAAnC,EAA+CG,gBAA/C,EAAiED,cAAjE,CAAf;AACH;;AACD,WAAOE,aAAa,GAAG6C,SAAvB,EAAkC;AAC9B;AACAjB,MAAAA,eAAe,CAAC/B,eAAD,EAAkBG,aAAlB,EAAiCD,gBAAjC,EAAmDC,aAAa,GAAGJ,UAAnE,CAAf;AACH,KAvEqB,CAwEtB;AACA;;AACH;;AAED,WAAS6D,cAAT,GAAyB;AACrB,UAAMC,GAAG,GAAGvD,MAAM,CAACkB,OAAnB;AACA,UAAMsC,mBAAmB,GAAGC,gBAAgB,CAAC/D,eAAD,EAAkBC,cAAlB,CAA5C;AACA,UAAM+D,uBAAuB,GAAGD,gBAAgB,CAAC7D,gBAAD,EAAmBC,aAAnB,CAAhD;AACA,UAAM8D,iBAAiB,GAAGD,uBAAuB,CAAC,CAAD,CAAvB,GAA6BF,mBAAmB,CAAC,CAAD,CAA1E;AACA,UAAMI,kBAAkB,GAAGF,uBAAuB,CAAC,CAAD,CAAvB,GAA6BF,mBAAmB,CAAC,CAAD,CAA3E;AACAD,IAAAA,GAAG,CAACM,WAAJ,GAAkB,KAAlB;AACAN,IAAAA,GAAG,CAACO,UAAJ,CAAeN,mBAAmB,CAAC,CAAD,CAAlC,EAAuCA,mBAAmB,CAAC,CAAD,CAA1D,EAA+DG,iBAA/D,EAAkFC,kBAAlF;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,WAASH,gBAAT,CAA0BM,GAA1B,EAA+BC,GAA/B,EAAoC;AAChC,UAAMC,aAAa,GAAG7E,OAAO,GAAG2E,GAAhC;AACA,UAAMG,aAAa,GAAGF,GAAG,GAAG3E,MAA5B,CAFgC,CAGhC;AACA;AACA;;AAEA,WAAO,CAAC8E,MAAM,CAACF,aAAD,CAAP,EAAwBE,MAAM,CAACD,aAAD,CAA9B,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACI,WAASC,MAAT,CAAgBC,SAAhB,EAA2B;AACvB,UAAMC,mBAAmB,GAAGpF,kBAAkB,GAAGK,WAAjD;AACA,WAAO8E,SAAS,GAAGC,mBAAnB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,WAASC,gBAAT,CAA0BC,IAA1B,EAAgCC,GAAhC,EAAqC;AACjC,UAAMvD,MAAM,GAAGlB,SAAS,CAACmB,OAAzB;AACA,UAAMuD,cAAc,GAAGF,IAAI,GAAGtD,MAAM,CAACyD,UAArC;AACA,UAAMC,aAAa,GAAGH,GAAG,GAAGvD,MAAM,CAAC2D,SAAnC,CAHiC,CAIjC;AACA;;AAEA,UAAMC,SAAS,GAAGzF,OAAO,GAAG0F,SAAS,CAACL,cAAD,CAArC;AACA,UAAMM,SAAS,GAAG1F,MAAM,GAAGyF,SAAS,CAACH,aAAD,CAApC,CARiC,CASjC;AACA;;AACA,WAAO,CAACE,SAAD,EAAYE,SAAZ,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACI,WAASD,SAAT,CAAmBE,MAAnB,EAA2B;AACvB,UAAMC,mBAAmB,GAAI3F,WAAW,GAAGL,kBAA3C;AACA,WAAO+F,MAAM,GAAGC,mBAAhB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACI,WAASzD,gBAAT,GAA4B;AACxB,WAAOwB,cAAc,CAAC5D,OAAD,EAAUC,MAAV,EAAkBC,WAAlB,CAArB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,WAAS0D,cAAT,CAAwBkC,UAAxB,EAAoCC,SAApC,EAA+CC,QAA/C,EAAyD;AACrD,WAAO,CAACF,UAAD,EAAaC,SAAb,EAAwBD,UAAU,GAAGE,QAArC,EAA+CD,SAAS,GAAGC,QAA3D,CAAP;AACH,GA3SY,CA6Sb;;;AAEA,WAASC,iBAAT,CAA2BC,QAA3B,EAAqCC,QAArC,EAA+C;AAC3C,UAAMC,OAAO,GAAGF,QAAQ,GAAG/F,UAA3B;AACA,UAAMkG,OAAO,GAAGjG,UAAU,GAAG+F,QAA7B,CAF2C,CAG3C;AACA;;AAEA,QAAItD,IAAI,CAACyD,GAAL,CAASF,OAAT,IAAoBrG,WAApB,IAAmC8C,IAAI,CAACyD,GAAL,CAASD,OAAT,IAAoBtG,WAA3D,EAAwE;AACpEyB,MAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ;AACA,YAAM0C,GAAG,GAAGvD,MAAM,CAACkB,OAAnB;AACAqC,MAAAA,GAAG,CAACoC,SAAJ,GAAgB,OAAhB,CAHoE,CAKpE;AACH,KAND,MAMO;AACH/E,MAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ,EADG,CAEH;AACA;AACA;AACA;;AACAzB,MAAAA,OAAO,IAAI0F,SAAS,CAACU,OAAD,CAApB;AACAnG,MAAAA,MAAM,IAAIyF,SAAS,CAACW,OAAD,CAAnB,CAPG,CAQH;;AACAnD,MAAAA,cAAc;AACjB;AACJ;;AAED,WAASC,WAAT,GAAuB;AACnB,QAAIgB,GAAG,GAAGvD,MAAM,CAACkB,OAAjB;AACA,UAAMD,MAAM,GAAGlB,SAAS,CAACmB,OAAzB;AACAqC,IAAAA,GAAG,CAACqC,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB3E,MAAM,CAACE,KAA3B,EAAkCF,MAAM,CAACG,MAAzC;AACH;;AAED,WAASgB,QAAT,CAAkByD,UAAlB,EAA8B;AAC1B;AACA;AACA,UAAMtC,GAAG,GAAGvD,MAAM,CAACkB,OAAnB;AACAqC,IAAAA,GAAG,CAACoC,SAAJ,GAAgB,YAAhB;AACA,UAAMG,SAAS,GAAGrC,gBAAgB,CAACoC,UAAU,CAAC,SAAD,CAAX,EAAwBA,UAAU,CAAC,SAAD,CAAlC,CAAlC;AACA,UAAME,KAAK,GAAGD,SAAS,CAAC,CAAD,CAAvB;AACA,UAAME,KAAK,GAAGF,SAAS,CAAC,CAAD,CAAvB;AAEA,UAAMG,YAAY,GAAG9B,MAAM,CAAC1E,UAAD,CAA3B;AACA8D,IAAAA,GAAG,CAAC2C,QAAJ,CAAajE,IAAI,CAACkE,GAAL,CAASJ,KAAT,EAAe,CAAf,CAAb,EAAgC9D,IAAI,CAACkE,GAAL,CAASH,KAAT,EAAe,CAAf,CAAhC,EACI/D,IAAI,CAACmE,GAAL,CAASL,KAAK,GAAGE,YAAjB,EAA+BA,YAA/B,CADJ,EAEIhE,IAAI,CAACmE,GAAL,CAASJ,KAAK,GAAGC,YAAjB,EAA+BA,YAA/B,CAFJ;AAGA1C,IAAAA,GAAG,CAACM,WAAJ,GAAkB,OAAlB;AACAN,IAAAA,GAAG,CAACO,UAAJ,CAAe7B,IAAI,CAACkE,GAAL,CAASJ,KAAT,EAAe,CAAf,CAAf,EAAkC9D,IAAI,CAACkE,GAAL,CAASH,KAAT,EAAe,CAAf,CAAlC,EACI/D,IAAI,CAACmE,GAAL,CAASL,KAAK,GAAGE,YAAjB,EAA+BA,YAA/B,CADJ,EAEIhE,IAAI,CAACmE,GAAL,CAASJ,KAAK,GAAGC,YAAjB,EAA+BA,YAA/B,CAFJ;AAGA1C,IAAAA,GAAG,CAACoC,SAAJ,GAAgB,OAAhB;AACApC,IAAAA,GAAG,CAAC8C,QAAJ,CAAaR,UAAU,CAAC,MAAD,CAAvB,EAAiCE,KAAK,GAAIE,YAAY,GAAG,GAAzD,EAA+DD,KAAK,GAAIC,YAAY,GAAG,GAAvF;AACH;;AAED,MAAIK,YAAJ;AAEA,sBACI;AAAA,4BACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YADJ,eAEI,QAAC,OAAD;AAAS,MAAA,KAAK,EAAE,iBAAhB;AAAmC,MAAA,MAAM,EAAE9H;AAA3C;AAAA;AAAA;AAAA;AAAA,YAFJ,eAGI,QAAC,OAAD;AAAS,MAAA,KAAK,EAAE,kBAAhB;AAAoC,MAAA,MAAM,EAAEE;AAA5C;AAAA;AAAA;AAAA;AAAA,YAHJ,eAII,QAAC,OAAD;AAAS,MAAA,KAAK,EAAE,sBAAhB;AAAwC,MAAA,MAAM,EAAEE;AAAhD;AAAA;AAAA;AAAA;AAAA,YAJJ,eAKI,QAAC,OAAD;AAAS,MAAA,KAAK,EAAE,uBAAhB;AAAyC,MAAA,MAAM,EAAEE;AAAjD;AAAA;AAAA;AAAA;AAAA,YALJ,eAMI,QAAC,aAAD;AAAe,MAAA,IAAI,EAAC,SAApB;AAA8B,MAAA,OAAO,EAAEmB,YAAvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YANJ,eAOI;AAAA;AAAA;AAAA;AAAA,YAPJ,EAQKlB,KAAK,CAACwH,GAAN,CAAU,CAACC,KAAD,EAAQC,KAAR,kBACP;AAAA,iBAAgBD,KAAK,CAAC,CAAD,CAArB,QAA4BA,KAAK,CAAC,CAAD,CAAjC;AAAA,OAAQC,KAAR;AAAA;AAAA;AAAA;AAAA,YADH,CARL,eAWI;AAAQ,MAAA,GAAG,EAAE1G,SAAb;AAAwB,MAAA,WAAW,EAAG2G,KAAD,IAAW;AAC5CnH,QAAAA,UAAU,GAAGmH,KAAK,CAACC,KAAnB;AACAnH,QAAAA,UAAU,GAAGkH,KAAK,CAACE,KAAnB;AACH,OAHD;AAGG,MAAA,SAAS,EAAGF,KAAD,IAAW;AACrB;AACArB,QAAAA,iBAAiB,CAACqB,KAAK,CAACC,KAAP,EAAcD,KAAK,CAACE,KAApB,CAAjB;AACH,OAND;AAMG,MAAA,OAAO,EAAGF,KAAD,IAAW;AACnBA,QAAAA,KAAK,CAACG,eAAN,GADmB,CAEnB;;AACAC,QAAAA,YAAY,CAACR,YAAD,CAAZ;AACAA,QAAAA,YAAY,GAAGS,UAAU,CAAC,MAAM;AAC5B;AACA,cAAIL,KAAK,CAACM,MAAN,GAAe,CAAnB,EAAsB;AAClBpG,YAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ;AACH,WAFD,MAEO;AACHD,YAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ;AACH;AACJ,SAPwB,EAOtB3B,WAPsB,CAAzB;AAQH;AAlBD;AAAA;AAAA;AAAA;AAAA,YAXJ;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAiCH;;GAtYQZ,K;;KAAAA,K;AAwYT,eAAeA,KAAf","sourcesContent":["import './App.css';\nimport TextBox from \"./TextBox\";\nimport React, {useState, useEffect, useRef} from 'react';\nimport axios from 'axios';\nimport { AwesomeButton } from \"react-awesome-button\";\nimport \"react-awesome-button/dist/styles.css\";\n\nfunction Route() {\n    const [startLat, setStartLat] = useState(0);\n    const [startLon, setStartLon] = useState(0);\n    const [destLat, setDestLat] = useState(0);\n    const [destLon, setDestLon] = useState(0);\n    const [route, setRoute] = useState([]);\n    const CANVAS_SIDE_LENGTH = 450;\n    const SCROLL_WAIT = 40;\n    const CLICK_RANGE = 5;\n    //TODO: will probably want to turn these into useState() calls eventually when zoom and scroll\n    // are implemented\n    let leftLat = 41.833038;\n    let topLon = -71.411957;\n    let latLonRange = 0.031275;\n    let mouseDownX;\n    let mouseDownY;\n    // So in order to render the starting map, it'll have to render 64 tiles, I think\n    // On Brown campus, that gives approximately 4,500 ways in just one tile...\n\n    // We expect latitudes within the map range to be LESS than the leftLat\n    // We expect longitudes within the map range to be GREATER than the topLon\n\n    // In order to get rightLat or bottomLon, just subtract latLonRange from leftLat, or add it to topLon\n    // But for testing purposes, unless the above values are changed:\n    // rightLat = 41.801763\n    // bottomLon = -71.380682\n\n    const TILE_WIDTH = 0.003909375; // one eighth of starting latLonRange\n    let leftmostTileLat = leftLat;\n    let highestTileLon = topLon;\n    let rightmostTileLat = leftmostTileLat;\n    let lowestTileLon = highestTileLon;\n    let tilesLoaded = [];\n    // Tiles should be JavaScript objects with properties leftLat, topLon, and an [] of ways\n    // Ways should be length-4 list of Doubles? [lat1, lon1, lat2, lon2]?\n\n\n    const canvasRef = useRef();\n    let ctxRef = useRef();\n\n    /**\n     * Makes an axios request.\n     */\n    const requestRoute = () => {\n        const toSend = {\n            srclat: startLat,\n            srclong: startLon,\n            destlat: destLat,\n            destlong: destLon\n        };\n        //console.log(toSend);\n\n        let config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n\n        //Install and import this!\n        axios.post(\n            \"http://localhost:4567/route\",\n            toSend,\n            config\n        )\n            .then(response => {\n                console.log(response.data);\n                // TODO: make sure that the \"route\" here corresponds to the correct data we want back\n                setRoute(response.data[\"route\"]);\n            })\n            .catch(function (error) {\n                console.log(error);\n            });\n    }\n\n    /**\n     * Code to run when the page loads\n     */\n    useEffect(() => {\n        //console.log(\"page loaded!\");\n        const canvas = canvasRef.current;\n        canvas.width = CANVAS_SIDE_LENGTH;\n        canvas.height = CANVAS_SIDE_LENGTH;\n        ctxRef.current = canvas.getContext(\"2d\");\n        // let ctx = ctxRef.current;\n        // ctx.fillStyle = \"green\";\n        // ctx.fillRect(0, 0, 100, 100);\n\n        // Load tiles\n        loadStartingTiles();\n    }, []);\n\n    function loadStartingTiles() {\n        console.log(\"Loading starting tiles\");\n        const boundaries = getMapBoundaries();\n        loadTilesWithin(boundaries[0], boundaries[1], boundaries[2], boundaries[3]);\n    }\n\n    function loadTilesWithin(leftLatLimit, topLonLimit, rightLatLimit, bottomLonLimit) {\n        if (leftLatLimit > leftmostTileLat) {\n            leftmostTileLat = leftLatLimit;\n        }\n        if (topLonLimit < highestTileLon) {\n            highestTileLon = topLonLimit;\n        }\n        let newTile;\n        let curLat = leftLatLimit;\n        let curLon = topLonLimit;\n        while (curLon < bottomLonLimit) {\n            while (curLat > rightLatLimit) {\n                newTile = {\"tileLat\": curLat, \"tileLon\": curLon, \"ways\": [], \"name\":Math.round(Math.random()*100)};\n                drawTile(newTile);\n                // TODO: here, \"ways\" should hold a list of ways within the tile range\n                // NOTE: you can get lat1/lon1 lat2/lon2 coordinates for the tile\n                // by calling getBoudingBox(tileLat, tileLon, TILE_WIDTH);\n\n                // TODO: drawTile might want to call the eventual method for drawing ways\n\n                // console.log(newTile);\n                tilesLoaded.push(newTile);\n                curLat -= TILE_WIDTH;\n            }\n            if (curLat < rightmostTileLat) {\n                rightmostTileLat = curLat;\n            }\n            curLat = leftLatLimit;\n            curLon += TILE_WIDTH;\n        }\n        if (curLon > lowestTileLon) {\n            lowestTileLon = curLon;\n        }\n    }\n\n    function clearLoadTiles() {\n        clearCanvas();\n\n        // First, purge old tiles\n        const mapBoundaries = getMapBoundaries();\n        const rightLat = mapBoundaries[2];\n        const bottomLon = mapBoundaries[3];\n        let saveTiles = [];\n        // Iterate over all the loaded tiles and see if they're still useful\n        for (let i = 0; i < tilesLoaded.length; i++) {\n            const checkTile = tilesLoaded[i];\n            const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n            const tileLeftLat = tileBoundaries[0];\n            const tileTopLon = tileBoundaries[1];\n            const tileRightLat = tileBoundaries[2];\n            const tileBottomLon = tileBoundaries[3];\n            // We expect latitudes within the map range to be LESS than the leftLat\n            // We expect longitudes within the map range to be GREATER than the topLon\n            const deleteTile = (tileRightLat > leftLat) || (tileLeftLat < rightLat)\n                || (tileBottomLon < topLon) || (tileTopLon > bottomLon);\n            // const keepTileLeftRight = (tileRightLat < leftLat) || (tileLeftLat > rightLat);\n            // if (tileRightLat > leftLat) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the left side\");\n            // }\n            // const keepTileUpDown = (tileBottomLon > topLon) || (tileTopLon < bottomLon);\n            // if (tileTopLon > bottomLon) {\n            //     console.log(checkTile[\"name\"] + \" tile is offscreen on the bottom side\");\n            // }\n            // let keepTile = keepTileLeftRight && keepTileUpDown;\n            if (!deleteTile) {\n                drawTile(tilesLoaded[i]);\n                saveTiles.push(checkTile);\n            }\n        }\n        tilesLoaded = saveTiles;\n\n        // update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n        while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[2] > leftLat){\n            //console.log(\"adjusting loaded left boundary\");\n            leftmostTileLat -= TILE_WIDTH;\n        }\n        while (getBoundingBox(leftmostTileLat, highestTileLon, TILE_WIDTH)[3] < topLon){\n            //console.log(\"adjusting loaded top boundary\");\n            highestTileLon += TILE_WIDTH;\n        }\n        while (rightmostTileLat < rightLat){\n            //console.log(\"adjusting loaded right boundary\");\n            rightmostTileLat += TILE_WIDTH;\n        }\n        while (lowestTileLon > bottomLon){\n            //console.log(\"adjusting loaded bottom boundary\");\n            lowestTileLon -= TILE_WIDTH;\n        }\n\n        // Now, load new tiles\n        while (leftmostTileLat < leftLat) {\n            //console.log(\"gap at left\");\n            loadTilesWithin(leftmostTileLat + TILE_WIDTH, highestTileLon, leftmostTileLat, lowestTileLon);\n            //leftmostTileLat += TILE_WIDTH;\n        }\n        while (rightmostTileLat > rightLat) {\n            //console.log(\"gap at right\");\n            loadTilesWithin(rightmostTileLat, highestTileLon, rightmostTileLat - TILE_WIDTH, lowestTileLon);\n        }\n        while (highestTileLon > topLon) {\n            //console.log(\"gap at top\");\n            loadTilesWithin(leftmostTileLat, highestTileLon - TILE_WIDTH, rightmostTileLat, highestTileLon);\n        }\n        while (lowestTileLon < bottomLon) {\n            //console.log(\"gap at bottom\");\n            loadTilesWithin(leftmostTileLat, lowestTileLon, rightmostTileLat, lowestTileLon + TILE_WIDTH);\n        }\n        //console.log(tilesLoaded.length);\n        //drawLoadedRect();\n    }\n\n    function drawLoadedRect(){\n        const ctx = ctxRef.current;\n        const loadedPixBoxTopLeft = latLonCoordToPix(leftmostTileLat, highestTileLon);\n        const loadedPixBoxBottomRight = latLonCoordToPix(rightmostTileLat, lowestTileLon);\n        const loadedPixBoxWidth = loadedPixBoxBottomRight[0] - loadedPixBoxTopLeft[0];\n        const loadedPixBoxHeight = loadedPixBoxBottomRight[1] - loadedPixBoxTopLeft[1];\n        ctx.strokeStyle = \"red\";\n        ctx.strokeRect(loadedPixBoxTopLeft[0], loadedPixBoxTopLeft[1], loadedPixBoxWidth, loadedPixBoxHeight);\n    }\n\n    /**\n     * Code to turn lon/lat coordinates into pixel coordinates for the canvas:\n     * takes in a latitude and longitude coordinate, returns a length-2 list with the\n     * corresponding pixel position on the canvas [left, top]\n     * @param lat - the latitude coordinate to turn into a pixel left coordinate\n     * @param lon - the longitude coordinate to turn into a pixel top coordinate\n     * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n     */\n    function latLonCoordToPix(lat, lon) {\n        const normalizedLat = leftLat - lat;\n        const normalizedLon = lon - topLon;\n        // Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n        // We expect latitudes within the map range to be LESS than the leftLat\n        // We expect longitudes within the map range to be GREATER than the topLon\n\n        return [pixIfy(normalizedLat), pixIfy(normalizedLon)];\n    }\n\n    /**\n     * Turns a latitude/longitude coordinate value into a pixel value.\n     * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n     * @returns {number} the pixel conversion of the lat/lon value\n     */\n    function pixIfy(latLonVal) {\n        const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n        return latLonVal * pixOverLatLonFactor;\n    }\n\n    /**\n     * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n     * and longitude coordinate\n     * Returns a length-2 list with [lat, lon]\n     * @param left - the pixel left coordinate to turn into map latitude\n     * @param top - the pixel top coordinate to turn into map longitude\n     * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n     */\n    function pixCoordToLatLon(left, top) {\n        const canvas = canvasRef.current;\n        const normalizedLeft = left - canvas.offsetLeft;\n        const normalizedTop = top - canvas.offsetTop;\n        // console.log(normalizedLeft + \", \" + normalizedTop);\n        // console.log(normalizedLeft/CANVAS_SIDE_LENGTH + \", \" + normalizedTop/CANVAS_SIDE_LENGTH);\n\n        const returnLat = leftLat - latLonIfy(normalizedLeft);\n        const returnLon = topLon + latLonIfy(normalizedTop);\n        // console.log(returnLat, \", \", returnLon)\n        // console.log(latLonCoordToPix(returnLat, returnLon));\n        return [returnLat, returnLon];\n    }\n\n    /**\n     * Turns a value in pixels into a value in latitude/longitude coordinates.\n     * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n     * @returns {number} the lat/lon conversion of the pixel value\n     */\n    function latLonIfy(pixVal) {\n        const latLonOverPixFactor =  latLonRange / CANVAS_SIDE_LENGTH;\n        return pixVal * latLonOverPixFactor;\n    }\n\n    /**\n     * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n     * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of the current map frame.\n     */\n    function getMapBoundaries() {\n        return getBoundingBox(leftLat, topLon, latLonRange);\n    }\n\n    /**\n     * Get the lat/lon boundaries of a passed square area with unknown side length.\n     * @param boxLeftLat latitude coordinate of the northwest corner\n     * @param boxTopLon longitude coordinate of the northwest corner\n     * @param boxRange side length, in terms of lat/lon coordinates\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of a passed square.\n     */\n    function getBoundingBox(boxLeftLat, boxTopLon, boxRange) {\n        return [boxLeftLat, boxTopLon, boxLeftLat - boxRange, boxTopLon + boxRange];\n    }\n\n    // console.log(latLonCoordToPix(41.801763, -71.380682));\n\n    function handleClickOrDrag(mouseUpX, mouseUpY) {\n        const xChange = mouseUpX - mouseDownX;\n        const yChange = mouseDownY - mouseUpY;\n        // We expect latitudes within the map range to be LESS than the leftLat\n        // We expect longitudes within the map range to be GREATER than the topLon\n\n        if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n            console.log(\"Clicked!\");\n            const ctx = ctxRef.current;\n            ctx.fillStyle = \"green\";\n\n            //TODO: insert the nearest call here\n        } else {\n            console.log(\"Dragged!\");\n            // console.log(xChange, yChange);\n            //console.log(latLonIfy(xChange), latLonIfy(yChange));\n            //console.log(leftLat + \", \" + topLon);\n            // TODO: this may want to get changed to a setParamName() function call when setState is used\n            leftLat += latLonIfy(xChange);\n            topLon += latLonIfy(yChange);\n            //console.log(leftLat + \", \" + topLon);\n            clearLoadTiles();\n        }\n    }\n\n    function clearCanvas() {\n        let ctx = ctxRef.current;\n        const canvas = canvasRef.current;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    function drawTile(tileToDraw) {\n        //console.log(\"drawing tile\");\n        // console.log(tileToDraw);\n        const ctx = ctxRef.current;\n        ctx.fillStyle = \"lightgreen\";\n        const tileCoord = latLonCoordToPix(tileToDraw[\"tileLat\"], tileToDraw[\"tileLon\"]);\n        const baseX = tileCoord[0];\n        const baseY = tileCoord[1];\n\n        const pixTileWidth = pixIfy(TILE_WIDTH);\n        ctx.fillRect(Math.max(baseX,0), Math.max(baseY,0),\n            Math.min(baseX + pixTileWidth, pixTileWidth),\n            Math.min(baseY + pixTileWidth, pixTileWidth));\n        ctx.strokeStyle = \"black\";\n        ctx.strokeRect(Math.max(baseX,0), Math.max(baseY,0),\n            Math.min(baseX + pixTileWidth, pixTileWidth),\n            Math.min(baseY + pixTileWidth, pixTileWidth));\n        ctx.fillStyle = \"black\";\n        ctx.fillText(tileToDraw[\"name\"], baseX + (pixTileWidth / 2.0), baseY + (pixTileWidth / 2.0));\n    }\n\n    let scrollFinish;\n\n    return (\n        <div>\n            <h1>Test title</h1>\n            <TextBox label={\"Source Latitude\"} change={setStartLat}/>\n            <TextBox label={\"Source Longitude\"} change={setStartLon}/>\n            <TextBox label={\"Destination Latitude\"} change={setDestLat}/>\n            <TextBox label={\"Destination Longitude\"} change={setDestLon}/>\n            <AwesomeButton type=\"primary\" onPress={requestRoute}>Submit!</AwesomeButton>\n            <br/>\n            {route.map((coord, index) =>\n                <p key={index}>{coord[0]}, {coord[1]}</p>\n            )}\n            <canvas ref={canvasRef} onMouseDown={(event) => {\n                mouseDownX = event.pageX;\n                mouseDownY = event.pageY;\n            }} onMouseUp={(event) => {\n                //pixCoordToLatLon(event.pageX, event.pageY);\n                handleClickOrDrag(event.pageX, event.pageY);\n            }} onWheel={(event) => {\n                event.stopPropagation();\n                // console.log(\"scrolling\");\n                clearTimeout(scrollFinish)\n                scrollFinish = setTimeout(() => {\n                    // console.log(\"Not scrolling anymore\");\n                    if (event.deltaY < 0) {\n                        console.log(\"Scrolled up\");\n                    } else {\n                        console.log(\"Scrolled down\");\n                    }\n                }, SCROLL_WAIT);\n            }}/>\n        </div>\n    );\n}\n\nexport default Route;"]},"metadata":{},"sourceType":"module"}