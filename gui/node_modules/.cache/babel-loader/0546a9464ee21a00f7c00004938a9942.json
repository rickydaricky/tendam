{"ast":null,"code":"var _jsxFileName = \"/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js\",\n    _s = $RefreshSig$();\n\nimport './App.css';\nimport TextBox from \"./TextBox\";\nimport ErrorBox from \"./ErrorBox\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport axios from 'axios';\nimport \"react-awesome-button/dist/styles.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Route() {\n  _s();\n\n  /*\n   * We used useRefs for a large number of variables that were previously useState().\n   * Changes to these variables caused the component to be rerendered often enough\n   * to cause glitches.\n   * However, this is why there are these brief setter functions for all of the useRef()\n   * variables.\n   */\n  const startLatLon = useRef([\"\", \"\"]);\n\n  const setStartLatLon = newStartLatLon => {\n    startLatLon.current = newStartLatLon;\n  };\n\n  const destLatLon = useRef([\"\", \"\"]);\n\n  const setDestLatLon = newdestLatLon => {\n    destLatLon.current = newdestLatLon;\n  };\n\n  const [startStreets, setStartStreets] = useState([\"\", \"\"]);\n  const startStreet1 = startStreets[0];\n  const startStreet2 = startStreets[1];\n\n  const setStartStreet1 = newStartStreet1 => {\n    setStartStreets([newStartStreet1, startStreet2]);\n  };\n\n  const setStartStreet2 = newStartStreet2 => {\n    setStartStreets([startStreet1, newStartStreet2]);\n  };\n\n  const [destStreets, setDestStreets] = useState([\"\", \"\"]);\n  const destStreet1 = destStreets[0];\n  const destStreet2 = destStreets[1];\n\n  const setDestStreet1 = newDestStreet1 => {\n    setDestStreets([newDestStreet1, destStreet2]);\n  };\n\n  const setDestStreet2 = newDestStreet2 => {\n    setDestStreets([destStreet1, newDestStreet2]);\n  };\n\n  const routeRef = useRef([]);\n\n  const setRoute = newRoute => {\n    routeRef.current = newRoute;\n  };\n\n  const route = routeRef.current;\n  const [errorMessage, setErrorMessage] = useState(\"\");\n  const CANVAS_SIDE_LENGTH = 450;\n  const CLICK_RANGE = 5; // The below constant is used to store the top left corner of the view window and its side length\n\n  const [mapWindow, setMapWindow] = useState([41.8320, -71.4070, 0.0113]);\n  const topLat = mapWindow[0];\n  const leftLon = mapWindow[1];\n  const latLonRange = mapWindow[2];\n  let mouseDownX;\n  let mouseDownY;\n  /*\n   * We expect latitudes within the map range to be LESS than the topLat\n   * We expect longitudes within the map range to be GREATER than the leftLon\n   * In order to get bottomLat or rightLon, just subtract latLonRange from topLat, or add it to leftLon\n   */\n\n  const TILE_WIDTH = 0.0016; // this is an arbitrarily chosen-value, but it works well\n  // The below constants track how far the user has loaded tiles in each direction\n\n  const topmostTileLat = useRef(topLat);\n  const leftmostTileLon = useRef(leftLon);\n  const bottommostTileLat = useRef(topmostTileLat.current);\n  const rightmostTileLon = useRef(leftmostTileLon.current);\n  const tilesLoadedRef = useRef([]); // Tiles should be JavaScript objects with properties topLat, leftLon, and an [] of ways\n  // Ways should be length-4 list of Doubles: [lat1, lon1, lat2, lon2]\n\n  const canvasRef = useRef();\n  const ctxRef = useRef();\n  const reloadCounter = useRef(0);\n  /*\n   * The above constant is used to stop various processes when changes to the map\n   * make the previous function calls redundant (processes such as drawing the map\n   * or loading tiles that may now be beyond the scope of the screen)\n   */\n\n  /**\n   * Code to run when the page loads for the first time.\n   */\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    canvas.width = CANVAS_SIDE_LENGTH;\n    canvas.height = CANVAS_SIDE_LENGTH;\n    ctxRef.current = canvas.getContext(\"2d\");\n  }, []);\n  /**\n   * Code to run whenever the component reloads.\n   */\n\n  useEffect(() => {\n    reloadCounter.current += 1;\n\n    if (startStreet1 !== \"\" && startStreet2 !== \"\") {\n      requestNode(startStreet1, startStreet2, startLatLon.current, setStartLatLon);\n    }\n\n    if (destStreet1 !== \"\" && destStreet2 !== \"\" && errorMessage === \"\") {\n      requestNode(destStreet1, destStreet2, destLatLon.current, setDestLatLon);\n    }\n\n    redrawMap(reloadCounter.current);\n  });\n\n  async function loadTilesWithin(topLatLimit, leftLonLimit, bottomLatLimit, rightLonLimit, reloadNum) {\n    /*\n     * We expect latitudes within the map range to be LESS than the topLat\n     * We expect longitudes within the map range to be GREATER than the leftLon\n     */\n    let newTile;\n    let curLat = topLatLimit;\n    let curLon = leftLonLimit;\n\n    while (curLon < rightLonLimit) {\n      while (curLat > bottomLatLimit) {\n        if (reloadNum !== reloadCounter.current) {\n          return;\n        } // Check if the tile has already been loaded\n\n\n        if (!tileLoaded(curLat, curLon, tilesLoadedRef.current)) {\n          const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n          newTile = {\n            \"tileLat\": curLat,\n            \"tileLon\": curLon,\n            \"ways\": ways\n          };\n          drawTile(newTile);\n          tilesLoadedRef.current.push(newTile);\n        }\n\n        curLat -= TILE_WIDTH;\n      }\n\n      if (curLat < bottommostTileLat.current) {\n        bottommostTileLat.current = curLat;\n      }\n\n      curLat = topLatLimit;\n      curLon += TILE_WIDTH;\n    }\n\n    if (curLon > rightmostTileLon.current) {\n      rightmostTileLon.current = curLon;\n    }\n  }\n  /**\n   * Determines whether a tile with a given lat/lon coordinate has been cached on the client-side\n   * or note. Returns a boolean.\n   * @param lat - latitude coordinate of tile to check\n   * @param lon - longitude coordinate of tile to check\n   * @param loadedTiles - list of tiles that have been loaded already\n   * @returns {boolean} - whether or not the tile is cached already\n   */\n\n\n  function tileLoaded(lat, lon, loadedTiles) {\n    let loaded = false;\n    let checkTile;\n\n    for (let i = 0; i < loadedTiles.length; i++) {\n      checkTile = loadedTiles[i];\n      loaded = loaded || checkTile[\"tileLat\"] === lat && checkTile[\"tileLon\"] === lon;\n    }\n\n    return loaded;\n  }\n  /**\n   * Makes an axios request.\n   */\n\n\n  async function requestRoute() {\n    const startLat = startLatLon.current[0];\n    const startLon = startLatLon.current[1];\n    const destLat = destLatLon.current[0];\n    const destLon = destLatLon.current[1];\n    const toSend = {\n      srclat: startLat,\n      srclong: startLon,\n      destlat: destLat,\n      destlong: destLon\n    };\n    const config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    const res = await axios.post(\"http://localhost:4567/route\", toSend, config);\n    return res[\"data\"][\"route\"];\n  } // uses post request to get ways within bounding box\n\n\n  async function requestWays(coordinates) {\n    const toSend = {\n      lat1: coordinates[0],\n      long1: coordinates[1],\n      lat2: coordinates[2],\n      long2: coordinates[3]\n    };\n    const config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    const res = await axios.post(\"http://localhost:4567/ways\", toSend, config);\n    return res[\"data\"][\"ways\"];\n  }\n  /**\n   * Makes an axios request to get the coordinates of the node nearest to a clicked lat and lon.\n   */\n\n\n  function requestNearest(lat, lon, latLonSetter, streetSetter) {\n    const toSend = {\n      lat: lat,\n      lon: lon\n    };\n    const config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    axios.post(\"http://localhost:4567/nearest\", toSend, config).then(response => {\n      return response.data;\n    }).then(data => {\n      const newLat = data[\"nearestLat\"];\n      const newLon = data[\"nearestLon\"];\n      return [newLat, newLon];\n    }).then(newCoord => {\n      streetSetter([\"\", \"\"]);\n      latLonSetter(newCoord);\n      setRoute([]);\n      setErrorMessage(\"\");\n    }).catch(function (error) {\n      console.log(error);\n    });\n  }\n\n  const requestNode = (street1, street2, storedLatLon, latLonSetter) => {\n    const toSend = {\n      street1: street1,\n      street2: street2\n    };\n    const config = {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        'Access-Control-Allow-Origin': '*'\n      }\n    };\n    axios.post(\"http://localhost:4567/intersection\", toSend, config).then(response => {\n      return response.data;\n    }).then(data => {\n      if (data[\"error\"] !== \"\") {\n        if (data[\"error\"] !== errorMessage) {\n          latLonSetter([\"\", \"\"]);\n          setRoute([]);\n          setErrorMessage(data[\"error\"]);\n        }\n      } else {\n        const newLat = data[\"lat\"];\n        const newLon = data[\"lon\"];\n        const storedLat = storedLatLon[0];\n        const storedLon = storedLatLon[1];\n\n        if (newLat !== storedLat || newLon !== storedLon) {\n          latLonSetter([newLat, newLon]);\n          setRoute([]);\n          setErrorMessage(\"\");\n        }\n      }\n    }).catch(function (error) {\n      console.log(error);\n    });\n  };\n\n  async function clearLoadTiles(reloadNum) {\n    const tilesLoadedTemp = tilesLoadedRef.current; // First, purge old tiles\n\n    const mapBoundaries = getMapBoundaries(); //these are backwards\n\n    const bottomLat = mapBoundaries[2];\n    const rightLon = mapBoundaries[3];\n    let saveTiles = []; // Iterate over all the loaded tiles and see if they're still useful\n\n    for (let i = 0; i < tilesLoadedTemp.length; i++) {\n      const checkTile = tilesLoadedTemp[i];\n      const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH); // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n\n      const tileTopLat = tileBoundaries[0];\n      const tileLeftLon = tileBoundaries[1];\n      const tileBottomLat = tileBoundaries[2];\n      const tileRightLon = tileBoundaries[3];\n      /*\n       * We expect latitudes within the map range to be LESS than the topLat\n       * We expect longitudes within the map range to be GREATER than the leftLon\n       */\n\n      const deleteTile = tileBottomLat > topLat || tileTopLat < bottomLat || tileRightLon < leftLon || tileLeftLon > rightLon;\n\n      if (!deleteTile) {\n        drawTile(tilesLoadedTemp[i]);\n        saveTiles.push(checkTile);\n      }\n    }\n\n    tilesLoadedRef.current = saveTiles; // Update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n    // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n\n    while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[2] > topLat) {\n      // Adjusting loaded top boundary\n      topmostTileLat.current -= TILE_WIDTH;\n    }\n\n    while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[3] < leftLon) {\n      // Adjusting loaded left boundary\n      leftmostTileLon.current += TILE_WIDTH;\n    }\n\n    while (bottommostTileLat.current < bottomLat) {\n      // Adjusting loaded bottom boundary\n      bottommostTileLat.current += TILE_WIDTH;\n    }\n\n    while (rightmostTileLon.current > rightLon) {\n      // Adjusting loaded right boundary\n      rightmostTileLon.current -= TILE_WIDTH;\n    } // Now, expand the loaded-tile boundaries to fill the gaps at the edges of the map\n\n\n    while (leftmostTileLon.current > leftLon) {\n      // Gap at left\n      leftmostTileLon.current -= TILE_WIDTH;\n    }\n\n    while (topmostTileLat.current < topLat) {\n      // Gap at top\n      topmostTileLat.current += TILE_WIDTH;\n    }\n\n    while (bottommostTileLat.current >= bottomLat) {\n      // Gap at bottom\n      bottommostTileLat.current -= TILE_WIDTH;\n    }\n\n    while (rightmostTileLon.current <= rightLon) {\n      // Gap at right\n      rightmostTileLon.current += TILE_WIDTH;\n    }\n\n    await loadTilesWithin(topmostTileLat.current, leftmostTileLon.current, bottommostTileLat.current, rightmostTileLon.current, reloadNum);\n  }\n  /**\n   * Function to re-render the current state of the map.\n   * @param reloadNum a constant to allow the clearLoadTiles to quit early if\n   * a new page state might make its work redundant.\n   */\n\n\n  async function redrawMap(reloadNum) {\n    clearCanvas();\n\n    if (reloadNum !== reloadCounter.current) {\n      // Quit early if the page has been reloaded\n      return;\n    }\n\n    await clearLoadTiles(reloadNum);\n\n    if (reloadNum !== reloadCounter.current) {\n      // Quit early if the page has been reloaded\n      return;\n    }\n\n    drawStartEndCircles();\n\n    if (reloadNum !== reloadCounter.current) {\n      // Quit early if the page has been reloaded\n      return;\n    }\n\n    drawRoute();\n  }\n  /**\n   * Code to turn lat/lon coordinates into pixel coordinates for the canvas:\n   * takes in a latitude and longitude coordinate, returns a length-2 list with the\n   * corresponding pixel position on the canvas [left, top]\n   * @param lat - the latitude coordinate to turn into a pixel left coordinate\n   * @param lon - the longitude coordinate to turn into a pixel top coordinate\n   * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n   */\n\n\n  function latLonCoordToPix(lat, lon) {\n    const normalizedLat = topLat - lat;\n    const normalizedLon = lon - leftLon;\n    /*\n     * Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n     * We expect latitudes within the map range to be LESS than the topLat\n     * We expect longitudes within the map range to be GREATER than the leftLon\n     */\n    // REMEMBER: lat is y-value, lon is x-value!\n\n    return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n  }\n  /**\n   * Converts a single latitude/longitude coordinate value into a pixel value.\n   * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n   * @returns {number} the pixel conversion of the lat/lon value\n   */\n\n\n  function pixIfy(latLonVal) {\n    const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n    return latLonVal * pixOverLatLonFactor;\n  }\n  /**\n   * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n   * and longitude coordinate.\n   * Returns a length-2 list with [lat, lon].\n   * @param left - the pixel left coordinate to turn into map latitude\n   * @param top - the pixel top coordinate to turn into map longitude\n   * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n   */\n\n\n  function pixCoordToLatLon(left, top) {\n    const canvas = canvasRef.current;\n    const normalizedLeft = left - canvas.offsetLeft;\n    const normalizedTop = top - canvas.offsetTop;\n    const returnLat = topLat - latLonIfy(normalizedTop);\n    const returnLon = leftLon + latLonIfy(normalizedLeft); // REMEMBER: lat is y-value, lon is x-value!\n\n    return [returnLat, returnLon];\n  }\n  /**\n   * Turns a single value in pixels into a value in latitude/longitude coordinates.\n   * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n   * @returns {number} the lat/lon conversion of the pixel value\n   */\n\n\n  function latLonIfy(pixVal) {\n    const latLonOverPixFactor = latLonRange / CANVAS_SIDE_LENGTH;\n    return pixVal * latLonOverPixFactor;\n  }\n  /**\n   * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n   * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of the current map frame.\n   */\n\n\n  function getMapBoundaries() {\n    return getBoundingBox(topLat, leftLon, latLonRange);\n  }\n  /**\n   * Get the lat/lon boundaries of a passed square area with unknown side length.\n   * @param boxtopLat latitude coordinate of the northwest corner\n   * @param boxleftLon longitude coordinate of the northwest corner\n   * @param boxRange side length, in terms of lat/lon coordinates\n   * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n   * and longitude coordinates of the northwest and southeast corners of a passed square.\n   */\n\n\n  function getBoundingBox(boxtopLat, boxleftLon, boxRange) {\n    // REMEMBER: lat is y-value, lon is x-value!\n    return [boxtopLat, boxleftLon, boxtopLat - boxRange, boxleftLon + boxRange];\n  }\n  /**\n   * Function called on a mouseUp event: first determines whether the user clicked\n   * or dragged, then either requests the nearest node to a click or shifts the map to\n   * reflect a drag.\n   * @param mouseUpX pageX coordinate of the mouseup event\n   * @param mouseUpY pageY coordinate of the mouseup event\n   */\n\n\n  function handleClickOrDrag(mouseUpX, mouseUpY) {\n    const startLat = startLatLon.current[0];\n    const xChange = mouseUpX - mouseDownX; // positive if the map is dragged to the right\n\n    const yChange = mouseUpY - mouseDownY; // positive if the map is dragged downwards\n\n    /*\n     * We expect latitudes within the map range to be LESS than the topLat\n     * We expect longitudes within the map range to be GREATER than the leftLon\n     */\n\n    if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n      // This was a click!\n      const latLonCoord = pixCoordToLatLon(mouseUpX, mouseUpY);\n\n      if (startLat === \"\") {\n        console.log(\"no starting node inputted\");\n        requestNearest(latLonCoord[0], latLonCoord[1], setStartLatLon, setStartStreets);\n      } else {\n        // Override the destination point, if the start of the route is already\n        // selected\n        requestNearest(latLonCoord[0], latLonCoord[1], setDestLatLon, setDestStreets);\n      }\n    } else {\n      // This was a drag!\n      // REMEMBER: lat is y-value, lon is x-value!\n      const newLeftLon = leftLon - latLonIfy(xChange);\n      /*\n       * positive values, dragging the map to the right\n       * moves the previous leftLon rightwards\n       * meaning that the new leftLon should be less than the previous leftLon\n       */\n\n      const newTopLat = topLat + latLonIfy(yChange);\n      /*\n       * positive values, dragging the map downwards\n       * moves the previous topLat downwards\n       * meaning that the new topLat should be greater than the previous topLat\n       */\n\n      const newMapWindow = [newTopLat, newLeftLon, mapWindow[2]];\n      setMapWindow(newMapWindow);\n    }\n  }\n  /**\n   * Function called on a scroll event: calculates the new dimensions of the window\n   * as well as the top coordinates, so that the window zooms in and out centered\n   * on the mouse position.\n   *\n   * @param zoomedOut boolean with value true if the scroll direction was down\n   * @param mouseX pageX coordinate of the mouse current position\n   * @param mouseY pageY coordinate of the mouse current position\n   */\n\n\n  function handleZoomInOut(zoomedOut, mouseX, mouseY) {\n    const mouseLatLonCoord = pixCoordToLatLon(mouseX, mouseY);\n    const zoomLatNormalized = topLat - mouseLatLonCoord[0];\n    const zoomLonNormalized = mouseLatLonCoord[1] - leftLon;\n    const latFraction = zoomLatNormalized / latLonRange;\n    const lonFraction = zoomLonNormalized / latLonRange;\n    /*\n     * We expect latitudes within the map range to be LESS than the topLat\n     * We expect longitudes within the map range to be GREATER than the leftLon\n     */\n\n    if (zoomedOut) {\n      const stepSize = latLonRange * 1.05 - latLonRange;\n      const newLatLonRange = latLonRange + stepSize; // We're zooming out, so the topLat should move upwards\n\n      const newTopLat = topLat + latFraction * stepSize; // and leftLon should move leftwards\n\n      const newLeftLon = leftLon - lonFraction * stepSize;\n      const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n      setMapWindow(newMapWindow);\n    } else {\n      const stepSize = latLonRange - latLonRange * 0.95;\n      const newLatLonRange = latLonRange - stepSize; // We're zooming in, so the topLat should move downwards\n\n      const newTopLat = topLat - latFraction * stepSize; // and leftLon should move inwards\n\n      const newLeftLon = leftLon + lonFraction * stepSize;\n      const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n      setMapWindow(newMapWindow);\n    }\n  }\n  /**\n   * Simple method to erase everything currently drawn on the canvas.\n   */\n\n\n  function clearCanvas() {\n    const ctx = ctxRef.current;\n    const canvas = canvasRef.current;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n  /**\n   * Simple wrapper function to handle drawing a single tile of way data.\n   * @param tileToDraw the cached tile to draw\n   */\n\n\n  function drawTile(tileToDraw) {\n    tileToDraw[\"ways\"].forEach(traceWay);\n  }\n  /**\n   * Simple method that draws a circle of passed radius, centered on a given latitude\n   * and longitude coordinate on the map.\n   *\n   * @param lat latitude coordinate of the circle center\n   * @param lon longitude coordinate of the circle center\n   * @param radius pixel radius for the circle\n   */\n\n\n  function drawCircle(lat, lon, radius) {\n    const ctx = ctxRef.current;\n    const pixCoord = latLonCoordToPix(lat, lon);\n    ctx.strokeStyle = \"red\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(pixCoord[0], pixCoord[1], radius, 0, 2 * Math.PI);\n    ctx.stroke();\n  }\n  /**\n   * Simple method that checks whether the start and end nodes have been inputted,\n   * and if so, draws a circle around them.\n   */\n\n\n  function drawStartEndCircles() {\n    const startLat = startLatLon.current[0];\n    const startLon = startLatLon.current[1];\n    const destLat = destLatLon.current[0];\n    const destLon = destLatLon.current[1]; // And add the circles for the selected start/destination!\n\n    const radius = pixIfy(latLonRange / 100);\n\n    if (!(startLon.toString() === \"\" || startLat.toString() === \"\")) {\n      // drawing start circle\n      drawCircle(startLat, startLon, radius);\n    }\n\n    if (!(destLon.toString() === \"\" || destLat.toString() === \"\")) {\n      // drawing destination circle\n      drawCircle(destLat, destLon, radius);\n    }\n  }\n  /**\n   * Draws a single highlighted way for the selected route.\n   * @param way - the way to draw in highlight\n   */\n\n\n  function traceRoute(way) {\n    const ctx = ctxRef.current;\n    const startLatCoord = way[\"startLat\"];\n    const startLonCoord = way[\"startLong\"];\n    const pixStart = latLonCoordToPix(startLatCoord, startLonCoord);\n    ctx.fillStyle = \"blue\";\n    ctx.strokeStyle = \"blue\";\n    ctx.lineWidth = 4;\n    ctx.beginPath();\n    ctx.moveTo(pixStart[0], pixStart[1]);\n    const endLatCoord = way[\"destLat\"];\n    const endLongCoord = way[\"destLong\"];\n    const pixEnd = latLonCoordToPix(endLatCoord, endLongCoord);\n    ctx.lineTo(pixEnd[0], pixEnd[1]);\n    ctx.stroke();\n  }\n  /**\n   * Draws a single passed way on the canvas, with the color and width\n   * selected based on its type.\n   * @param way - the way to draw\n   */\n\n\n  function traceWay(way) {\n    const ctx = ctxRef.current;\n    const startLatCoord = Number(way[\"startLat\"]);\n    const startLonCoord = Number(way[\"startLong\"]);\n    const pixStart = latLonCoordToPix(startLatCoord, startLonCoord);\n\n    switch (way[\"type\"]) {\n      case 'residential':\n        ctx.fillStyle = \"green\";\n        ctx.strokeStyle = \"green\";\n        ctx.lineWidth = 1.5;\n        break;\n\n      case 'service':\n        ctx.fillStyle = \"dimgrey\";\n        ctx.strokeStyle = \"dimgrey\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'secondary':\n        ctx.fillStyle = \"olivedrab\";\n        ctx.strokeStyle = \"olivedrab\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'track':\n        ctx.fillStyle = \"palegoldenrod\";\n        ctx.strokeStyle = \"palegoldenrod\";\n        ctx.lineWidth = 2;\n        break;\n\n      case 'tertiary':\n        ctx.fillStyle = \"lightgreen\";\n        ctx.strokeStyle = \"lightgreen\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'trunk':\n        ctx.fillStyle = \"DarkOrchid\";\n        ctx.strokeStyle = \"DarkOrchid\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'primary':\n        ctx.fillStyle = \"goldenrod\";\n        ctx.strokeStyle = \"goldenrod\";\n        ctx.lineWidth = 2;\n        break;\n\n      case 'secondary_link':\n        ctx.fillStyle = \"crimson\";\n        ctx.strokeStyle = \"crimson\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'trunk_link':\n        ctx.fillStyle = \"Lavender\";\n        ctx.strokeStyle = \"Lavender\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'path':\n        ctx.fillStyle = \"LightBlue\";\n        ctx.strokeStyle = \"LightBlue\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'motorway_link':\n        ctx.fillStyle = \"gold\";\n        ctx.strokeStyle = \"gold\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'motorway':\n        ctx.fillStyle = \"orange\";\n        ctx.strokeStyle = \"orange\";\n        ctx.lineWidth = 1.5;\n        break;\n\n      case 'cycleway':\n        ctx.fillStyle = \"darkkhaki\";\n        ctx.strokeStyle = \"darkkhaki\";\n        ctx.lineWidth = 1.5;\n        break;\n\n      case 'tertiary_link':\n        ctx.fillStyle = \"MediumPurple\";\n        ctx.strokeStyle = \"MediumPurple\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'footway':\n        ctx.fillStyle = \"burlywood\";\n        ctx.strokeStyle = \"burlywood\";\n        ctx.lineWidth = 1.5;\n        break;\n\n      case 'primary_link':\n        ctx.fillStyle = \"Pink\";\n        ctx.strokeStyle = \"Pink\";\n        ctx.lineWidth = 2;\n        break;\n\n      case 'pedestrian':\n        ctx.fillStyle = \"wheat\";\n        ctx.strokeStyle = \"wheat\";\n        ctx.lineWidth = 1.5;\n        break;\n\n      case 'steps':\n        ctx.fillStyle = \"PaleVioletRed\";\n        ctx.strokeStyle = \"PaleVioletRed\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'construction':\n        ctx.fillStyle = \"Red\";\n        ctx.strokeStyle = \"Red\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'living_street':\n        ctx.fillStyle = \"SkyBlue\";\n        ctx.strokeStyle = \"SkyBlue\";\n        ctx.lineWidth = 1;\n        break;\n\n      case 'road':\n        ctx.fillStyle = \"Yellow\";\n        ctx.strokeStyle = \"Yellow\";\n        ctx.lineWidth = 1.5;\n        break;\n\n      default:\n        ctx.fillStyle = \"Gray\";\n        ctx.strokeStyle = \"Gray\";\n        ctx.lineWidth = 0.5;\n    }\n\n    ctx.beginPath();\n    ctx.moveTo(pixStart[0], pixStart[1]);\n    const endLatCoord = Number(way[\"destLat\"]);\n    const endLongCoord = Number(way[\"destLong\"]);\n    const pixEnd = latLonCoordToPix(endLatCoord, endLongCoord);\n    ctx.lineTo(pixEnd[0], pixEnd[1]);\n    ctx.stroke();\n  }\n  /**\n   * Wrapper function for requestRoute that handles error checking and prepares the\n   * map display window after the route has been returned.\n   */\n\n\n  async function getRoute() {\n    const startLat = startLatLon.current[0];\n    const startLon = startLatLon.current[1];\n    const destLat = destLatLon.current[0];\n    const destLon = destLatLon.current[1];\n\n    if (startLat.toString() === \"\" || startLon.toString() === \"\" || destLat.toString() === \"\" || destLon.toString() === \"\") {\n      setErrorMessage(\"ERROR: Please enter both start and end locations\");\n    }\n\n    const routeTemp = await requestRoute();\n    setRoute(routeTemp);\n\n    if (routeTemp.length === 0) {\n      setErrorMessage(\"ERROR: No route found  between these two points.\");\n      return;\n    } // Now we'll auto-zoom to a proper display size!\n\n    /*\n     * We expect latitudes within the map range to be LESS than the topLat\n     * We expect longitudes within the map range to be GREATER than the leftLon\n     */\n\n\n    const latRange = Math.abs(startLat - destLat);\n    const lonRange = Math.abs(startLon - destLon);\n    const routeTopLat = Math.max(startLat, destLat);\n    const routeLeftLon = Math.min(startLon, destLon);\n    const maxRange = Math.max(latRange, lonRange);\n    const centerLatPadding = (maxRange - latRange) / 2.0;\n    const centerLonPadding = (maxRange - lonRange) / 2.0;\n    const overallPadding = 0.2 * maxRange; // We'll add a border of 20% of the longest dimension of the path\n\n    const newTopLat = routeTopLat + centerLatPadding + overallPadding;\n    const newLeftLon = routeLeftLon - centerLonPadding - overallPadding;\n    const newLatLonRange = maxRange + 2 * overallPadding;\n    const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n    setMapWindow(newMapWindow);\n  }\n  /**\n   * Wrapper function to draw the entire selected route.\n   */\n\n\n  function drawRoute() {\n    for (const way of route) {\n      traceRoute(way);\n    }\n  }\n  /**\n   * Function called when the clear map button is clicked. Clears all selected information,\n   * including points selected for the start or end of a route.\n   */\n\n\n  function clearMap() {\n    // clear out the clicked/entered-in points\n    setStartLatLon([\"\", \"\"]);\n    setDestLatLon([\"\", \"\"]);\n    setStartStreets([\"\", \"\"]);\n    setDestStreets([\"\", \"\"]); // also clear out any loaded route\n\n    setRoute([]);\n    setErrorMessage(\"\");\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"routeMap\",\n    children: [/*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Starting Street\",\n      boxVal: startStreet1,\n      change: setStartStreet1\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 834,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Starting Cross Street\",\n      boxVal: startStreet2,\n      change: setStartStreet2\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 835,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Street\",\n      boxVal: destStreet1,\n      change: setDestStreet1\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 836,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TextBox, {\n      label: \"Destination Cross Street\",\n      boxVal: destStreet2,\n      change: setDestStreet2\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 837,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: getRoute,\n      children: \"Map Route\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 838,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: clearMap,\n      children: \"Clear Map\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 839,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 840,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(ErrorBox, {\n      text: errorMessage\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 841,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 842,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      onMouseDown: event => {\n        mouseDownX = event.pageX;\n        mouseDownY = event.pageY;\n      },\n      onMouseUp: event => {\n        handleClickOrDrag(event.pageX, event.pageY);\n      },\n      onWheel: event => {\n        event.stopPropagation(); // Scrolling!\n\n        if (event.deltaY < 0) {\n          // Scrolling up\n          handleZoomInOut(false, event.pageX, event.pageY);\n        } else {\n          // Scrolling down\n          handleZoomInOut(true, event.pageX, event.pageY);\n        }\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 843,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 833,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Route, \"h8h8YnyOMyK2pbl+Bq7W/TiLHps=\");\n\n_c = Route;\nexport default Route;\n\nvar _c;\n\n$RefreshReg$(_c, \"Route\");","map":{"version":3,"sources":["/Users/riarajesh/cs0320/maps-3-4-mhendrik-rrajesh/maps-frontend/src/Route.js"],"names":["TextBox","ErrorBox","React","useState","useEffect","useRef","axios","Route","startLatLon","setStartLatLon","newStartLatLon","current","destLatLon","setDestLatLon","newdestLatLon","startStreets","setStartStreets","startStreet1","startStreet2","setStartStreet1","newStartStreet1","setStartStreet2","newStartStreet2","destStreets","setDestStreets","destStreet1","destStreet2","setDestStreet1","newDestStreet1","setDestStreet2","newDestStreet2","routeRef","setRoute","newRoute","route","errorMessage","setErrorMessage","CANVAS_SIDE_LENGTH","CLICK_RANGE","mapWindow","setMapWindow","topLat","leftLon","latLonRange","mouseDownX","mouseDownY","TILE_WIDTH","topmostTileLat","leftmostTileLon","bottommostTileLat","rightmostTileLon","tilesLoadedRef","canvasRef","ctxRef","reloadCounter","canvas","width","height","getContext","requestNode","redrawMap","loadTilesWithin","topLatLimit","leftLonLimit","bottomLatLimit","rightLonLimit","reloadNum","newTile","curLat","curLon","tileLoaded","ways","requestWays","getBoundingBox","drawTile","push","lat","lon","loadedTiles","loaded","checkTile","i","length","requestRoute","startLat","startLon","destLat","destLon","toSend","srclat","srclong","destlat","destlong","config","headers","res","post","coordinates","lat1","long1","lat2","long2","requestNearest","latLonSetter","streetSetter","then","response","data","newLat","newLon","newCoord","catch","error","console","log","street1","street2","storedLatLon","storedLat","storedLon","clearLoadTiles","tilesLoadedTemp","mapBoundaries","getMapBoundaries","bottomLat","rightLon","saveTiles","tileBoundaries","tileTopLat","tileLeftLon","tileBottomLat","tileRightLon","deleteTile","clearCanvas","drawStartEndCircles","drawRoute","latLonCoordToPix","normalizedLat","normalizedLon","pixIfy","latLonVal","pixOverLatLonFactor","pixCoordToLatLon","left","top","normalizedLeft","offsetLeft","normalizedTop","offsetTop","returnLat","latLonIfy","returnLon","pixVal","latLonOverPixFactor","boxtopLat","boxleftLon","boxRange","handleClickOrDrag","mouseUpX","mouseUpY","xChange","yChange","Math","abs","latLonCoord","newLeftLon","newTopLat","newMapWindow","handleZoomInOut","zoomedOut","mouseX","mouseY","mouseLatLonCoord","zoomLatNormalized","zoomLonNormalized","latFraction","lonFraction","stepSize","newLatLonRange","ctx","clearRect","tileToDraw","forEach","traceWay","drawCircle","radius","pixCoord","strokeStyle","lineWidth","beginPath","arc","PI","stroke","toString","traceRoute","way","startLatCoord","startLonCoord","pixStart","fillStyle","moveTo","endLatCoord","endLongCoord","pixEnd","lineTo","Number","getRoute","routeTemp","latRange","lonRange","routeTopLat","max","routeLeftLon","min","maxRange","centerLatPadding","centerLonPadding","overallPadding","clearMap","event","pageX","pageY","stopPropagation","deltaY"],"mappings":"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","sourcesContent":["import './App.css';\nimport TextBox from \"./TextBox\";\nimport ErrorBox from \"./ErrorBox\";\nimport React, {useState, useEffect, useRef} from 'react';\nimport axios from 'axios';\nimport \"react-awesome-button/dist/styles.css\";\n\nfunction Route() {\n    /*\n     * We used useRefs for a large number of variables that were previously useState().\n     * Changes to these variables caused the component to be rerendered often enough\n     * to cause glitches.\n     * However, this is why there are these brief setter functions for all of the useRef()\n     * variables.\n     */\n    const startLatLon = useRef([\"\", \"\"]);\n    const setStartLatLon = (newStartLatLon) => {\n        startLatLon.current = newStartLatLon;\n    }\n    const destLatLon = useRef([\"\", \"\"]);\n    const setDestLatLon = (newdestLatLon) => {\n        destLatLon.current = newdestLatLon;\n    }\n    const [startStreets, setStartStreets] = useState([\"\", \"\"]);\n    const startStreet1 = startStreets[0];\n    const startStreet2 = startStreets[1];\n    const setStartStreet1 = (newStartStreet1) => {\n        setStartStreets([newStartStreet1, startStreet2]);\n    }\n    const setStartStreet2 = (newStartStreet2) => {\n        setStartStreets([startStreet1, newStartStreet2]);\n    }\n    const [destStreets, setDestStreets] = useState([\"\", \"\"]);\n    const destStreet1 = destStreets[0];\n    const destStreet2 = destStreets[1];\n    const setDestStreet1 = (newDestStreet1) => {\n        setDestStreets([newDestStreet1, destStreet2]);\n    }\n    const setDestStreet2 = (newDestStreet2) => {\n        setDestStreets([destStreet1, newDestStreet2]);\n    }\n    const routeRef = useRef([]);\n    const setRoute = (newRoute) => {\n        routeRef.current = newRoute;\n    }\n    const route = routeRef.current;\n    const [errorMessage, setErrorMessage] = useState(\"\");\n    const CANVAS_SIDE_LENGTH = 450;\n    const CLICK_RANGE = 5;\n    // The below constant is used to store the top left corner of the view window and its side length\n    const [mapWindow, setMapWindow] = useState([41.8320, -71.4070, 0.0113])\n    const topLat = mapWindow[0];\n    const leftLon = mapWindow[1];\n    const latLonRange = mapWindow[2];\n    let mouseDownX;\n    let mouseDownY;\n    /*\n     * We expect latitudes within the map range to be LESS than the topLat\n     * We expect longitudes within the map range to be GREATER than the leftLon\n     * In order to get bottomLat or rightLon, just subtract latLonRange from topLat, or add it to leftLon\n     */\n\n    const TILE_WIDTH = 0.0016; // this is an arbitrarily chosen-value, but it works well\n    // The below constants track how far the user has loaded tiles in each direction\n    const topmostTileLat = useRef(topLat);\n    const leftmostTileLon = useRef(leftLon);\n    const bottommostTileLat = useRef(topmostTileLat.current);\n    const rightmostTileLon = useRef(leftmostTileLon.current);\n    const tilesLoadedRef = useRef([]);\n    // Tiles should be JavaScript objects with properties topLat, leftLon, and an [] of ways\n    // Ways should be length-4 list of Doubles: [lat1, lon1, lat2, lon2]\n\n    const canvasRef = useRef();\n    const ctxRef = useRef();\n    const reloadCounter = useRef(0);\n    /*\n     * The above constant is used to stop various processes when changes to the map\n     * make the previous function calls redundant (processes such as drawing the map\n     * or loading tiles that may now be beyond the scope of the screen)\n     */\n\n    /**\n     * Code to run when the page loads for the first time.\n     */\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        canvas.width = CANVAS_SIDE_LENGTH;\n        canvas.height = CANVAS_SIDE_LENGTH;\n        ctxRef.current = canvas.getContext(\"2d\");\n    }, []);\n\n    /**\n     * Code to run whenever the component reloads.\n     */\n    useEffect(() => {\n        reloadCounter.current += 1;\n        if (startStreet1 !== \"\" && startStreet2 !== \"\") {\n            requestNode(startStreet1, startStreet2, startLatLon.current, setStartLatLon);\n        }\n        if (destStreet1 !== \"\" && destStreet2 !== \"\" && errorMessage === \"\") {\n            requestNode(destStreet1, destStreet2, destLatLon.current, setDestLatLon);\n        }\n        redrawMap(reloadCounter.current);\n    })\n\n    async function loadTilesWithin(topLatLimit, leftLonLimit, bottomLatLimit, rightLonLimit, reloadNum) {\n        /*\n         * We expect latitudes within the map range to be LESS than the topLat\n         * We expect longitudes within the map range to be GREATER than the leftLon\n         */\n        let newTile;\n        let curLat = topLatLimit;\n        let curLon = leftLonLimit;\n        while (curLon < rightLonLimit) {\n            while (curLat > bottomLatLimit) {\n                if (reloadNum !== reloadCounter.current) {\n                    return;\n                }\n                // Check if the tile has already been loaded\n                if (!tileLoaded(curLat, curLon, tilesLoadedRef.current)) {\n                    const ways = await requestWays(getBoundingBox(curLat, curLon, TILE_WIDTH));\n                    newTile = {\"tileLat\": curLat, \"tileLon\": curLon, \"ways\": ways};\n                    drawTile(newTile);\n                    tilesLoadedRef.current.push(newTile);\n                }\n\n                curLat -= TILE_WIDTH;\n            }\n            if (curLat < bottommostTileLat.current) {\n                bottommostTileLat.current = curLat;\n            }\n            curLat = topLatLimit;\n            curLon += TILE_WIDTH;\n        }\n        if (curLon > rightmostTileLon.current) {\n            rightmostTileLon.current = curLon;\n        }\n    }\n\n    /**\n     * Determines whether a tile with a given lat/lon coordinate has been cached on the client-side\n     * or note. Returns a boolean.\n     * @param lat - latitude coordinate of tile to check\n     * @param lon - longitude coordinate of tile to check\n     * @param loadedTiles - list of tiles that have been loaded already\n     * @returns {boolean} - whether or not the tile is cached already\n     */\n    function tileLoaded(lat, lon, loadedTiles) {\n        let loaded = false;\n        let checkTile;\n        for (let i = 0; i < loadedTiles.length; i++) {\n            checkTile = loadedTiles[i];\n            loaded = loaded || (checkTile[\"tileLat\"] === lat && checkTile[\"tileLon\"] === lon);\n        }\n        return loaded;\n    }\n\n    /**\n     * Makes an axios request.\n     */\n    async function requestRoute() {\n        const startLat = startLatLon.current[0];\n        const startLon = startLatLon.current[1];\n        const destLat = destLatLon.current[0];\n        const destLon = destLatLon.current[1];\n\n        const toSend = {\n            srclat: startLat,\n            srclong: startLon,\n            destlat: destLat,\n            destlong: destLon\n\n        };\n\n        const config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n        const res = await axios.post(\n            \"http://localhost:4567/route\",\n            toSend,\n            config\n        );\n        return res[\"data\"][\"route\"];\n    }\n\n    // uses post request to get ways within bounding box\n    async function requestWays(coordinates) {\n        const toSend = {\n            lat1: coordinates[0],\n            long1: coordinates[1],\n            lat2: coordinates[2],\n            long2: coordinates[3]\n        };\n        const config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n        const res = await axios.post(\n            \"http://localhost:4567/ways\",\n            toSend,\n            config\n        );\n        return res[\"data\"][\"ways\"];\n    }\n\n    /**\n     * Makes an axios request to get the coordinates of the node nearest to a clicked lat and lon.\n     */\n    function requestNearest(lat, lon, latLonSetter, streetSetter) {\n        const toSend = {\n            lat: lat,\n            lon: lon\n        };\n        const config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n        axios.post(\n            \"http://localhost:4567/nearest\",\n            toSend,\n            config\n        )\n            .then(response => {\n                return response.data;\n            })\n            .then((data) => {\n                const newLat = data[\"nearestLat\"];\n                const newLon = data[\"nearestLon\"];\n                return [newLat, newLon];\n            })\n            .then((newCoord) => {\n                streetSetter([\"\",\"\"]);\n                latLonSetter(newCoord);\n                setRoute([]);\n                setErrorMessage(\"\");\n            })\n            .catch(function (error) {\n                console.log(error);\n            });\n    }\n\n    const requestNode = (street1, street2, storedLatLon, latLonSetter) => {\n        const toSend = {\n            street1: street1,\n            street2: street2\n        };\n        const config = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                'Access-Control-Allow-Origin': '*',\n            }\n        }\n        axios.post(\n            \"http://localhost:4567/intersection\",\n            toSend,\n            config\n        )\n            .then(response => {\n                return response.data;\n            })\n            .then((data) => {\n                if (data[\"error\"] !== \"\") {\n                    if (data[\"error\"] !== errorMessage) {\n                        latLonSetter([\"\", \"\"]);\n                        setRoute([]);\n                        setErrorMessage(data[\"error\"]);\n                    }\n                } else {\n                    const newLat = data[\"lat\"];\n                    const newLon = data[\"lon\"];\n                    const storedLat = storedLatLon[0];\n                    const storedLon = storedLatLon[1];\n                    if (newLat !== storedLat || newLon !== storedLon) {\n                        latLonSetter([newLat, newLon]);\n                        setRoute([]);\n                        setErrorMessage(\"\");\n                    }\n                }\n            })\n            .catch(function (error) {\n                console.log(error);\n            });\n    }\n\n    async function clearLoadTiles(reloadNum) {\n        const tilesLoadedTemp = tilesLoadedRef.current;\n        // First, purge old tiles\n        const mapBoundaries = getMapBoundaries();\n        //these are backwards\n        const bottomLat = mapBoundaries[2];\n        const rightLon = mapBoundaries[3];\n        let saveTiles = [];\n        // Iterate over all the loaded tiles and see if they're still useful\n        for (let i = 0; i < tilesLoadedTemp.length; i++) {\n            const checkTile = tilesLoadedTemp[i];\n            const tileBoundaries = getBoundingBox(checkTile[\"tileLat\"], checkTile[\"tileLon\"], TILE_WIDTH);\n            // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n            const tileTopLat = tileBoundaries[0];\n            const tileLeftLon = tileBoundaries[1];\n            const tileBottomLat = tileBoundaries[2];\n            const tileRightLon = tileBoundaries[3];\n            /*\n             * We expect latitudes within the map range to be LESS than the topLat\n             * We expect longitudes within the map range to be GREATER than the leftLon\n             */\n            const deleteTile = (tileBottomLat > topLat) || (tileTopLat < bottomLat)\n                || (tileRightLon < leftLon) || (tileLeftLon > rightLon);\n            if (!deleteTile) {\n                drawTile(tilesLoadedTemp[i]);\n                saveTiles.push(checkTile);\n            }\n        }\n        tilesLoadedRef.current = saveTiles;\n\n        // Update the loaded tile boundaries (how far in each direction have tiles been loaded?)\n        // getBoundingBox() returns [lat1, lon1, lat2, lon2]\n        while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[2] > topLat) {\n            // Adjusting loaded top boundary\n            topmostTileLat.current -= TILE_WIDTH;\n        }\n        while (getBoundingBox(topmostTileLat.current, leftmostTileLon.current, TILE_WIDTH)[3] < leftLon) {\n            // Adjusting loaded left boundary\n            leftmostTileLon.current += TILE_WIDTH;\n        }\n        while (bottommostTileLat.current < bottomLat) {\n            // Adjusting loaded bottom boundary\n            bottommostTileLat.current += TILE_WIDTH;\n        }\n        while (rightmostTileLon.current > rightLon) {\n            // Adjusting loaded right boundary\n            rightmostTileLon.current -= TILE_WIDTH;\n        }\n\n        // Now, expand the loaded-tile boundaries to fill the gaps at the edges of the map\n        while (leftmostTileLon.current > leftLon) {\n            // Gap at left\n            leftmostTileLon.current -= TILE_WIDTH;\n        }\n        while (topmostTileLat.current < topLat) {\n            // Gap at top\n            topmostTileLat.current += TILE_WIDTH;\n        }\n        while (bottommostTileLat.current >= bottomLat) {\n            // Gap at bottom\n            bottommostTileLat.current -= TILE_WIDTH;\n        }\n        while (rightmostTileLon.current <= rightLon) {\n            // Gap at right\n            rightmostTileLon.current += TILE_WIDTH;\n        }\n        await loadTilesWithin(topmostTileLat.current, leftmostTileLon.current,\n            bottommostTileLat.current, rightmostTileLon.current, reloadNum);\n    }\n\n    /**\n     * Function to re-render the current state of the map.\n     * @param reloadNum a constant to allow the clearLoadTiles to quit early if\n     * a new page state might make its work redundant.\n     */\n    async function redrawMap(reloadNum) {\n        clearCanvas();\n        if (reloadNum !== reloadCounter.current) {\n            // Quit early if the page has been reloaded\n            return;\n        }\n        await clearLoadTiles(reloadNum);\n        if (reloadNum !== reloadCounter.current) {\n            // Quit early if the page has been reloaded\n            return;\n        }\n        drawStartEndCircles();\n        if (reloadNum !== reloadCounter.current) {\n            // Quit early if the page has been reloaded\n            return;\n        }\n        drawRoute();\n    }\n\n    /**\n     * Code to turn lat/lon coordinates into pixel coordinates for the canvas:\n     * takes in a latitude and longitude coordinate, returns a length-2 list with the\n     * corresponding pixel position on the canvas [left, top]\n     * @param lat - the latitude coordinate to turn into a pixel left coordinate\n     * @param lon - the longitude coordinate to turn into a pixel top coordinate\n     * @returns {number[]} the corresponding pixel position on the canvas [left, top]\n     */\n    function latLonCoordToPix(lat, lon) {\n        const normalizedLat = topLat - lat;\n        const normalizedLon = lon - leftLon;\n        /*\n         * Because of weird latitude/longitude rules in the specific hemisphere Rhode Island is in:\n         * We expect latitudes within the map range to be LESS than the topLat\n         * We expect longitudes within the map range to be GREATER than the leftLon\n         */\n\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [pixIfy(normalizedLon), pixIfy(normalizedLat)];\n    }\n\n    /**\n     * Converts a single latitude/longitude coordinate value into a pixel value.\n     * @param latLonVal the lat/lon coordinate to convert to pixel coordinates.\n     * @returns {number} the pixel conversion of the lat/lon value\n     */\n    function pixIfy(latLonVal) {\n        const pixOverLatLonFactor = CANVAS_SIDE_LENGTH / latLonRange;\n        return latLonVal * pixOverLatLonFactor;\n    }\n\n    /**\n     * Code takes in a pageX (NOT canvas x) and pageY and turns it into a latitude\n     * and longitude coordinate.\n     * Returns a length-2 list with [lat, lon].\n     * @param left - the pixel left coordinate to turn into map latitude\n     * @param top - the pixel top coordinate to turn into map longitude\n     * @returns {number[]} the corresponding lat/lon coordinate on the canvas [lat, lon]\n     */\n    function pixCoordToLatLon(left, top) {\n        const canvas = canvasRef.current;\n        const normalizedLeft = left - canvas.offsetLeft;\n        const normalizedTop = top - canvas.offsetTop;\n\n        const returnLat = topLat - latLonIfy(normalizedTop);\n        const returnLon = leftLon + latLonIfy(normalizedLeft);\n\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [returnLat, returnLon];\n    }\n\n    /**\n     * Turns a single value in pixels into a value in latitude/longitude coordinates.\n     * @param pixVal the pixel value to convert to latitude/longitude coordinates.\n     * @returns {number} the lat/lon conversion of the pixel value\n     */\n    function latLonIfy(pixVal) {\n        const latLonOverPixFactor = latLonRange / CANVAS_SIDE_LENGTH;\n        return pixVal * latLonOverPixFactor;\n    }\n\n    /**\n     * Get the lat/lon boundaries of the current map. May be helpful for the ways command.\n     * Returns a length-4 list of [lat1, lon1, lat2, lon2].\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of the current map frame.\n     */\n    function getMapBoundaries() {\n        return getBoundingBox(topLat, leftLon, latLonRange);\n    }\n\n    /**\n     * Get the lat/lon boundaries of a passed square area with unknown side length.\n     * @param boxtopLat latitude coordinate of the northwest corner\n     * @param boxleftLon longitude coordinate of the northwest corner\n     * @param boxRange side length, in terms of lat/lon coordinates\n     * @returns {(*|number)[]} a length-4 list of [lat1, lon1, lat2, lon2], representing the latitude\n     * and longitude coordinates of the northwest and southeast corners of a passed square.\n     */\n    function getBoundingBox(boxtopLat, boxleftLon, boxRange) {\n        // REMEMBER: lat is y-value, lon is x-value!\n        return [boxtopLat, boxleftLon, boxtopLat - boxRange, boxleftLon + boxRange];\n    }\n\n    /**\n     * Function called on a mouseUp event: first determines whether the user clicked\n     * or dragged, then either requests the nearest node to a click or shifts the map to\n     * reflect a drag.\n     * @param mouseUpX pageX coordinate of the mouseup event\n     * @param mouseUpY pageY coordinate of the mouseup event\n     */\n    function handleClickOrDrag(mouseUpX, mouseUpY) {\n        const startLat = startLatLon.current[0];\n\n        const xChange = mouseUpX - mouseDownX; // positive if the map is dragged to the right\n        const yChange = mouseUpY - mouseDownY; // positive if the map is dragged downwards\n        /*\n         * We expect latitudes within the map range to be LESS than the topLat\n         * We expect longitudes within the map range to be GREATER than the leftLon\n         */\n\n        if (Math.abs(xChange) < CLICK_RANGE && Math.abs(yChange) < CLICK_RANGE) {\n            // This was a click!\n            const latLonCoord = pixCoordToLatLon(mouseUpX, mouseUpY);\n            if (startLat === \"\") {\n                console.log(\"no starting node inputted\");\n                requestNearest(latLonCoord[0], latLonCoord[1], setStartLatLon, setStartStreets);\n            } else {\n                // Override the destination point, if the start of the route is already\n                // selected\n                requestNearest(latLonCoord[0], latLonCoord[1], setDestLatLon, setDestStreets);\n            }\n        } else {\n            // This was a drag!\n            // REMEMBER: lat is y-value, lon is x-value!\n            const newLeftLon = leftLon - latLonIfy(xChange);\n            /*\n             * positive values, dragging the map to the right\n             * moves the previous leftLon rightwards\n             * meaning that the new leftLon should be less than the previous leftLon\n             */\n            const newTopLat = topLat + latLonIfy(yChange);\n            /*\n             * positive values, dragging the map downwards\n             * moves the previous topLat downwards\n             * meaning that the new topLat should be greater than the previous topLat\n             */\n            const newMapWindow = [newTopLat, newLeftLon, mapWindow[2]];\n            setMapWindow(newMapWindow);\n        }\n    }\n\n    /**\n     * Function called on a scroll event: calculates the new dimensions of the window\n     * as well as the top coordinates, so that the window zooms in and out centered\n     * on the mouse position.\n     *\n     * @param zoomedOut boolean with value true if the scroll direction was down\n     * @param mouseX pageX coordinate of the mouse current position\n     * @param mouseY pageY coordinate of the mouse current position\n     */\n    function handleZoomInOut(zoomedOut, mouseX, mouseY) {\n        const mouseLatLonCoord = pixCoordToLatLon(mouseX, mouseY);\n        const zoomLatNormalized = topLat - mouseLatLonCoord[0];\n        const zoomLonNormalized = mouseLatLonCoord[1] - leftLon;\n        const latFraction = (zoomLatNormalized / latLonRange);\n        const lonFraction = (zoomLonNormalized / latLonRange);\n\n        /*\n         * We expect latitudes within the map range to be LESS than the topLat\n         * We expect longitudes within the map range to be GREATER than the leftLon\n         */\n        if (zoomedOut) {\n            const stepSize = (latLonRange * 1.05) - latLonRange;\n            const newLatLonRange = latLonRange + stepSize;\n            // We're zooming out, so the topLat should move upwards\n            const newTopLat = topLat + (latFraction * stepSize);\n            // and leftLon should move leftwards\n            const newLeftLon = leftLon - (lonFraction * stepSize);\n            const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n            setMapWindow(newMapWindow);\n        } else {\n            const stepSize = latLonRange - (latLonRange * 0.95);\n            const newLatLonRange = latLonRange - stepSize;\n            // We're zooming in, so the topLat should move downwards\n            const newTopLat = topLat - (latFraction * stepSize);\n            // and leftLon should move inwards\n            const newLeftLon = leftLon + (lonFraction * stepSize);\n            const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n            setMapWindow(newMapWindow);\n        }\n    }\n\n    /**\n     * Simple method to erase everything currently drawn on the canvas.\n     */\n    function clearCanvas() {\n        const ctx = ctxRef.current;\n        const canvas = canvasRef.current;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    /**\n     * Simple wrapper function to handle drawing a single tile of way data.\n     * @param tileToDraw the cached tile to draw\n     */\n    function drawTile(tileToDraw) {\n        tileToDraw[\"ways\"].forEach(traceWay);\n    }\n\n    /**\n     * Simple method that draws a circle of passed radius, centered on a given latitude\n     * and longitude coordinate on the map.\n     *\n     * @param lat latitude coordinate of the circle center\n     * @param lon longitude coordinate of the circle center\n     * @param radius pixel radius for the circle\n     */\n    function drawCircle(lat, lon, radius) {\n        const ctx = ctxRef.current;\n        const pixCoord = latLonCoordToPix(lat, lon);\n        ctx.strokeStyle = \"red\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.arc(pixCoord[0], pixCoord[1], radius, 0, 2 * Math.PI);\n        ctx.stroke();\n    }\n\n    /**\n     * Simple method that checks whether the start and end nodes have been inputted,\n     * and if so, draws a circle around them.\n     */\n    function drawStartEndCircles() {\n        const startLat = startLatLon.current[0];\n        const startLon = startLatLon.current[1];\n        const destLat = destLatLon.current[0];\n        const destLon = destLatLon.current[1];\n\n        // And add the circles for the selected start/destination!\n        const radius = pixIfy(latLonRange / 100);\n        if (!(startLon.toString() === \"\" || startLat.toString() === \"\")) {\n            // drawing start circle\n            drawCircle(startLat, startLon, radius);\n        }\n        if (!(destLon.toString() === \"\" || destLat.toString() === \"\")) {\n            // drawing destination circle\n            drawCircle(destLat, destLon, radius);\n        }\n    }\n\n    /**\n     * Draws a single highlighted way for the selected route.\n     * @param way - the way to draw in highlight\n     */\n    function traceRoute(way) {\n        const ctx = ctxRef.current;\n        const startLatCoord = way[\"startLat\"]\n        const startLonCoord = way[\"startLong\"]\n        const pixStart = latLonCoordToPix(startLatCoord, startLonCoord)\n        ctx.fillStyle = \"blue\";\n        ctx.strokeStyle = \"blue\";\n        ctx.lineWidth = 4;\n        ctx.beginPath();\n        ctx.moveTo(pixStart[0], pixStart[1])\n        const endLatCoord = way[\"destLat\"]\n        const endLongCoord = way[\"destLong\"]\n        const pixEnd = latLonCoordToPix(endLatCoord, endLongCoord)\n        ctx.lineTo(pixEnd[0], pixEnd[1])\n        ctx.stroke();\n    }\n\n    /**\n     * Draws a single passed way on the canvas, with the color and width\n     * selected based on its type.\n     * @param way - the way to draw\n     */\n    function traceWay(way) {\n        const ctx = ctxRef.current;\n        const startLatCoord = Number(way[\"startLat\"])\n        const startLonCoord = Number(way[\"startLong\"])\n        const pixStart = latLonCoordToPix(startLatCoord, startLonCoord)\n        switch (way[\"type\"]) {\n            case 'residential':\n                ctx.fillStyle = \"green\";\n                ctx.strokeStyle = \"green\";\n                ctx.lineWidth = 1.5;\n                break;\n            case 'service':\n                ctx.fillStyle = \"dimgrey\";\n                ctx.strokeStyle = \"dimgrey\";\n                ctx.lineWidth = 1;\n                break;\n            case 'secondary':\n                ctx.fillStyle = \"olivedrab\";\n                ctx.strokeStyle = \"olivedrab\";\n                ctx.lineWidth = 1;\n                break;\n            case 'track':\n                ctx.fillStyle = \"palegoldenrod\";\n                ctx.strokeStyle = \"palegoldenrod\";\n                ctx.lineWidth = 2;\n                break;\n            case 'tertiary':\n                ctx.fillStyle = \"lightgreen\";\n                ctx.strokeStyle = \"lightgreen\";\n                ctx.lineWidth = 1;\n                break;\n            case 'trunk':\n                ctx.fillStyle = \"DarkOrchid\";\n                ctx.strokeStyle = \"DarkOrchid\";\n                ctx.lineWidth = 1;\n                break;\n            case 'primary':\n                ctx.fillStyle = \"goldenrod\";\n                ctx.strokeStyle = \"goldenrod\";\n                ctx.lineWidth = 2;\n                break;\n            case 'secondary_link':\n                ctx.fillStyle = \"crimson\";\n                ctx.strokeStyle = \"crimson\";\n                ctx.lineWidth = 1;\n                break;\n            case 'trunk_link':\n                ctx.fillStyle = \"Lavender\";\n                ctx.strokeStyle = \"Lavender\";\n                ctx.lineWidth = 1;\n                break;\n            case 'path':\n                ctx.fillStyle = \"LightBlue\";\n                ctx.strokeStyle = \"LightBlue\";\n                ctx.lineWidth = 1;\n                break;\n            case 'motorway_link':\n                ctx.fillStyle = \"gold\";\n                ctx.strokeStyle = \"gold\";\n                ctx.lineWidth = 1;\n                break;\n            case 'motorway':\n                ctx.fillStyle = \"orange\";\n                ctx.strokeStyle = \"orange\";\n                ctx.lineWidth = 1.5;\n                break;\n            case 'cycleway':\n                ctx.fillStyle = \"darkkhaki\";\n                ctx.strokeStyle = \"darkkhaki\";\n                ctx.lineWidth = 1.5;\n                break;\n            case 'tertiary_link':\n                ctx.fillStyle = \"MediumPurple\";\n                ctx.strokeStyle = \"MediumPurple\";\n                ctx.lineWidth = 1;\n                break;\n            case 'footway':\n                ctx.fillStyle = \"burlywood\";\n                ctx.strokeStyle = \"burlywood\";\n                ctx.lineWidth = 1.5;\n                break;\n            case 'primary_link':\n                ctx.fillStyle = \"Pink\";\n                ctx.strokeStyle = \"Pink\";\n                ctx.lineWidth = 2;\n                break;\n            case 'pedestrian':\n                ctx.fillStyle = \"wheat\";\n                ctx.strokeStyle = \"wheat\";\n                ctx.lineWidth = 1.5;\n                break;\n            case 'steps':\n                ctx.fillStyle = \"PaleVioletRed\";\n                ctx.strokeStyle = \"PaleVioletRed\";\n                ctx.lineWidth = 1;\n                break;\n            case 'construction':\n                ctx.fillStyle = \"Red\";\n                ctx.strokeStyle = \"Red\";\n                ctx.lineWidth = 1;\n                break;\n            case 'living_street':\n                ctx.fillStyle = \"SkyBlue\";\n                ctx.strokeStyle = \"SkyBlue\";\n                ctx.lineWidth = 1;\n                break;\n            case 'road':\n                ctx.fillStyle = \"Yellow\";\n                ctx.strokeStyle = \"Yellow\";\n                ctx.lineWidth = 1.5;\n                break;\n            default:\n                ctx.fillStyle = \"Gray\";\n                ctx.strokeStyle = \"Gray\";\n                ctx.lineWidth = 0.5;\n        }\n        ctx.beginPath();\n        ctx.moveTo(pixStart[0], pixStart[1])\n        const endLatCoord = Number(way[\"destLat\"])\n        const endLongCoord = Number(way[\"destLong\"])\n        const pixEnd = latLonCoordToPix(endLatCoord, endLongCoord)\n        ctx.lineTo(pixEnd[0], pixEnd[1])\n        ctx.stroke();\n    }\n\n    /**\n     * Wrapper function for requestRoute that handles error checking and prepares the\n     * map display window after the route has been returned.\n     */\n    async function getRoute() {\n        const startLat = startLatLon.current[0];\n        const startLon = startLatLon.current[1];\n        const destLat = destLatLon.current[0];\n        const destLon = destLatLon.current[1];\n        if (startLat.toString() === \"\" || startLon.toString() === \"\"\n        || destLat.toString() === \"\" || destLon.toString() === \"\") {\n            setErrorMessage(\"ERROR: Please enter both start and end locations\");\n        }\n\n        const routeTemp = await requestRoute();\n        setRoute(routeTemp);\n        if (routeTemp.length === 0) {\n            setErrorMessage(\"ERROR: No route found  between these two points.\");\n            return;\n        }\n\n        // Now we'll auto-zoom to a proper display size!\n        /*\n         * We expect latitudes within the map range to be LESS than the topLat\n         * We expect longitudes within the map range to be GREATER than the leftLon\n         */\n        const latRange = Math.abs(startLat - destLat);\n        const lonRange = Math.abs(startLon - destLon);\n        const routeTopLat = Math.max(startLat, destLat);\n        const routeLeftLon = Math.min(startLon, destLon);\n        const maxRange = Math.max(latRange, lonRange);\n        const centerLatPadding = (maxRange - latRange) / 2.0;\n        const centerLonPadding = (maxRange - lonRange) / 2.0;\n        const overallPadding = 0.2 * maxRange; // We'll add a border of 20% of the longest dimension of the path\n        const newTopLat = routeTopLat + centerLatPadding + overallPadding;\n        const newLeftLon = routeLeftLon - centerLonPadding - overallPadding;\n        const newLatLonRange = maxRange + (2 * overallPadding);\n        const newMapWindow = [newTopLat, newLeftLon, newLatLonRange];\n        setMapWindow(newMapWindow);\n    }\n\n    /**\n     * Wrapper function to draw the entire selected route.\n     */\n    function drawRoute() {\n        for (const way of route) {\n            traceRoute(way)\n        }\n    }\n\n    /**\n     * Function called when the clear map button is clicked. Clears all selected information,\n     * including points selected for the start or end of a route.\n     */\n    function clearMap() {\n        // clear out the clicked/entered-in points\n        setStartLatLon([\"\", \"\"]);\n        setDestLatLon([\"\", \"\"]);\n        setStartStreets([\"\", \"\"]);\n        setDestStreets([\"\", \"\"]);\n        // also clear out any loaded route\n        setRoute([]);\n        setErrorMessage(\"\");\n    }\n\n    return (\n        <div className={\"routeMap\"}>\n            <TextBox label={\"Starting Street\"} boxVal={startStreet1} change={setStartStreet1}/>\n            <TextBox label={\"Starting Cross Street\"} boxVal={startStreet2} change={setStartStreet2}/>\n            <TextBox label={\"Destination Street\"} boxVal={destStreet1} change={setDestStreet1}/>\n            <TextBox label={\"Destination Cross Street\"} boxVal={destStreet2} change={setDestStreet2}/>\n            <button onClick={getRoute}>Map Route</button>\n            <button onClick={clearMap}>Clear Map</button>\n            <br/>\n            <ErrorBox text={errorMessage}/>\n            <br/>\n            <canvas ref={canvasRef} onMouseDown={(event) => {\n                mouseDownX = event.pageX;\n                mouseDownY = event.pageY;\n            }} onMouseUp={(event) => {\n                handleClickOrDrag(event.pageX, event.pageY);\n            }} onWheel={(event) => {\n                event.stopPropagation();\n                // Scrolling!\n                if (event.deltaY < 0) {\n                    // Scrolling up\n                    handleZoomInOut(false, event.pageX, event.pageY);\n                } else {\n                    // Scrolling down\n                    handleZoomInOut(true, event.pageX, event.pageY);\n                }\n            }}/>\n        </div>\n    );\n}\n\nexport default Route;"]},"metadata":{},"sourceType":"module"}